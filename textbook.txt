An Active Introduction to
Discrete Mathematics and Algorithms
Charles A. Cusack
cusack@hope.edu
Version 3.0
July 28, 2023

ii
Copyright © 2023 Charles A. Cusack. Permission is granted to copy, distr ibute and/or
modify this document under the terms of the GNU Free Document ation License, Version
1.2 or any later version published by the Free Software Found ation; with no Invariant
Sections, no Front-Cover Texts, and no Back-Cover Texts.  A c opy of the license is
included in the section entitled “GNU Free Documentation Li cense”.
© 2007 David Anthony Santos. Permission is granted to copy, di stribute Copyright
and/or modify this document under the terms of the GNU Free Do cumentation License,
Version 1.2 or any later version published by the Free Softwa re Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cove r Texts.  A copy of the
license is included in the section entitled “GNU Free Docume ntation License”.
History
• 2023: Reordered content, moved some of the proof content thr oughout so it can be used in a
course that does not want to be as proof focused. Edited Histo ry to make it shorter.
• 2021: More edits, added solutions to Reading Questions.
• 2020: Addition of Reading Comprehension Questions. Added m aterial in Chapters 2, 4, 5,
and especially 10. A few new Problems in several chapters. Mi nor edits throughout.
• 2017, 2018, 2019: Minor revisions/fixing of errors. A few add itions/subtractions of material.
• 2016: Minor revisions. Algorithm Analysis chapter had a few additions.
• 2015: Minor revisions. Algorithm Analysis chapter had majo r revisions.
• 2014: A significant revision of the 2013 version, so a title ch ange.
• 2013: Original version titled An Introduction to Discrete Mathematics and Algorithms : This
document draws some content from each of the following.
– Discrete Mathematics Notes, 2008, David A. Santos.
– More Discrete Mathematics, 2007, David A. Santos.
– Number Theory for Mathematical Contests, 2007, David A. San tos.
– Linear Algebra Notes, 2008, David A. Santos.
– Precalculus, An Honours Course, 2008, David Santos.
http://www.opensourcemath.org/books/santos/ , These documents used to be available from
but the site appears not to be no longer available.
About the cover
Pascal’s Triangle shown modulo 5 and modulo 10 made by Charle s Cusack.  For more of Dr.
Cusack’s digital art, go to https://cusack.hope.edu/Art/

iii
Contents
Preface and Note to Instructors v 5.7  Arrays . . . . . . . . . . . . . . . . . . 158
5.8  Quantifiers and Algorithms  . . . . . . 164
How to use this book vii 5.9  The while loop . . . . . . . . . . . . . 167
5.10 More fun with Algorithms . . . . . . . 172
1  Motivation 1
5.11 Reading Comprehension Questions . . 176
1.1  Some Problems . . . . . . . . . . . . . 2
5.12 Problems  . . . . . . . . . . . . . . . . 179
2  Logic 7
6  Sequences and Summations 185 2.1  Propositional Logic . . . . . . . . . . . 7
6.1  Sequences . . . . . . . . . . . . . . . . 185 2.1.1  Basic Definitions . . . . . . . . 7
6.2  Sums and Products . . . . . . . . . . . 199 2.1.2  Compound Propositions . . . . 8
6.3  Reading Comprehension Questions . . 216 2.1.3  Truth Tables  . . . . . . . . . . 14
6.4  Problems  . . . . . . . . . . . . . . . . 218 2.1.4  Precedence Rules . . . . . . . . 16
2.2  Propositional Equivalence . . . . . . . 18
7  Algorithm Analysis 221 2.3  Predicates and Quantifiers . . . . . . . 26
7.1  Asymptotic Notation . . . . . . . . . . 221 2.4  Normal Forms . . . . . . . . . . . . . . 31
7.1.1  The Notations  . . . . . . . . . 221 2.5  Reading Comprehension Questions . . 35
2.6  Problems  . . . . . . . . . . . . . . . . 37 7.1.2  Properties of the Notations  . . 231
7.1.3  Proofs using the definitions . . 235
3  Proof Methods 41 7.1.4  Proofs using limits . . . . . . . 240
3.1  Direct Proofs . . . . . . . . . . . . . . 41 7.2  Common Growth Rates  . . . . . . . . 251
3.2  Implication and Its Friends  . . . . . . 49 7.3  Algorithm Analysis . . . . . . . . . . . 259
3.3  Proof by Contradiction . . . . . . . . . 53
7.3.1  Analyzing Algorithms  . . . . . 260
3.4  Proof by Contraposition . . . . . . . . 61
7.3.2  Common Time Complexities  . 268
3.5  Other Proof Techniques  . . . . . . . . 63
7.3.3  Basic Sorting Algorithms  . . . 272
3.6  If and Only If Proofs . . . . . . . . . . 65
7.3.4  Basic Data Structures . . . . . 277 3.7  Common Errors in Proofs . . . . . . . 67
7.3.5  More Examples . . . . . . . . . 279 3.8  More Practice . . . . . . . . . . . . . . 71
7.3.6  Binary Search . . . . . . . . . . 287 3.9  Reading Comprehension Questions . . 75
7.4  Reading Comprehension Questions . . 292 3.10 Problems  . . . . . . . . . . . . . . . . 77
7.5  Problems  . . . . . . . . . . . . . . . . 294
4  Sets, Functions, and Relations 79
8  Recursion, Recurrences, and 4.1  Sets  . . . . . . . . . . . . . . . . . . . 79
Mathematical Induction 301 4.1.1  Definitions  . . . . . . . . . . . 79
8.1  Mathematical Induction . . . . . . . . 301 4.1.2  Set Operations . . . . . . . . . 86
4.1.3  Set Proofs . . . . . . . . . . . . 93 8.1.1  The Basics  . . . . . . . . . . . 302
4.2  Remainders and Rounding . . . . . . . 96 8.1.2  Equalities/Inequalities . . . . . 308
4.3  Functions  . . . . . . . . . . . . . . . . 99 8.1.3  Variations . . . . . . . . . . . . 311
4.3.1  Definitions  . . . . . . . . . . . 99 8.1.4  Strong Induction . . . . . . . . 315
4.3.2  Function Proofs . . . . . . . . . 107 8.1.5  Induction Errors . . . . . . . . 317
4.4  Partitions and Equivalence Relations . 112 8.1.6  Summary/Tips . . . . . . . . . 319
4.5  Reading Comprehension Questions . . 126 8.2  Recursion . . . . . . . . . . . . . . . . 322
4.6  Problems  . . . . . . . . . . . . . . . . 130 8.3  Solving Recurrence Relations  . . . . . 330
8.3.1  Substitution Method . . . . . . 332 5  Programming Fundamentals and Algo-
8.3.2  Iteration Method . . . . . . . . 336 133 rithms
8.3.3  Master Theorem  . . . . . . . . 344 5.1  Basic Syntax and Algorithms . . . . . 133
8.3.4  Linear Recurrence Relations . . 346 5.2  Remainders and Rounding Revisited . 139
8.4  Analyzing Recursive Algorithms  . . . 350 5.3 If-Else Statements  . . . . . . . . . . 143
8.4.1  Analyzing Quicksort . . . . . . 354 5.4  Logic in programming . . . . . . . . . 147
8.5  Reading Comprehension Questions . . 358 5.5  Bitwise Operations . . . . . . . . . . . 153
5.6  The for loop . . . . . . . . . . . . . . 155 8.6  Problems  . . . . . . . . . . . . . . . . 360

iv
9  Counting 363 10.1 Types of Graphs  . . . . . . . . . . . . 403
9.1  The Sum and Product Rules  . . . . . 363 10.2 Graph Terminology . . . . . . . . . . . 407
9.2  Pigeonhole Principle . . . . . . . . . . 368 10.3 Some Special Graphs . . . . . . . . . . 413
9.3  Permutations and Combinations  . . . 373 10.4 Handshaking Lemma . . . . . . . . . . 416
9.3.1  Permutations without Repeti- 10.5 Graph Representation  . . . . . . . . . 418
tions . . . . . . . . . . . . . . . 374 10.6 Problem Solving with Graphs . . . . . 422
9.3.2  Permutations with Repetitions 376 10.7 Reading Comprehension Questions . . 430
9.3.3  Combinations without Repeti- 10.8 Problems  . . . . . . . . . . . . . . . . 433
tions . . . . . . . . . . . . . . . 380
9.3.4  Combinations with Repetitions 386 11 Reading Question Solutions 435
9.4  Binomial Theorem . . . . . . . . . . . 388
9.5  Inclusion-Exclusion . . . . . . . . . . . 391 12 Exercise Solutions 457
9.6  Reading Comprehension Questions . . 396
GNU Free Documentation License 507 9.7  Problems  . . . . . . . . . . . . . . . . 398
10 Graph Theory 403 Index 511

Preface
This book is an attempt to present some of the most important d iscrete mathematics concepts to
computer science students in the context of algorithms. I wr ote it for use as a textbook for half
of a course on discrete mathematics and algorithms that we offe r at Hope College. Since it was
written for use in this particular context, it is important t o note that the course (and therefore
this book) has as a prerequisite what is typically referred t o as CS2. Thus, it is assumed that the
reader has had one or more programming courses (the example c ode in the book is very much like
C++ or Java), has seen basic data structures (e.g. stacks, qu eues, linked lists, trees), has studied
the standard sorting algorithms (e.g.  selection sort, bubb le sort, insertion sort, quicksort, and
mergesort), and has seen recursion (although that material is reviewed in the book). In addition,
it is assumed that the reader has seen the binary representat ion of integers. Finally, limits and
derivatives are used in a few sections in the chapter on algor ithm analysis because I (and I think
many students) find it much easier to prove bounds using limit s instead of the formal definitions,
assuming they have had calculus. Because the majority of our students have had calculus, I do not
review those concepts. I have found that even the students wh o have not had calculus can tackle
this material with a little extra help, especially given the fact that the derivatives and limits they
need to compute are pretty straightforward. Alternatively , that section can be skipped (although
it makes the next section on growth rates a bit more difficult to read in detail).
Some of the material is drawn from several open-source books by David Santos. Other material
is from handouts I have written and used over the years. I have extensively edited the material
from both sources, both for clarity and to emphasize the conn ections between the material and
algorithms where possible. I have also added a significant am ount of new material. The format of
the material is also significantly different than it was in the o riginal sources.
I should mention that I never met David Santos, who apparentl y died in 2011. I stumbled upon
his books in the summer of 2013 when I was searching for a discr ete mathematics book to use in
a new course. When I discovered that I could adapt his materia l for my own use, I decided to do
so. Since clearly he has no knowledge of this book, he bears no responsibility for any of the edited
content. Any errors or omissions are therefore mine.
I appreciate any feedback you have.  Please send any typos, fo rmatting errors, other errors,
cusack@hope.edu . suggestions, etc., to
I would like to thank the following people for submitting fee dback/errata (listed in no particular
order): Dan Zingaro, Mike Jipping, Steve Ratering, Victori a Gonda, Nathan Vance, Cole Watson,
Kalli Crandell, John Dood, James Cerone, Coty Franklin, Kyl e Magnuson, Karl-Dieter Crisman,
Katie Brudos, Jonathan Senning, Matthew DeJongh, Julian Pa yne, Josiah Brouwer, and probably
several others I forgot to mention (sorry!).  I would also lik e to thank Lydia Won for helping
write/compile solutions for the reading comprehension que stions.
Charles A. Cusack
May, 2019
v

vi
Note to Instructors
The latest version is an attempt at making this textbook more applicable for a wider range
of courses. Although it was originally designed for use in a f ollow-up course to a data structures
course for computer science majors, the current version can also be used for a discrete mathematics
course with few prerequisites.  In order to accomplish this, I attempted to provide a few more
details about topics I previously expected were review (e.g . sorting and searching algorithms), and
in a few places I note that examples or sections can be skipped based on the reader’s background
7.3.4 on basic data structures). Since these changes are yet to be t ested, I appreciate (e.g. Section
any feedback you may have.
In addition to being usable by both computer science student s and a more general audience, I
have rearranged the content so that it can be used in a course t hat has more or less emphasis on
proof writing. For instance, Sections 4.1.3 and 4.3.2 separate proofs involving sets and functions so
they can be skipped if desired. Again, this reordering is yet to be tested, so if you see things that
seem out of place, please let me know.
I am sad to say that I have not had sufficient time to map out prere quisite sections or suggest
which section may be useful in different sorts of courses.  I lea ve it in your capable hands to
determine that for yourself.
Charles A. Cusack
July, 2023

How to use this book
As the title of the book indicates, this is not a book that is ju st to be read. It was written so that
the reader interacts with the material. If you attempt to jus t read what is written and take no part
in the exercises that are embedded throughout, you will like ly get very little out of it. Learning
needs to be active, not passive. The more active you are as you ‘read’ the book, the more you will
get out of it. That will translate to better learning. And it w ill also translate to a higher grade. So
whether you are motivated by learning (which is my hope) or me rely by getting a certain grade,
your path will be the same–use this book as described below.
The content is presented in the following manner. First, con cepts and definitions are given–
generally one at a time. Then one or more examples that illust rate the concept/definition will be
given. After that you will find one or more exercises of variou s kinds. This is where this book differs
from most. Instead of piling on more examples that you merely read and think you understand,
you will be asked to solve some for yourself so that you can be m ore confident that you really do
understand.
Some of the exercises are just called Exercises . They are very similar to the examples, except
that you have to provide the solution.  There are also Fill in the details which provide part of
the solution, but ask you to provide some of the details. The p oint of these is to help you think
about some of the finer details that you might otherwise miss. There are also Questions of various
kinds that get you thinking about the concepts. Finally, the re are Evaluate exercises. These ask
you to look at solutions written by others and determine whet her or not they are correct. More
precisely, your goal is to try to find as many errors in the solu tions as you can. Usually there will
be one or more errors in each solution, but occasionally a cor rect solution will be given, so pay
careful attention to every detail. The point of these exerci ses is to help you see mistakes before
you make them. Many of these exercises are based on solutions from previous students, so they
often represent the common mistakes students make. Hopeful ly if you see someone else make these
mistakes, you will be less likely to make them yourself.
The point of the exercises is to get you thinking about and int eracting with the material. As
you encounter these, you should write your solution in the sp ace provided. After you have written
your solution, you should check your answer with the solutio n provided in the back of the book.
You will get the most out of them if you first do your best to give a complete solution on your own,
and then always check your solution with the one provided to make sure you did it correctly. If
yours is significantly different, make sure you determine whet her or not the differences are just a
matter of choice or if there is something wrong with your solu tion.
If you get stuck on an exercise, you should re-read the previo us material (definitions, examples,
etc.) and see if that helps. Then give it a little more thought . For Fill in the details questions,
sometimes reading what is past a blank will help you figure out what to put there. If you get really
stuck on an exercise, look up the solution and make sure you fu lly understand it. But don’t jump
to the solution too quickly or too often without giving an hon est attempt at solving the exercise
yourself. When you do end up looking up a solution, you should always try to rewrite it in the
space provided in your own words . You should not just copy it word for word. You won’t learn as
much if you do that. Instead, do your best to fully understand the solution. Then, without looking
at the solution, try to re-solve the problem and write your so lution in the space provided. Then
check the solution again to make sure you got it right.
It is highly recommended that you act as your own grader when y ou check your solutions. If
your solution is correct, put a big check mark in the margin. I f there are just a few errors, use a
vii

viii
different colored writing utensil to mark and fix your errors. I f your solution is way off, cross it out
(just put a big ‘X’ through it) and write out your second attem pt, using a separate sheet of paper if
necessary. If you couldn’t get very far without reading the s olution, you should somehow indicate
that. So that you can track your errors, I highly recommend cr ossing out incorrect solutions (or
portions of solutions) instead of erasing them. Doing this w ill also allow you to look back and
determine how well you did as you were working through each ch apter.  It may also help you
determine how to spend your time as you study for exams.
This whole process will help you become better at evaluating your own work. This is important
because you should be confident in your answers, but only when they are correct. Grading yourself
will help you gain confidence when you are correct and help you quickly realize when you are not
correct so that you do not become confident about the wrong thi ngs. Another reason that grading
your solutions is important is so that when you go back to re-r ead any portion of the book, you
will know whether or not what you wrote was correct.
It is important that you read the solutions to the exercises a fter you attempt them, even if you
think your solution is correct. The solutions often provide further insight into the material and
should be regarded as part of any reading assignment given.
Make sure you read carefully. When you come upon an Evaluate exercise, do not mistake it
for an example. Doing so might lead you down the wrong path. Ne ver consider the content of an
Evaluate exercise to be correct unless you have verified with the solut ion that it is really correct.
To be safe, when re-reading, always assume that the Evaluate exercises are incorrect, and never use
them as a model for your own problem solving. To help you, we ha ve tried to differentiate these
from other example and exercise types by using a different font .
There is an expectation that you are able to solve every exerc ise on your own. (Note that I
am talking about the exercises embedded into the chapters, n ot the homework problems at the
end of each chapter.) If there are exercises that you are unab le to complete, you need to get them
cleared up immediately. This might mean asking about them in class, going to see the professor or
a teaching assistant, and/or going to a help center/tutor. W hatever it takes, make sure you have
a clear understanding of how to solve all of them.
Every chapter ends with two sections called Reading Comprehension Questions and Problems .
The Problems sections are exactly what they sound like–a list of problems suitable for working on
in class or given as homework assignments.
All of the Reading Comprehension Questions should be attempted after you have finished read-
ing each section (including completing all of the exercises ). They are sort of the final check of your
comprehension of the material before you move on to solving h omework problems. Although some
of these questions are similar to the exercises in the sectio ns, others are more conceptual in nature.
The majority of them are not meant to be difficult, but rather to test whether you really understand
the material from the section as whole. These can be used as a s tarting point for class discussion,
so be sure to ask about those that you have trouble completing and/or are unsure about.
Space is not given in the book for solutions to the Reading Comprehension Questions , so write
your answers on paper or use a Google Doc or other typesetting software to record your solutions.
(In my classes I have students share a Google Doc with me in whi ch they place their answers to
these questions, adding the most recent answers at the top of the document to make it easier to
find their recent answers. When questions can’t easily be don e in a Google Doc, they write their
solution on paper, scan or take a picture of it, and include th e picture in their Google Doc.)
Solutions to the Reading Comprehension Questions are available in the back of the book. As
with the exercises throughout the book, it is highly recomme nded that you check your answers and
grade your own work, crossing out your solution when you were incorrect (instead of erasing/deleting
it) and replacing it with the correct solution.

Chapter 1: Motivation
The purpose of a discrete mathematics course in the computer science curriculum is to give students
a foundation in some of the mathematical concepts that are fo undational to computer science. By
“foundational,” we mean both that the field of computer scien ce was built upon (some of) them
and that they are used to varying degrees in the study of the mo re advanced topics in computer
science.
Computer science students sometimes complain about taking a discrete mathematics course.
They do not understand the relevance of the material to the re st of the computer science curriculum
or to their future career. This can lead to lack of motivation . They also perceive the material to
be difficult.
To be honest, some of the topics are difficult. But the majority of the material is very acces-
sible to most students. One problem is that learning discret e mathematics takes effort, and when
something doesn’t sink in instantly, some students give up t oo quickly. The perceived difficulty
together with a lack of motivation can lead to lack of effort, wh ich almost always leads to failure.
Even when students expend effort to learn, they can let their pe rceptions get the best of them. If
someone believes something is hard or that they can’t do it, i t often leads to self-fulfilling prophecy.
This is perhaps human nature. On the other hand, if someone be lieves that they can learn the
material and solve the problems, chances are they will. The b ottom line is that a positive attitude
can go a long way.
This book was written in order to ensure that the student has to expend effort while reading it.
The idea is that if you are allowed to simply read but not requi red to interact with the material,
you can easily read a chapter and get nothing out. For instanc e, your brain can go on ‘autopilot’
when something doesn’t sink in and you might get nothing out o f the remainder of your time
reading. By requiring you to solve problems and answer quest ions as you read, your brain is forced
to stay engaged with the material. In addition, when you inco rrectly solve a problem, you know
immediately, giving you a chance to figure out what the mistak e was and correct it before moving
on to the next topic. When you correctly solve a problem, your confidence increases. We strongly
believe that this feature will go a long way to help you more qu ickly and thoroughly learn the
material, assuming you use the book as instructed.
What about the problem of relevance? In other words, what is t he connection between discrete
mathematics and other computer science topics? There are se veral reasons that this connection
is unclear to students. First, we don’t always do a very good j ob of making the connection clear.
We teach a certain set of topics because it is the set of topics that has always been taught in
such a course. We don’t always think about the connection our selves, and it is easy to forget that
this connection is incredibly important to students. Witho ut it, students can suffer from a lack of
motivation to learn the material.
The second reason the connection is unclear is because one of the goals of such a course is
simply to help students to be able to think mathematically. A s they continue in their education
and career, they will most certainly use some of the concepts they learn, yet they may be totally
unaware of the fact that some of their thoughts and ideas are b ased on what they learned in a
discrete mathematics course.  Thus, although the students g ain a benefit from the course, it is
essentially impossible to convince them of this during the c ourse.
The third reason that the connection is unclear is that given the time constraints, it is impossible
to provide all of the foundational mathematics that is relev ant to the advanced computer science
courses and make the connection to those advanced topics clear. Making t hese connections would
1

2 Chapter 1
require an in-depth discussions of the advanced topics. The connections are generally made, either
implicitly or explicitly, in the courses in which the materi al is needed.
This book attempts to address this problem by making connect ions to one set of advanced
topics–the design and analysis of algorithms. This is an ide al application of the discrete mathematics
topics since many of them are used in the design and analysis o f algorithms. We also do not have to
go out of our way too far to provide the necessary background, as we would if we attempted to make
connections to topics such as networking, operating system s, architecture, artificial intelligence,
database, or any number of other advanced topics. As already mentioned, the necessary connections
to those topics will be made when you take courses that focus o n those topics.
The goal of the rest of this chapter is to further motivate you to want to learn the topics that
will be presented in this book. We hope that after reading it y ou will be more motivated. For
some students, the topics are interesting enough on their ow n, whether or not they can be applied
elsewhere. For others, this is not the case. One way or anothe r, you must find motivation to learn
this material.
1.1  Some Problems
In this section we present a number of problems for you to atte mpt to solve. You should make an
honest attempt to solve each. We suspect that most readers wi ll be able to solve at most a few
of them, and even then will probably not use the most straight forward techniques. On the other
hand, after you have finished this book you should be able to so lve most, if not all of them, with
little difficulty.
There are two main reasons we present these problems to you no w. First, we hope they help you
gauge your learning. That is, we hope that you do experience difficulty trying to to solve them now,
but that when you revisit them later, they will seem much easi er. Second, we hope they provide
some motivation for you to learn the content. Although all of these problems may not interest you,
we hope that you are intrigued by at least some of them.
Problem A: The following algorithm supposedly computes the sum of the fi rst n integers. Does
it work properly? If it does not work, explain the problem and fix it.
int n) { sum1ToN(
return n + sum1ToN(n-1);
}
Problem B: The Mega Millions lottery involves picking five different numb ers from 1 to 56, and
one number from 1 to 46. I purchased a ticket last week and was s urprised when none of my
six numbers matched. Should I have been surprised? What are t he chances that a randomly
selected ticket will match none of the numbers?
Problem C: I programmed an algorithm recently to solve an interesting p roblem. The input is an
array of size n . When n = 1, it took 1 second to run. When n = 2, it took 7 seconds. When
n = 3, it took 19 seconds. When n = 4, it took 43 seconds. Assume this pattern continues.
(a) How large of an array can I run the algorithm on in less than 24 hours?
(b) How large can n be if I can wait a year for the answer?
Problem D: Is the following a reasonable implementation of the Quicksort algorithms? In other
words, is it correct, and is it efficient? (Notice that the only difference between this and the
standard algorithm is that this one is implemented on a LinkedList rather than an array .)

Some Problems 3
Quicksort(LinkedList A, int l, int r) {
if (r > l) {
int p = RPartition(A,l,r);
Quicksort(A,l,p-1);
Quicksort(A,p+1,r);
}
}
int RPartition(LinkedList A, int l, int r) {
int piv=l+(rand()%(r-l+1));
swap(A,l,piv);
int i = l+1;
int j = r;
while (1) {
while (A.get(i)  <= A.get(l) && i= A.get(l) && j>l)
j--;
if (i  >= j) {
swap(A,j,l);
return j;
} else {
swap(A,i,j);
}
}
}
void swap(LinkedList A, index i, index j) {
int temp = A.get(i);
A.set(i,A.get(j));
A.set(j,temp);
}
Problem E: I have an algorithm that takes two inputs, n and m . The algorithm treats n differently
when it is less than zero, between zero and 10, and greater tha n 10. It treats m differently
based on whether or not it is even. I want to write some test cod e to make sure the algorithm
works properly for all possible inputs.  What pairs ( n , m ) should I test?  Do these tests
guarantee correctness? Explain.
Problem F: Can the following code be simplified? If so, give equivalent c ode that is as simple as
possible.
if ((!x.size()  <=0   && x.get(0) != 11) || x.size() > 0)
{
if (!(x.get(0)==11 && (x.size() > 13 || x.size() < 13))
&& (x.size() > 0 || x.size() == 13))
{
//do something
}
}
Problem G: In how many ways may we write the number 19 as the sum of three po sitive integer
summands? Here order counts, so, for example, 1 + 17 + 1 is to be regarded different from
17 + 1 + 1.

4 Chapter 1
Problem H: Consider the stoogeSort algorithm given here:
void stoogeSort( int [] A, int L, int R){
if (R<=L) { // Array  has at most  one element so it is sorted
return ;
}
if (A[R]1){ // If the list  has at least 3  elements
int third=(R-L+1)/3;
// Sort first two -thirds stoogeSort(A,L,R-third);
stoogeSort(A,L+third ,R); // Sort last two -thirds
stoogeSort(A,L,R-third); // Sort first two -thirds  again
}
}
(a) Does stoogeSort correctly sort an array of integers?
(b) Is stoogeSort a good sorting algorithm? Specifically, how long does it take , and how
does it compare to other sorting algorithms?
Problem I: A cryptosystem was recently proposed. One of the parameters of the cryptosystem
is a nonnegative integer n , the meaning of which is unimportant here. What is important is
that someone has proven that the system is insecure for a give n n if there is more than one
integer m such that 2 · m ≤ n ≤ 2 · ( m + 1).
(a) For what value(s) of n , if any, can you prove or disprove that there is more than one
integer m such that 2 · m ≤ n ≤ 2 · ( m + 1)?
(b) Given your answer to (a), does this prove that the cryptos ystem is either secure or
insecure? Explain.
Problem J: A certain algorithm takes a positive integer, n , as input. The first thing the algorithm
does is set n = n mod 5. It then uses the value of n to do further computations. One friend
claims that you can fully test the algorithm using just the in puts 1, 2, 3, 4, and 5. Another
friend claims that the inputs 29, 17, 38, 55, and 6 will work ju st as well.  A third friend
responds with “then why not just use 50, 55, 60, 65, and 70? Tho se should work just as
well as your stupid lists.” A fourth friend claims that you ne ed many more test cases to be
certain. A fifth friend says that you can never be certain no ma tter how many test cases you
use. Which friend or friends is correct? Explain.
Problem K: Write an algorithm to swap two integers without using any ext ra storage. (That is,
you can’t use any temporary variables.)
Problem L: You are at a party with some friends and one of them claims “I ju st did a quick count,
and it turns out that at this party, there are an odd number of p eople who have shaken hands
with an odd number of other people.” Can you prove or disprove that this friend is correct?
Problem M: Recall the Fibonacci sequence , defined by the recurrence relation

0 if n =0 
f = 1 if n =1 n

f + f if n > 1. n − 1 n − 2

Some Problems 5
So f = 1, f = 2, f = 3, f = 5, f = 8, etc. 2 3 4 5 6
(a) One friend claims that the following algorithm is an eleg ant and efficient way to compute
f . n
int Fibonacci( int n) {
if (n  <= 1) {
return (n);
} else {
return (Fibonacci(n-1)+Fibonacci(n-2));
}
}
Is he right? Explain.
(b) Another friend claims that he has an algorithm that compu tes f that takes constant n
time–that is, no matter how large n is, it always takes the same amount of time to
computer f . Is it possible that he has such an algorithm? Explain. n
Problem N: You need to settle an argument between your boss (who can fire y ou) and your
professor (who can fail you). They are trying to decide who to invite to the Young Accountants
Volleyball League. They want to invite freshmen who are stud ying accounting and are over
6 feet tall. They have a list of everyone they could potential ly invite.
1. Your boss says they should make a list of all freshmen, a lis t of all accounting majors,
and a list of everyone over 6 feet tall. They should then combi ne the lists (removing
duplicates) and invite those on the combined list.
2. Your professor says they should make a list of everyone who is not a freshman, a list
of anyone who does not do accounting, and a list of everyone wh o is 6 feet tall or less.
They should make a fourth list that contains everyone who is o n all three of the prior
lists. Finally, they should remove from the original list ev eryone on this fourth list, and
invite the remaining students.
Who is correct? Explain.

6 Chapter 1

Chapter 2: Logic
2.1  Propositional Logic
2.1.1  Basic Definitions
Definition 2.1. A boolean proposition (or simply proposition ) is a statement which is
either true or false (sometimes abbreviated as T or F ). We call this the truth value of the
proposition.
Whether the statement is obviously true or false does not enter into the definition. One only need s
to know that its certainty can be established.
Example 2.2. The following are propositions and their truth values, if kn own:
2 (a) 7 = 49. ( true )
(b) 5 > 6. ( false )
(c) If p is a prime then p is odd. ( false )
(d) There exists infinitely many primes which are the sum of a s quare and 1. (unknown)
(e) Dr. Cusack is the Pope. ( false )
(f) Every even integer greater than 6 is the sum of two distinc t primes. (unknown)
Note: Next you will see the first of many Exercises . These give you an opportunity to solve
a problem from start to finish and then check your answer with t he solution provided. It is
important that you try each of these on your own before lookin g at the solution. You will not
get as much out of the book if you skip these or jump straight to the answer without trying them
yourself.
⋆ Exercise 2.3. Give the truth value of each of the following statements.
(a) 0 = 1.
(b) 17 is an integer.
(c) In 1999, it was possible to buy a red Swingline stapler.
7

8 Chapter 2
Note: Did you notice the ⋆ in the heading of the previous example? This indicates that a
solution is provided. If you are reading the PDF file, clicking on the ⋆ will take you to the
solution. Clicking on the number in the solution will take you back.
If you are reading the PDF, go to the back of the book to find the so lutions.
Example 2.4. The following are not propositions, since it is impossible t o assign a true or
false value to them.
(a) Whenever I shampoo my camel.
(b) Sit on a potato pan, Otis!
(c) What I am is what I am, are you what you are or what?
(d) x = x + 1.
(e) This sentence is false.
⋆ Exercise 2.5. For each of the following statements, state whether it is tru e, false, or not a
proposition.
i can has cheezburger? (a)
(b) “Psych” was one of the best shows on TV when it was on the air.
I know, right? (c)
(d) This is a proposition.
This is not a proposition. (e)
2.1.2  Compound Propositions
Definition 2.6. A logical operator is used to combine one or more propositions to form a
new one. A proposition formed in this way is called a compound proposition . We call the
propositions used to form a compound proposition variables for reasons that should become
evident shortly.
Next we will discuss the most common logical operators. Beca use one of the applications of
logic we will be concerned about is algorithms and programmi ng, when we introduce notation we
will also mention equivalent notations used in several comm on programming languages. For each
of the following definitions, assume p and q are propositions.

Propositional Logic 9
Definition 2.7. The negation (or NOT ) of p , denoted by ¬ p is the proposition “ it is not
the case that p ”. ¬ p is true when p is false, and vice-versa. Other notations include p , ∼ p ,
and ! p . Many programming languages use the last one.
Example 2.8. If p is “ x < 0”, then ¬ p is “It is not the case that x < 0,” or “ x ≥ 0.”
Note: The next example is the first of many Fill in the details exercises in which you need
to supply some of the details. After you have filled in the blan ks, compare your answers with
the solutions. The answers are often given with semicolons (; ) separating the blanks.
⋆ Fill in the details 2.9. Let p be the proposition “I am learning discrete mathematics.”
Then ¬ p is the proposition .
. The truth value of ¬ p is
Definition 2.10. The conjunction (or AND ) of p and q , denoted by p ∧ q , is the proposition
“ p and q ”. The conjunction of p and q is true when p and q are both true and false otherwise.
Many programming languages use && for conjunction.
Example 2.11. Let p be the proposition “ x > 0” and q be the proposition “ x < 10.” Then
p ∧ q is the proposition “ x > 0 and x < 10,” or “0 < x < 10.”
Example 2.12. Let p be the proposition “ x < 0” and q be the proposition “ x > 10.” Then
p ∧ q is the proposition “ x < 0 and x > 10.”
Notice that p ∧ q is always false since if x < 0, clearly x 6 > 10.  But don’t confuse the
proposition with its truth value . When you see the statement ‘ p ∧ q is “ x < 0 and x > 10”’
and ‘ p ∧ q is false,’ these are saying two different things. The first one i s telling us what the
proposition is. The second one is telling us its truth value. ‘ p ∧ q is false’ is just a shorthand
for saying ‘ p ∧ q has truth value false.’
⋆ Fill in the details 2.13. If p is the proposition “I like cake,” and q is the proposition “I
like ice cream,” then p ∧ q is the proposition .
Definition 2.14. The disjunction (or OR ) of p and q , denoted by p ∨ q , is the proposition “ p
or q ”. The disjunction of p and q is false when both p and q are false and true otherwise. Put
another way, if p is true, q is true, or both are true, the disjunction is true. Many progr amming
languages use || for disjunction.

10 Chapter 2
Example 2.15. Let p be the proposition “ x < 5” and q be the proposition “ x > 15.” Then p ∨ q
is the proposition “ x < 5 or x > 15.” In a Java/C/C++ program, it would be “ x<5 || x>15 .”
⋆ Fill in the details 2.16. Let p be the proposition “ x  > 0” and q be the proposition
“ x < 10.” Then p ∨ q is the proposition .
Notice that p ∨ q is always since it is if x > 0, and if x 6 > 0,
then clearly , so it is then as well.
⋆ Exercise 2.17. Let p be “Jill is tall,” and q be “Jill is smart.” Express each of the following
propositions in English.
(a) ¬ p is
(b) p ∨ q is
(c) p ∧ q is
(d) p ∧¬ q is
(e) ¬ ( p ∧ q ) is
Definition 2.18. The exclusive or (or XOR ) of p and q , denoted by p ⊕ q , is the proposition
“ p is true or q is true, but not both ”. The exclusive or of p and q is true when exactly
one of p or q is true. Put another way, the exclusive or of p and q is true iff p and q have
different truth values.
Example 2.19. Let p be the proposition “ x > 10” and q be the proposition “ x < 20.” Then
p ⊕ q is the proposition “ x > 10 or x < 20, but not both.”
Note: Notice that ∨ is an inclusive or , meaning that it is true if both are true, whereas ⊕
is an exclusive or , meaning it is false if both are true. The difference between ∨ and ⊕ is
complicated by the fact that in English, the word “or” to can m ean either of these depending on
context. For instance, if your mother tells you “you can have cake or ice cream” she is likely
using the exclusive or, whereas a prerequisite of “Math 110 o r demonstrated competency with
algebra” clearly has the inclusive or in mind.

Propositional Logic 11
⋆ Exercise 2.20. For each of the following, is the or inclusive or exclusive? Answer OR or
XOR for each.
The special includes your choice of a salad or fries. (a)
(b) The list is empty or the first element is zero.
(c) The first list is empty or the second list is empty.
(d) You need to take probability or statistics before taking thi s class.
(e) You can get credit for either Math 111 or Math 222.
⋆ Exercise 2.21. Let p be “list 1 is empty” and q be “list 2 is empty.” Explain the difference
in meaning between p ∨ q and p ⊕ q .
Answer
Note: The Question examples are similar to the Evaluate ones except that they ask a specific
question. Write down your answer in the space provided and th en compare your answer with
the one in the solutions.
⋆ Question 2.22. Let p be the proposition “ x < 5” and q be the proposition “ x > 15.”
(a) Do the statements p ∨ q and p ⊕ q mean the same thing? Explain.
Answer
(b) Practically speaking, are p ∨ q and p ⊕ q the same? Explain.
Answer

12 Chapter 2
XOR is not used as often as AND and OR in logical expressions in programs. Some languages
have an XOR operator and some do not. The issue gets blurry bec ause some languages, like Java,
have an explicit Boolean type, while others, like C and C++, d o not. All of these languages have
a bitwise XOR operator, but this is not the same thing as a logical XOR operator. We will return
to this topic later. In the next section we will see how to impl ement ⊕ using ∨ , ∧ , and ¬ .
Definition 2.23. The conditional statement (or implies or implication ) involving p and
q , denoted by p → q , is the proposition “ if p , then q ”. It is false when p is true and q is
false, and true otherwise. In the statement p → q , we call p the premise (or hypothesis or
antecedent ) and q the conclusion (or consequence ).
Example 2.24. Let p be “you earn at least 94%,” and q be “you will receive an A.” Then
p → q is the proposition “If you earn at least 94%, then you will rec eive an A.”
It is important to realize that p → q and q → p are not always equivalent.
Example 2.25. Let p be “you earn at least 94%,” and q be “you will receive an A.” Then
p → q is the proposition “If you earn at least 94%, then you will rec eive an A,” and q → p
is the proposition “If you receive an A, then you earned at lea st 94%.” Although they may
sound equivalent, they are not. Consider the possibility th at it is true that receiving at least
93% results in an A. Then p → q is true, but q → p is false.
⋆ Question 2.26. Assume that the proposition “If you earn at least 94% in this c lass, then
you will receive an A” is true.
(a) What grade will you get if you earn 94%? Explain.
Answer
(b) If you receive an A, did you earn at least 94%? Explain.
Answer
(c) If you don’t earn 94%, does that mean you didn’t get an A? Ex plain.
Answer
Example 2.27. Translating between an English sentence and a mathematical expression can
sometimes be tricky with conditional statements. Again, le t p be “you earn at least 94%,” and
q be “you will receive an A.” Then the sentence “You will receiv e an A whenever you earn at
least 94%” is p → q , and not q → p since it is expressing the same idea as the sentence “If you

Propositional Logic 13
earn at least 94%, you will receive an A.”
Note: The conditional statement is by far the one that is the most difficult to get a han dle
on for at least two reasons. First, the conditional statemen t p → q is not saying anything about
p or q by themselves. It is only saying that if p is true, then q has to also be true. It doesn’t say
anything about the case that p is not true. This brings us to the second reason. Should F → T
be true or false? Although it seems counterintuitive to some , it should be true. Again, p → q
is telling us about the value of q when p is true (i.e., if p is true, the q must be true). What
does it tell us if p is false? Nothing. As strange as it might seem, when p is false, the whole
statement is true regardless of the truth value of q .
If you are still confused, you can simply fall back on the forma l definition: p → q is false
when p is true and q is false, and is true otherwise. In other words, if interpreting
p → q as the English sentence “ p implies q ” is more harmful than helpful in understanding the
a concept, don’t worry about why it doesn’t make sense and just remember the definition.
a In mathematics, terms are usually chosen so they make sense i mmediately. Sometimes this is not possible
(if the concept is very complicated or it doesn’t relate to an ything familiar). Sometimes a term is poorly defined
but the definition sticks because of prior use.  Sometimes it m akes sense to some people and not to others,
probably based on a person’s background. I think this last po ssibility may be the reason in this case.
We will learn more about the conditional statements and stat ements related to it in the chapter
on proofs where it is particularly relevant.
Definition 2.28. The biconditional statement involving p and q , denoted by p ↔ q , is the
proposition “ p if and only if q ” (or abbreviated as “ p iff q ”). It is true when p and q have
the same truth value, and false otherwise.
Example 2.29. Let p be “you earn at least 94%,” and q be “you receive an A.” Then p ↔ q
is the proposition “You earn at least 94% if and only if you rec eive an A.”
⋆ Question 2.30. Assume that the proposition “You will receive an A if and only if you earn
at least 94%” is true.
(a) What grade will you get if you earn 94%?
Answer
(b) If you receive an A, did you earn at least 94%?
Answer
(c) If you don’t earn at least 94%, does that mean you didn’t ge t an A?
Answer
Now let’s bring all of these operations together with a few mo re examples.

14 Chapter 2
Example 2.31. Let a be the proposition “I will eat my socks,” b be “It is snowing,” and c be
“I will go jogging.” Here are some compound propositions inv olving a , b , and c , written using
these variables and operators and in English.
With Variables/Operators In English
( b ∨¬ b ) → c Whether or not it is snowing, I will go jogging.
b →¬ c If it is snowing, I will not go jogging.
b → ( a ∧¬ c ) If it is snowing, I will eat my socks, but I will not go jogging.
a ↔ c When I eat my socks I go jogging, and when I go jogging I
eat my socks.
or I eat my socks if and only if I go jogging.
⋆ Fill in the details 2.32. Let p be the proposition “ Iron Man is on TV,” q be “I will
watch Iron Man ,” and r be “I own Iron Man on DVD.” Fill in the missing information in the
following table.
With Variables/Operators In English
p → q
If I don’t own Iron Man on DVD and it is on TV, I will
watch it.
p ∧ r ∧¬ q
I will watch Iron Man every time it is on TV, and that is
the only time I watch it.
I will watch Iron Man if I own the DVD.
2.1.3  Truth Tables
Sometimes we will find it useful to think of compound proposit ions in terms of truth tables .
Definition 2.33. A truth table is a table that shows the truth value of a compound propositio n
for all possible combinations of truth assignments to the va riables in the proposition. If there
n are n variables, the truth table will have 2 rows.
The truth table for ¬ is given in Table 2.1 and the truth tables for all
p ¬ p 2.2 . In the of the other operators we just defined are given in Table
T F latter table, the first two columns are the possible values of the two
F T variables, and the last 5 columns are the values for each of th e two-
variable compound propositions we just defined for the given inputs.
Table 2.1:
Truth table for ¬

Propositional Logic 15
p q ( p ∧ q ) ( p ∨ q ) p ⊕ q ( p → q ) ( p ↔ q )
T    T T T F T T
T    F F T T F F
F    T F T T T F
F    F F F F T T
Table 2.2: Truth tables for the two-variable operators
Example 2.34. Construct the truth table of the proposition a ∨ ( ¬ b ∧ c ).
3 Solution: Since there are three variables, the truth table will have 2 = 8 rows.
Here is the truth table, with several helpful intermediate c olumns.
a b c ¬ b ¬ b ∧ c a ∨ ( ¬ b ∧ c )
T    T    T F F T
T    T    F F F T
T    F    T T T T
T    F    F T F T
F    T    T F F F
F    T    F F F F
F    F    T T T T
F    F    F T F F
Note: Notice that there are several columns in the truth table besi des the columns for the
variables and the column for the proposition we are interest ed in. These are “helper” or “in-
termediate” columns (those are not official definitions). Thei r purpose is simply to help us
compute the final column more easily and without (hopefully) making any mistakes.
⋆ Exercise 2.35. Construct the truth table for ( p → q ) ∧ q .
p  q p → q ( p → q ) ∧ q
T  T
T  F
F  T
F  F
Note: As long as all possible values of the variables are included, the order of the rows of a
truth table does not matter. However, by convention one of tw o orderings is usually used. Since
there is an interesting connection to the binary representa tion of numbers, let’s take a closer
look at this connection in the next example.
Example 2.36 (Ordering the rows of a Truth Table) . Notice that the values of the variables
can be used to construct an index for each row. We can do this by thinking of each T as a 1
and each F as a 0, and treating the columns as a binary number. T he rows will then be listed

16 Chapter 2
either in order or (more commonly) in reverse order. For inst ance, if there are three variables,
we can think of it as shown in the following table.
a b c index
T    T    T 1  1  1 7
T    T    F 1  1  0 6
T    F    T 1  0  1 5
T    F    F 1  0  0 4
F    T    T 0  1  1 3
F    T    F 0  1  0 2
F    F    T 0  0  1 1
F    F    F 0  0  0 0
This is the ordering you should follow so that you can easily ch eck your answers with those in
the solutions. It also makes grading your homework easier.
There is also a way of thinking about this recursively. Given an ordering for a table with
n variables, we can compute an ordering for a table with n + 1 variables as follows. Make two
copies of the columns corresponding to the n variables, appending a T to the beginning of the
first copy, and an F to the beginning of the second copy.
⋆ Exercise 2.37. Construct the truth table of the proposition ( a ∨¬ b ) ∧ c . You’re on your
own this time to supply all of the details.
2.1.4  Precedence Rules
Consider the compound proposition a ∨¬ b ∧ c . Should this be interpreted as a ∨ ( ¬ b ∧ c ), ( a ∨¬ b ) ∧ c ,
or even possibly a ∨¬ ( b ∧ c )? Does it even matter? You already know that 3 + (4 ∗ 5) 6 = (3 + 4) ∗ 5,
so it should not surprise you that where you put the parenthes es in logical expressions matters,
2.34 gives the truth table for one of these and you just computed th e truth too. In fact, Example
2.37 . If you compare them, you will see that they are not the table for another one in Exercise
same. The third interpretation is also different from both of t hese.

Propositional Logic 17
To correctly interpret compound propositions, the operato rs have an order of precedence . The
order is ¬ , ∧ , ⊕ , ∨ , → , and ↔ . Also, ¬ has right-to-left associativity, all other operators list ed
have left-to-right associativity.  Based on these rules, th e correct way to interpret a ∨ ¬ b ∧ c is
a ∨ (( ¬ b ) ∧ c ).
It is important to know the precedence rules for the logical o perators (or at least be able to
look it up) so you can properly interpret complex logical exp ressions. However, I generally prefer
to always use enough parentheses to make it immediately clea r, especially when I am writing code.
It isn’t difficult to remember that ¬ is first (that is, it always applies to what is immediately aft er
it) so sometimes I don’t use parentheses for it.
Example 2.38. According to the precedence rules, ¬ a → a ∨ b should be interpreted as
( ¬ a ) → ( a ∨ b ).
Example 2.39. According to the precedence rules, a ∧ ¬ b → c should be interpreted as
( a ∧ ( ¬ b )) → c .
⋆ Exercise 2.40. According to the precedence rules, how should a ∧ b ∨ c be interpreted?
Answer
⋆ Question 2.41. Are ( a ∧ b ) ∨ c and a ∧ ( b ∨ c ) equivalent? Prove your answer.
Answer
Note: The next example is an Evaluate exercise. These exercises give a problem and then
provide one or more solutions to the problem based on previou s student solutions. Your job is to
evaluate each solution by finding any mistakes. Mistakes inc lude not only incorrect algebra and
logic, but also unclear presentation, skipped steps, incor rect assumptions, over-simplification,
etc. When you come across these examples you should write dow n every error you can find.
Once you are pretty sure you know all of the problems (if there are any), compare your evalu-
ation to the one given in the solutions. Note that sometimes t he given solutions are correct!
⋆ Evaluate 2.42. According to the associativity rules, how should a → b → c be interpreted?
Solution:   It   should   be   interpreted   as   (a → b) → c.   However,   a → (b → c)
is   equivalent,   so   it   really  doesn’t   matter.
Evaluation

18 Chapter 2
2.2  Propositional Equivalence
We have already informally discussed two propositions bein g equivalent . In this section, we will
formally develop the notion of what it means for two proposit ions to be equivalent (or, more
formally, logically equivalent ). We will also provide you with a list of the most important lo gical
equivalences, along with some examples of some that aren’t n ecessarily as important, but make
interesting examples. But first, we need some new terminolog y.
Definition 2.43. A proposition that is always true is called a tautology . One that is always
false is a contradiction . Finally, one that is neither of these is called a contingency .
Example 2.44. Assume that x is a real number.
(a) The proposition “ x < 0” is a contingency since its truth depends on the value of x .
2 (b) The proposition “ x < 0” is a contradiction since it is false no matter what x is.
2 (c) The proposition “ x ≥ 0” is a tautology since it is true no matter what x is.
⋆ Fill in the details 2.45. State whether each of the following propositions is a tautol ogy,
contradiction, or contingency. Give a brief justification.
(a) p ∨¬ p is a since either p or ¬ p has to be true.
since . (b) p ∧¬ p is a
(c) p ∨ q is a since .
We will cover proofs more formally later, but for now we will i nformally introduce two proof
techniques involving propositional logic. To prove someth ing is a tautology, one must prove that
it is always true. One way to do this is to show that the proposi tion is true for every row of the
truth table. Another way is to argue (without using a truth ta ble) that the proposition is always
true, often using a proof by cases . This is exactly what it sounds like: consider every possibi lity,
and show that in all cases we get true.
Example 2.46. Prove that p ∨¬ p is a tautology.
Here are several proofs.
Proof 1:  Since every row in the following truth table for p ∨¬ p is T , it is a tautology.
p ¬ p p ∨¬ p
T F T
F T T
Proof 2:  By definition of disjunction, if p is true, then p ∨¬ p is true. On the other hand,

Propositional Equivalence 19
if p is false, ¬ p is true. In this case, p ∨¬ p is still true, again by definition of disjunction.
Since p ∨¬ p is true regardless of the value of p , it is a tautology.
⋆ Evaluate 2.47. Prove that [ p ∧ ( p → q )] → q is a tautology.
Proof   1:
p q p → q p ∧ (p → q) p ∧ (p → q) → q
T T T T T
T F F F T
F T T F T
F F T F T
Evaluation
Proof   2: One   way   to   show   that   p ∧ (p → q) → q   is   indeed   a   tautology   is   by
filling   out   a  truth  table,   as   follows:
p q p → q p ∧ (p → q) p ∧ (p → q) → q
T T T T T
T F F F T
F T T F T
F F T F T
Since    they    all    return    true    for    p ∧ (p → q) → q, this    proves    that    it    is    a
tautology.
Evaluation
Proof   3: One   way   to   prove   that   this   is   a   tautology   is   to   make   a   couple   of
assumptions.    First,   since   we   know   that   for   any   statement   x → y   where   y   is
true,   then   x   can   be   either   true   or   false. So   let   us   assume   that   q   i s   false
for   this   case. From   the   left   side   of   the   statement,   if   p   is   true,   we   w ould
have   true   and   (true   implies   false),   which   is   false,   thus   we   woul d   have   false
implies   false,   which   is   true,   and   if   p   is   false,   then   we   would   hav e   false   and
(false  implies  true),  which  comes  out  false.   So  in  both  cases  whe re  q  is  false,
the   statement   equals   out   to   false   implies   false,   which   is   true,   t hus   all   four
cases   are  true,  thereby   proving   that  p ∧ (p → q) → q  is   a  tautology.
Evaluation

20 Chapter 2
Proof   4: Since  an  implication  can  only  be  false  when  the  premise  is  tru e  and
the  conclusion  is  false,  we  only  need  to  prove  that  this  can’t  happen.   So let’s
assume  that  p ∧ (p → q)  is  true  but  that  q  is  false.   Since  p ∧ (p → q)  is  true,  p
is  true  and  p → q  is   true  (by  definition   of  conjunction).   But  if   p  is   true  and
q  is   false,  p → q  is   false.   This   is   a  contradiction,   so  it   must  be  the   case   that
our  assumption  that  p ∧ (p → q)  is  true  but  that  q  is  false  is  incorrect.   Since
that   was   the   only   possible   way   for   p ∧ (p → q) → q   to   be   false,   it   cannot   be
false.   Therefore  it   is   a  tautology.
Evaluation
Proof   5: Because   ‘merica.
Evaluation
Now we are ready to move on to the main topic of this section.
Definition 2.48. Let p and q be propositions. Then p and q are said to be logically equiv-
alent if p ↔ q is a tautology. An alternative (but equivalent) definition i s that p and q are
equivalent if they have the same truth table. That is, if they h ave the same truth value for all
assignments of truth values to the variables.
When p and q are equivalent, we write p = q . An alternative notation is p ≡ q .
Note: p = q is not a compound proposition. Rather it is a statement about the re lationship
between two propositions.
There are many logical equivalences (or identities / rules / laws ) that come in handy when working
with compound propositions.  Many of them (e.g.  commutative , associative, distributive) will
resemble the arithmetic laws you learned in grade school. Ot hers are very different. The most
2.3 . common ones are given in Table
We will provide proofs of some of these so you can get the hang o f how to prove propositions
are equivalent. One method is to demonstrate that the propos itions have the same truth tables.
That is, they have the same value on every row of the truth tabl e. But just drawing a truth table
isn’t enough. A statement like “since p and q have the same truth table, p = q ” is necessary to
make a connection between the truth table and the equivalenc e of the propositions. Let’s see a few
examples.

Propositional Equivalence 21
N ame Equivalence
commutativity p ∨ q = q ∨ p
p ∧ q = q ∧ p
associativity p ∨ ( q ∨ r ) = ( p ∨ q ) ∨ r
p ∧ ( q ∧ r ) = ( p ∧ q ) ∧ r
distributive p ∧ ( q ∨ r ) = ( p ∧ q ) ∨ ( p ∧ r )
p ∨ ( q ∧ r ) = ( p ∨ q ) ∧ ( p ∨ r )
identity p ∨ F = p
p ∧ T = p
negation p ∨¬ p = T
p ∧¬ p = F
domination p ∨ T = T
p ∧ F = F
idempotent p ∨ p = p
p ∧ p = p
double negation ¬ ( ¬ p ) = p
′ DeM organ s ¬ ( p ∨ q ) = ¬ p ∧¬ q
¬ ( p ∧ q ) = ¬ p ∨¬ q
absorption p ∨ ( p ∧ q ) = p
p ∧ ( p ∨ q ) = p
Table 2.3: Common Logical Equivalences
Example 2.49. Prove the double negation law: ¬ ( ¬ p ) = p .
Proof: The following is the truth table for p and ¬ ( ¬ p ).
p ¬ p ¬ ( ¬ p )
T F T
F T F
Since the entries for both p and ¬ ( ¬ p ) are the same for every row, ¬ ( ¬ p ) = p . 
The two versions of De Morgan’s Law are among the most importa nt propositional equivalences.
It is easy to make a mistake when trying to simplify expressio ns conditional statements, and a solid
understanding of De Morgan’s Laws goes a long way. Let’s take a look at them.
Example 2.50. Prove the first version of DeMorgan’s Law: ¬ ( p ∨ q ) = ¬ p ∧¬ q
Proof: We can prove this by showing that both expression have the sam e truth
table. Below is the truth table for ¬ ( p ∨ q ) and ¬ p ∧¬ q (the gray columns).
p q p ∨ q ¬ ( p ∨ q ) ¬ p ¬ q ¬ p ∧¬ q
T    T T F F F F
T    F T F F T F
F    T T F T F F
F    F F T T T T
Since they are the same for every row of the table, ¬ ( p ∨ q ) = ¬ p ∧¬ q . 

22 Chapter 2
⋆ Exercise 2.51. Prove the second version of De Morgan’s Law: ¬ ( p ∧ q ) = ¬ p ∨¬ q .
Proof
p   q p ∧ q ¬ ( p ∧ q ) ¬ p ¬ q ¬ p ∨¬ q
T  T
T  F
F  T
F  F
Truth tables aren’t the only way to prove that two propositio ns are equivalent. You can also
use other equivalences. Let’s see an example.
Example 2.52. Prove the idempotent law p ∨ p = p by using the other equivalences.
Proof: It is easier to prove backwards ( p = p ∨ p ). We have
p = p ∨ F (by identity)
= p ∨ ( p ∧¬ p ) (by negation)
=  ( p ∨ p ) ∧ ( p ∨¬ p )  (by distribution)
=  ( p ∨ p ) ∧ T (by negation)
= p ∨ p (by identity)
Thus, p ∨ p = p . 
⋆ Fill in the details 2.53. Prove the idempotent law p ∧ p = p by using the other equivalences.
Proof: Notice that
p = (by identity)
(by negation) =
= (by distributive)
(by negation) =
) = p ∧ p (by
.  Thus,
Although it is helpful to specifically state which rules are b eing used at every step, it isn’t
always required.

Propositional Equivalence 23
Example 2.54. Prove that ( p ∧ q ) ∨ ( p ∧¬ q ) = p .
Proof: It is not too difficult to see that
( p ∧ q ) ∨ ( p ∧¬ q ) = p ∧ ( q ∨¬ q ) = p ∧ T = p .

⋆ Exercise 2.55. Use the other equivalences (not a truth table) to prove the Ab sorption laws.
(a) Prove that p ∨ ( p ∧ q ) = p .
Proof:
(b) Prove that p ∧ ( p ∨ q ) = p .
Proof:
One use of propositional equivalences is to simplify logica l expressions.
Example 2.56. Simplify ¬ ( p ∨¬ q ).
Solution: Using DeMorgan’s Law and double negation, we can see that
¬ ( p ∨¬ q ) = ¬ p ∧¬ ( ¬ q ) = ¬ p ∧ q .
2.4 contains some important identities involving → , ↔ , and ⊕ . Since these operators are Table
not always present in a programming language, identities th at express them in terms of ∨ , ∧ , and
¬ are particularly important.

24 Chapter 2
p ⊕ q = ( p ∨ q ) ∧¬ ( p ∧ q ) p ↔ q = ( p → q ) ∧ ( q → p )
p ⊕ q = ( p ∧¬ q ) ∨ ( ¬ p ∧ q ) p ↔ q = ¬ p ↔¬ q
¬ ( p ⊕ q ) = p ↔ q p ↔ q = ( p ∧ q ) ∨ ( ¬ p ∧¬ q )
p → q = ¬ q →¬ p ¬ ( p ↔ q ) = p ↔¬ q
p → q = ¬ p ∨ q ¬ ( p ↔ q ) = p ⊕ q
Table 2.4: Logical equivalences involving → , ↔ , and ⊕
⋆ Exercise 2.57. Let p be “ x > 0”, q be “ y > 0,” and r be “Exactly one of x or y is greater
than 0.”
(a) Express r in terms of p and q using ⊕ (and possibly ¬ ).
Answer
(b) Express r in terms of p and q without using ⊕ .
Answer
Here is the proof of one of the identities from Table 2.4 .
Example 2.58. Prove that p ⊕ q = ( p ∧¬ q ) ∨ ( ¬ p ∧ q ).
Solution: It is straightforward to see that ( p ∧¬ q ) ∨ ( ¬ p ∧ q ) is true if p is true
and q is false, or if p is false and q is true, and false otherwise. Put another way,
it is true iff p and q have different truth values. But this is the definition of p ⊕ q .
Thus, p ⊕ q = ( p ∧¬ q ) ∨ ( ¬ p ∧ q ).
The previous example demonstrates an important general pri nciple. When proving identities (or
equations of any sort), sometimes it works best to start from the right hand side. More generally, it
is often best to start from the more complicated expression. Try to keep this in mind in the future.

Propositional Equivalence 25
⋆ Evaluate 2.59. Show that p ↔ q and ( p ∧ q ) ∨ ( ¬ p ∧¬ q ) are logically equivalent.
Proof   1: p ↔ q  is  true  when  p  and  q  are  both  true,  and  so  is  (p ∧ q) ∨ ( ¬ p ∧¬ q).
Therefore  they   are  logically   equivalent.
Evaluation
Proof   2: They    are    both    true    when    p    and    q    are    both    true    or    both    false.
Therefore  they   are  logically   equivalent.
Evaluation
Proof   3: Each  of   these   is   true  precisely   when  p  and  q   are  both   true.
Evaluation
Proof   4: Each  of  these   is   true  when  p  and  q  have  the  same  truth  value  and
false  otherwise,   so  they   are  equivalent.
Evaluation
In the previous example, you should have noticed that just a s ubtle change in wording can be
the difference between a correct or incorrect proof. When writ ing proofs, remember to be very
precise in how you word things. You may know what you mean when you wrote something, but a
reader can only see what you actually wrote.

26 Chapter 2
2.3  Predicates and Quantifiers
Definition 2.60. A predicate or propositional function is a statement containing one or
more variables, whose truth or falsity depends on the value( s) assigned to the variable(s).
We have already seen predicates in previous examples. Let’s revisit one.
2 Example 2.61. In a previous example we saw that “ x < 0” was a contingency, “ x < 0” was
2 a contradiction, and “ x ≥ 0” was a tautology. Each of these is actually a predicate sinc e until
we assign a value to x , they are not propositions.
Sometimes it is useful to write propositional functions using functional notation.
Example 2.62. Let P ( x ) be “ x < 0”. Notice that until we assign some value to x , P ( x ) is
neither true nor false.
P (3) is the proposition “3 < 0,” which is false.
2 2 If we let Q ( x ) be “ x ≥ 0,” then Q (3) is “3 ≥ 0,” which is true.
Notice that both P ( x ) and “ x < 0” are propositional functions. In other words, we don’t hav e
to use functional notation to represent a propositional fun ction. Any statement that has a variable
in it is a propositional function, whether we label it or not.
⋆ Exercise 2.63. Which of the following are propositional functions?
2 (a) x + 2 x + 1 = 0
2 (b) 3 + 2 · 3 + 1 = 0
(c) John Cusack was in movie M .
(d) x is an even integer if and only if x = 2 k for some integer k .
Definition 2.64. The symbol ∀ is the universal quantifier , and it is read as “for all”, “for
each”, “for every”, etc. For instance, ∀ x means “for all x ”. When it precedes a statement, it
means that the statement is true for all values of x .
As the name suggests, the “all” refers to everything in the universe of discourse (or
domain of discourse , or simply domain ), which is simply the set of objects to which the
current discussion relates.
Hopefully you recall that N is the set of natural numbers (i.e. { 0, 1, 2, . . . } ), Z is the set of
+ integers, and Z is the set of positive integers (i.e. { 1, 2, 3, . . . } ). We will use these in some of the
following examples.

Predicates and Quantifiers 27
Example 2.65. Let P ( x )=“ x < 0”. Then P ( x ) is a propositional function, and ∀ xP ( x ) means
“all values of x are negative.” If the domain is Z , ∀ xP ( x ) is false. However, if the domain is
negative integers, ∀ xP ( x ) is true.
Example 2.66. Express each of the following English sentences using the un iversal quantifier.
Don’t worry about whether or not the statements are true. Ass ume the domain is real numbers.
(a) The square of every number is non-negative.
(b) All numbers are positive.
2 Solution: (a) ∀ x ( x ≥ 0) (b) ∀ x ( x > 0)
⋆ Exercise 2.67. Express each of the following using the universal quantifier . Assume the
domain is Z .
(a) Two times any number is less than three times that number.
Answer
n (b) n ! is always less than n .
Answer
2 2 Example 2.68. The expression ∀ x ( x ≥ 0) means “for all values of x , x is non-negative”.
But what constitutes all values? In other words, what is the domain? In this case the mo st
logical possibilities are the integers or real numbers sinc e it seems to be stating something
about numbers (rather than people, for example). In most sit uations the context should make
it clear what the domain is.
3 3 Example 2.69. The expression ∀ x ≥ 0, x ≥ 0 means “for all positive values of x , x ≥
0.” There are several other ways of expressing this idea, but this one is probably the most
convenient. One alternative would be to restrict the domain to positive numbers and write it
3 as ∀ x ( x ≥ 0). But sometimes you don’t want to or can’t restrict the doma in.
3 Another way to express it is ∀ x ( x ≥ 0 → x ≥ 0).
⋆ Exercise 2.70. Use the universal quantifier to express the fact that the squa re of any integer
is not zero as long as the integer is not zero.
Answer

28 Chapter 2
Definition 2.71. The symbol ∃ is the existential quantifier , and it is read as “there exists”,
“there is”, “for some”, etc.  For instance, ∃ x means “For some x ”.  When it precedes a
statement, it means that the statement is true for at least one value of x in the universe.
√
Example 2.72. Prove that ∃ x ( x = 2) is true when the domain is the integers.
√ √
Proof. Notice that when x = 4, x = 4 = 2, proving the statement.
⋆ Exercise 2.73. Express the sentence “Some integers are positive” using qua ntifiers. You
may assume the domain of the variable(s) is Z .
Answer
Sometimes you will see nested quantifiers . Let’s see a few examples.
Example 2.74. Use quantifiers to express the sentence “all positive number s have a square
root,” where the domain is real numbers.
√
Solution: We can express this as ∀ ( x > 0) ∃ y ( x = y ).
⋆ Evaluate 2.75. Express the sentence “Some integers are even” using quantifi ers. You may
assume the domain of the variable(s) is the integers.
Solution   1: ∃ x(x  is   even).
Evaluation
Solution   2: ∃ x(x / 2 ∈ Z ).
Evaluation
Solution   3: ∃ x ∃ y(x  =  2y).
Evaluation
Example 2.76. Translate ∀∀∃∃ into English.
Solution: It means “ for every upside-down A there exists a backwards E .” This is
a geeky math joke that might make sense if you paid attention i n calculus (assuming
you ever took calculus, of course).

Predicates and Quantifiers 29
⋆ Exercise 2.77. Express the following statement using quantifiers: “Every i nteger can be
expressed as the sum of two squares.” Assume the domain for al l three variables (did you
catch the hint?) is Z .
Answer
⋆ Exercise 2.78. Find a predicate P ( x , y ) such that ∀ x ∃ yP ( x , y ) and ∃ y ∀ xP ( x , y ) have dif-
ferent true values. Justify your answer. (Hint: Think simpl e. Will something like “ x = y ” or
“ x < y ” work if you choose the appropriate domain?)
Answer:
Example 2.79. Let P ( x )=“ x < 0”. Then ¬∀ xP ( x ) means “it is not the case that all values
of x are negative.” Put more simply, it means “some value of x is not negative”, which we can
write as ∃ x ¬ P ( x ).
What we saw in the last example actually holds for any proposi tional function.
Theorem 2.80 (DeMorgan’s Laws for quantifiers) . If P ( x ) is a propositional function, then
¬∀ xP ( x ) = ∃ x ¬ P ( x ), and
¬∃ xP ( x ) = ∀ x ¬ P ( x ).
Proof: We will prove the first statement. The proof of the second is ver y similar.
Notice that ¬∀ xP ( x ) is true if and only if ∀ xP ( x ) is false. ∀ xP ( x ) is false if and
only if there is at least one x for which P ( x ) is false. This is true if and only if
¬ P ( x ) is true for some x . But this is exactly the same thing as ∃ x ¬ P ( x ) , proving
the result. 

30 Chapter 2
Example 2.81. Negate the following expression, but simplify it so it does n ot contain the ¬
symbol.
∀ n ∃ m (2 m = n )
Solution:
¬∀ n ∃ m (2 m = n )  = ∃ n ¬∃ m (2 m = n )
= ∃ n ∀ m ¬ (2 m = n )
= ∃ n ∀ m (2 m 6 = n )
⋆ Exercise 2.82. Answer the following questions about the expression from Ex ample 2.81 ,
assuming the domain is Z .
(a) Write the expression in English. You can start with a dire ct translation, but then smooth
it out as much as possible.
Answer
(b) Write the negation of the expression in English. State it as simply as possible.
Answer
(c) What is the truth value of the expression? Prove it.
Answer

Normal Forms 31
2.4  Normal Forms
Earlier we saw identities that express logical operators in terms of ∨ , ∧ , and ¬ . It turns out that
even if there isn’t an identity that does it, there is a straig htforward technique to convert any logical
expression into one only using ∨ , ∧ , and ¬ . That is the topic of this section.
Specifically, we will introduce two standard forms that ever y boolean expression can be written
in: disjunctive normal form and conjunctive normal form . These form have connections to im-
portant areas of computer science including circuit design and minimization, artificial intelligence
algorithms, automated theorem proving, and the study of alg orithm complexity. We begin with a
few necessary definitions.
Definition 2.83. A literal is a boolean variable or its negation.
Example 2.84. Let p , q , and r be boolean variables. Then p , ¬ p , q , ¬ q , r , and ¬ r are all
literals.
On the other hand, p ∧ q , ¬ p → q , and p ∧ q ∧ r are not literals because they include boolean
operations of two or more variables. In other words, none of t hem are a variable or the negation
of a variable.
⋆ Exercise 2.85. Let p , q , and r be boolean variables. Which of the following are literals?
q ∨ r , ¬ p , q , p ∧ q ∧ r , ¬ p ∧ q , r .
Answer
Definition 2.86. A conjunctive clause is a conjunction ( AND ) of one or more literals.
Example 2.87. Let p , q , and r be boolean variables. Then p ∧ q ∧ r , ¬ p ∧ r , and r ∧¬ q ∧ p
are all conjunctive clauses.
¬ ( p ∧ q ) is not a conjunctive clause because it has a negation that is applied to the con-
junction and not to just a variable. Other examples that are not conjunctive clauses are p ∨ r ,
p ∨ q ∧ r , p ↔ r , and p ∧ q ∧ ( r ⊕ p ).
Example 2.88. Literals are conjunctive clauses since they are a conjuncti on of a single variable.
This might sound weird because if you only have a single varia ble, there is nothing to “conjoin”
it to. But it is just like if someone asked to to add up all of the money in your pocket–if you
only have a single dollar, you will say you have one dollar, ha ving “added up” the dollar.
Therefore, p , ¬ p , q , ¬ q , r , and ¬ r are all conjunctive clauses.

32 Chapter 2
⋆ Exercise 2.89. Let p , q , and r be boolean variables. Which of the following are conjunctiv e
clauses?
q ∨ r , ¬ p , q , p ∧ q ∧ r , ¬ p → q , ¬ p ∧ q , r , ¬ r ∧ p ∧ q , q ∨¬ r , p ∧¬ ( r ∧ q )
Answer
Definition 2.90. A logical expression is in disjunctive normal form ( DNF ) (or sum-of-
products expansion ) if it is expressed as a disjunction ( OR ) of conjunctive clauses.
Example 2.91. Let p , q , and r be boolean variables. Then the following are in disjunctive
normal form:
• q (It is the disjunction of a single conjunctive clause that co nsists of just a literal.)
• p ∧¬ q (It is the disjunction of a single conjunctive clause.)
• p ∨¬ q (It is the disjunction of two conjunctive clauses, each of wh ich is just a literal.)
• ( p ∧ q ∧ r ) ∨ ( ¬ p ∧ r )
• p ∨ ( q ∧¬ p ) ∨ ( r ∧¬ p )
• r ∧¬ q ∧ p
These are not in disjunctive normal form.
• p → q
• p ∧ ( q ∨ r )
• p ∨¬ ( r ∧ q )
• p ∨ ( q ∧¬ p ) ∧ ( r ∨¬ q )
• ( p ↔ q ) ∨ ( q ∧¬ r ) ∨¬ p
⋆ Exercise 2.92. Let p , q , and r be boolean variables. Which of the following are in disjunct ive
normal form?
¬ p , q ∨ r , ¬ q ∧ r , p ∧ q ∧ r , ( ¬ p → q ) ∨ ( q ∧ r ), ¬ ( p ∧¬ q ), ¬ r ∧ p ∧ q , ¬ ( p ∨ q ), p ∧¬ ( r ∧ q ),
( p ∧ ¬ r ) ∨ ( r ∧ q ) ∨ ( ¬ q ∧ p ), ( p ∨ ¬ r ) ∧ ( r ∨ q ) ∧ ( ¬ q ∨ p ), ( p ∧ ¬ r ) ∨ ( r ∨ q ) ∨ ( ¬ q ∧ p ),
( p ∧¬ r ) ∨ ( r ∧ q ) ∧ ( ¬ q ∧ p ), ( p ∧¬ r ) ∨ ( r ∧ q ) ∨ ( ¬ q ∧ p ∧ r )
Answer

Normal Forms 33
Make sure you have a clear understanding of when an expressio n is and is not a literal, a
conjunctive clause, or in disjunctive normal form.
Now you understand what disjunctive normal form is and can re cognize when an expression
is in this form. Next we describe how to convert any expressio n to an equivalent one that is in
disjunctive normal form. The procedure involves construct ing a truth table for the expression. The
process is pretty straightforward once you get the hang of it , but it can be a little tricky at first so
pay careful attention!
Procedure 2.93. This will convert a boolean expression to disjunctive normal form.
1. Create a truth table for the expression.
2. Identify the rows having output T .
3. For each such row, create a conjunctive clause that includ es all of the variables which are
true on that row and the negation of all of the variables that a re false.
4. Combine all of the conjunctive clauses by disjunctions.
Example 2.94. Express p ⊕ q in disjunctive normal form.
Solution: The truth table for p ⊕ q is given to the right. The second and third
rows of the table are true, so we use those to construct the dis junctive normal form.
p q p ⊕ q
The second row yields conjunctive clause p ∧¬ q , and
T    T F
the third row yields conjunctive clause ¬ p ∧ q . The
T    F T
disjunction of these is ( p ∧¬ q ) ∨ ( ¬ p ∧ q ).
F    T T
Thus, p ⊕ q = ( p ∧¬ q ) ∨ ( ¬ p ∧ q ).
F    F F
The previous example is essentially just another proof of th e identity that was proven in Ex-
ample 2.58 .
⋆ Exercise 2.95. Express p ↔ q in disjunctive normal form.
p  q p ↔ q
T  T
T  F
F  T
F  F

34 Chapter 2
Example 2.96. Express Z in disjunctive normal form.
p   q    r Z
T   T   T T
T   T   F T
T   F   T F
T   F   F F
F   T   T F
F   T   F T
F   F   T F
F   F   F T
Solution: Z = ( p ∧ q ∧ r ) ∨ ( p ∧ q ∧¬ r ) ∨ ( ¬ p ∧ q ∧¬ r ) ∨ ( ¬ p ∧¬ q ∧¬ r ).
The solution from the previous example can be simplified to Z = ( p ∧ q ) ∨ ( ¬ p ∧¬ r ). Although
this can be done by applying the logical equivalences we lear ned about earlier, there are more
sophisticated techniques that can be used to simplify expre ssions that are in disjunctive normal
form.  This is beyond our scope, but you may learn more about th is if you take a computer
organization class and discuss circuit minimization. The i mportant point I want to make here is
that computing the disjunctive normal form of an expression using the technique we describe will
not always produce the most simple form of the expression. In fact, most of the time it won’t be.
⋆ Exercise 2.97. Express Y in disjunctive normal form.
p   q    r Y
T   T   T F
T   T   F T
T   F   T F
T   F   F F
F   T   T T
F   T   F F
F   F   T T
F   F   F T
There is another important form that is very similar to disju nctive normal form.
Definition 2.98. A disjunctive clause is a disjunction ( OR ) of one or more literals. A logical
expression is in conjunctive normal form ( CNF ) (or product-of-sums expansion ) if it
is expressed as a conjunction ( AND ) of disjunctive clauses.
There are several methods for converting to conjunctive nor mal form. They generally involve
using double negation, distributive, and De Morgan’s laws e ither based on the truth table or based
on the disjunctive normal form. However, we won’t discuss th ese techniques here.

Reading Comprehension Questions 35
2.5  Reading Comprehension Questions
Note: It is recommended that you attempt to complete all of the questions before checking your
answers. As with the exercises throughout the book, it is als o recommended that if you get one
wrong, attempt to solve it again before reading the answer/s olution in detail. You will learn a
lot more that way!
Also, the solutions given are often just one possible answer (especially when answers involve
coming up with an example).  If your answer is different, you sho uld be able to determine
whether or not your answer is also correct. If you are not sure, please ask!
From Section 2.1
Question 2.1. What is a proposition? ⋆
⋆ Question 2.2. What are the six logical operators that were introduced in th is chapter? Draw a
truth table for each.
⋆ Question 2.3. Explain the difference between (inclusive) or and exclusive or .
⋆ Question 2.4. When is p → q true?
⋆ Question 2.5. Draw a truth table for ( p ∧ q ) ∨¬ p .
⋆ Question 2.6. Draw a truth table for ( p ∧ q ) ∨ r .
⋆ Question 2.7. Can p and ¬ p both be true? Explain.
⋆ Question 2.8. If p ∨ q is true and p is false, what can you say about q ?
⋆ Question 2.9. If p ∨ q is true and p is true, what can you say about q ?
⋆ Question 2.10. If p ∧ q is true, what can you say about p and/or q ?
⋆ Question 2.11. If p ↔ q is true and p is false, what can you say about q ?
⋆ Question 2.12. If p → q is true and p is true, what can you say about q ?
⋆ Question 2.13. If p → q is true and p is false, what can you say about q ?
From Section 2.2
Question 2.14. Can a proposition be a contingency and a tautology at the same time? ⋆
⋆ Question 2.15. Is it possible for both a proposition and its negation to be tr ue? Explain.
⋆ Question 2.16. Prove the domination laws. That is, prove that
(a) p ∨ T = T
(b) p ∧ F = F .
⋆ Question 2.17. Explain why ¬ p ∧¬ q and ¬ ( p ∧ q ) are not logically equivalent.

36 Chapter 2
⋆ Question 2.18. Why is “because that’s not what DeMorgan’s law says” or “beca use they look
different” not sufficient to prove that ¬ p ∧¬ q and ¬ ( p ∧ q ) are not logically equivalent.
⋆ Question 2.19. What is an easy way to prove that two propositions are not logi cally equivalent?
From Section 2.3
Question 2.20. What is a propositional function (or predicate)? Give an exa mple. ⋆
⋆ Question 2.21. Does ¬∀ xP ( x ) mean P ( x ) is never true? If so, convince me. If not, what does
it mean?
⋆ Question 2.22. Does ¬∃ xP ( x ) mean P ( x ) is never true? If so, convince me. If not, what does
it mean?
⋆ Question 2.23. Give two equivalent (but different) ways of expressing ∀ x ¬∃ yQ ( x , y ).
⋆ Question 2.24. Give three equivalent (but different) ways of expressing ¬∃ x ( x < 0 ∧ x > 0).
⋆ Question 2.25. Express the sentence “Everybody hurts sometimes” using pre dicates and quan-
tifiers. To get you started, let H ( x , y ) =“ x hurts at time y ”.
⋆ Question 2.26. Express the sentence “Nothing ever changes, nothing ever st ays the same” using
predicates and quantifiers. Hint: You will need to define one o r two predicates, depending on how
you interpret the sentence and how clever you are.
⋆ Question 2.27. Let P ( x , y ) =“ x ≤ y ” and assume the universe of discourse is the set of integers.
(a) Rephrase ∀ x ∃ yP ( x , y ) in English.
(b) Rephrase ∃ x ∀ yP ( x , y ) in English.
(c) Do the statements in parts (a) and (b) seem to be saying the same thing? Explain.
(d) What is the truth value of ∀ x ∃ yP ( x , y )?
(e) What is the truth value of ∃ x ∀ yP ( x , y )?
(f) Hopefully you answered that one of the statements is true and the other is false (If not, go
back to the previous two questions and try again!). Can you ch ange the universe of discourse
so that the two statements have the same truth values?
(g) If you said no to the previous question, go back and try har der before continuing. So, you can
make them have the same truth value by changing the universe o f discourse. Does that mean
with this universe of discourse the statement are saying the same thing? (This is a subtle but
important point, so if you are not totally confident in your an swer, ask about this one!)
From Section 2.4
⋆ Question 2.28. Let p , q and r be boolean variables. Which of the following are literals? ¬ p ,
¬ p ∧ r , q , ¬ r , p → r , r .
⋆ Question 2.29. Let p , q and r be Boolean variables. Which of the following are conjunctiv e
clauses? ¬ p , p ∧ r , q ∨¬ r , ¬ p ∧ r , q , ¬ r , p → r , ¬ ( p ∧ q ).
⋆ Question 2.30. Let p , q and r be Boolean variables. Which of the following are in disjunct ive
normal form? ¬ p , p ∧ r , q ∨¬ r , ¬ p ∧ r , p → r , ¬ ( p ∧ q ), ( p ∧ q ) ∨ ( q ∧¬ r ) ∨¬ p , ( p ∨ q ) ∧ ( q ∨¬ r ) ∧¬ p ,
( p ∧ r ) ∨¬ ( r ∧¬ q ) ∨ ( ¬ p ∧ q ), ( p ∧¬ r ∧ q ) ∨ ( ¬ p ∧ r ∧¬ q ) ∨ ( p ∧ r ∧ q ) ∨ ( ¬ p ∧¬ r ∧¬ q ) .

Problems 37
2.6  Problems
Problem 2.1. Draw a truth table to represent the following.
(a) ¬ p ∨ q
(b) ( p → q ) ∨¬ p
(c) ( p ∧¬ q ) ∨ r
(d) (( p ∨ q ) ∧¬ ( p ∨ q )) ∨ r
(e) ( p ∨¬ r ) ∧ q
(f) ( p ⊕ q ) ∧ ( q ∨ r )
(g) p ↔ ( p ∧ q )
Problem 2.2. Prove the distributive laws.
(a) p ∧ ( q ∨ r ) = ( p ∧ q ) ∨ ( p ∧ r )
(b) p ∨ ( q ∧ r ) = ( p ∨ q ) ∧ ( p ∨ r )
Problem 2.3. Prove the identity laws.
(a) p ∨ F = p
(b) p ∧ T = p
Problem 2.4. Prove the negation laws.
(a) p ∨¬ p = T
(b) p ∧¬ p = F
Problem 2.5. Prove that p ⊕ q = ( p ∨ q ) ∧¬ ( p ∧ q ).
Problem 2.6. Prove the following laws involving implications.
(a) p → q = ¬ p ∨ q
(b) p → q = ¬ q →¬ p
Problem 2.7. Prove the following laws involving biconditionals.
(a) p ↔ q = ( p → q ) ∧ ( q → p )
(b) p ↔ q = ¬ p ↔¬ q
(c) ¬ ( p ↔ q ) = p ↔¬ q
Problem 2.8. Give 2 different proofs that [( p ∨ q ) ∧¬ p ] → q is a tautology.
Problem 2.9. Prove ¬ ( p ↔ q ) = p ⊕ q without using truth tables.
Problem 2.10. Express p ∨ q ∨ r using only ∧ and ¬ .

38 Chapter 2
Problem 2.11. The NAND of p and q , denoted by p | q , is the proposition “not both p and q ”. The
NAND of p and q is false when p and q are both true and true otherwise.
(a) Draw a truth table for N AN D
(b) Express p | q using ∨ , ∧ , and/or ¬ (you may not need all of them).
(c) Express p ∧ q using only | . (That means you cannot use ¬ , ∨ , ∧ , or any other boolean operator
except for | .  Thus, your answer should only involve p , q , | and parentheses.)  Your answer
should be as simple as possible. Give a truth table that shows they are the same.
(d) Express ¬ p ∨ q using only | . Your answer should be as simple as possible. Give a truth tab le
that shows they are the same.
Problem 2.12. The NOR of p and q , denoted by p ↓ q , is the proposition “neither p nor q ”. The
NOR of p and q is true when p and q are both false and false otherwise.
(a) Draw a truth table for ↓
(b) Express p ↓ q using ∨ , ∧ , and/or ¬ (you may not need all of them).
(c) Express p ∧ q using only ↓ . (That means you cannot use ¬ , ∨ , ∧ , or any other boolean operator
except for ↓ . Thus, your answer should only involve p , q , ↓ and parentheses.) Your answer
should be as simple as possible. Give a truth table that shows they are the same.
(d) Express ¬ p ∨ q using only ↓ . Your answer should be as simple as possible. Give a truth tab le
that shows they are the same.
Problem 2.13. A set of logical operators is functionally complete if any possible operator can be
implemented using only operators from that set. It turns out that {¬ , ∧} is functionally complete.
So is {¬ , ∨} .  To show that a set if functionally complete, all one needs to do is show how to
implement all of the operators from another functionally co mplete set. Given this,
(a) Show that {|} is functionally complete. (Hint: Since {¬ , ∧} is functionally complete, one way
is to show how to implement both ∧ and ¬ using just | .)
(b) Show that {↓} is functionally complete.
Problem 2.14. Express the following phrase using quantifiers. “There is so me constant c such
that f ( x ) is no greater than c · g ( x ) for all x ≥ x for some constant x .” Your solution should 0 0
contain no English words.
Problem 2.15. Write each of the following expressions so that negations ar e only applied to
propositional functions (and not quantifiers or connective s).
(a) ¬∀ x ∃ y ¬ P ( x , y )
(b) ¬ ( ∀ x ∃ yP ( x , y ) ∧∃ x ¬∀ yP ( x , y ))
(c) ¬∀ x ( ∃ yP ( x , y ) ∨∀ yQ ( x , y ))
(d) ¬∀ x ¬∃ y ( ¬∀ zP ( x , z ) →∃ zQ ( x , y , z ))
(e) ¬∃ x ( ¬∀ y [ ∃ z ( P ( y , x , z ) ∧ P ( y , z , x ) ∧ P ( x , y , z ))] ∨∃ zQ ( x , z ))

Problems 39
Problem 2.16. Let P ( x , y )=“ x likes y ”, where the universe of discourse for x and y is the set of
all people. Translate each of the following into English, sm oothing them out as much as possible.
Then give the truth value of each.
(a) ∀ x ∀ yP ( x , y )
(b) ∀ x ∃ yP ( x , y )
(c) ∀ y ∃ xP ( x , y )
(d) ∀ xP ( x , Raymond )
(e) ¬∀ x ∀ yP ( x , y )
(f) ∀ x ¬∀ yP ( x , y )
(g) ∀ x ¬∀ y ¬ P ( x , y )
2 2 2 Problem 2.17. Let P ( x , y , z )=“ x + y = z ”, where the universe of discourse for all variables is
the set of integers. What are the truth values of each of the fo llowing?
(a) ∀ x ∀ y ∀ zP ( x , y , z )
(b) ∃ x ∃ y ∀ zP ( x , y , z )
(c) ∀ x ∃ y ∃ zP ( x , y , z )
(d) ∀ x ∀ y ∃ zP ( x , y , z )
(e) ∀ x ∃ y ∀ zP ( x , y , z )
(f) ∃ x ∃ y ∃ zP ( x , y , z )
(g) ∃ zP (2, 3, z )
(h) ∃ x ∃ yP ( x , y , 5)
(i) ∃ x ∃ yP ( x , y , 3)
Problem 2.18. Write each of the following sentences using quantifiers and p ropositional functions.
Define propositional functions as necessary (e.g. Let D ( x ) be the proposition ‘ x plays disc golf.’)
(a) All disc golfers play ultimate Frisbee.
(b) If all students in my class do their homework, then some of the students will pass.
(c) If none of the students in my class study, then all of the st udents in my class will fail.
(d) Not everybody knows how to throw a Frisbee 300 feet.
(e) Some people like ice cream, and some people like cake, but everybody needs to drink water.
(f) Everybody loves somebody.
(g) Everybody is loved by somebody.
(h) Not everybody is loved by everybody.

40 Chapter 2
(i) Nobody is loved by everybody.
(j) You can’t please all of the people all of the time, but you c an please some of the people some
of the time.
(k) If only somebody would give me some money, I would buy a new house.
(l) Nobody loves me, everybody hates me, I’m going to eat some worms.
(m) Every rose has its thorn, and every night has its dawn.
(n) No one ever is to blame.
Problem 2.19. Consider the following expression:
∀ ǫ> 0 ∃ δ> 0 ∀ x (0 < | x − c | < δ →| f ( x ) − L | < ǫ ).
(a) Express it in English. Be as concise as possible.
(b) (Difficult if you have not had calculus.) This is the definit ion of something. What is it?
Problem 2.20. Use Procedure 2.93 to find the disjunctive normal form for each of the expression s
2.1 . from Problem

Chapter 3: Proof Methods
The ability to write proofs is important. Although you may no t find yourself writing proofs on a
regular basis in your future career, you will certainly need to make arguments based on evidence
and logic. Proof writing is exactly that, although it is typi cally more formal, and the subjects of
our proofs are generally mathematical. Nevertheless, what you learn here is definitely applicable
way beyond writing mathematical proofs of simple mathemati cal results (which will be the focus
of our proof writing).
In the context of discrete mathematics and algorithms, proo fs will be important in several
places. I will highlight just one here: algorithms. When you write an algorithm it is important
that the algorithm performs as expected, both in terms of pro ducing the correct answer and doing
so quickly. That is, proofs are necessary in algorithm correctness and algorithm analysis . Although
we will see examples of both, we will spend more time learning about algorithm analysis.
In this chapter we will introduce you to the basics of mathema tical proofs. Along the way we
will review some mathematical concepts/definitions you hav e probably already seen, and introduce
you to some new ones that we will find useful as we proceed. We wi ll continue to write proofs and
learn more advanced proof techniques as the book continues.
3.1  Direct Proofs
A direct proof is one that follows from the definitions. Facts previously le arned help many a time
when writing a direct proof. We will begin by seeing some dire ct proofs about something you should
already be very familiar with: even and odd integers.
Definition 3.1. Recall that:
• An even integer is one of the form 2 k , where k is an integer.
• An odd integer is one of the form 2 k + 1 where k is an integer.
• Two integers have the same parity if they are both even or both odd.
Example 3.2. Use the definition of even to prove that the sum of two even inte gers is even.
Proof: If x and y are even, then x = 2 a and y = 2 b for some integers a and b .
Then x + y = 2 a + 2 b = 2( a + b ), which is even since a + b is an integer. 
Example 3.3. Use the definitions of even and odd to prove that the sum of an ev en integer
and an odd integer is odd.
Proof: Let a be an even integer and b be an odd integer. Then a = 2 f and
b = 2 g + 1 for some integers f and g . Then a + b = 2 f + (2 g + 1) = 2( f + g ) + 1.
Since f + g is an integer, a + b is an odd integer. 
41

42 Chapter 3
⋆ Fill in the details 3.4. Use the definitions of even and odd to prove that the sum of two
odd integers is even.
for some integers Proof: If x and y are odd, then x = 2 c +1 and y =
c and d . Then x + y = 2 c +1+2 d +1 = 2( c + d +1). Now is an integer,
integer.  so 2( c + d + 1) is an
Example 3.5. Use the definitions of even and odd to prove that the product of two odd
integers is odd.
Proof: Let a and b be odd integers. Then a = 2 l + 1 and b = 2 m + 1 for some
integers l and m . Then a · b = (2 l +1)(2 m +1) = 4 ml +2 l +2 m +1 = 2(2 ml + l + m )+1
which is odd since 2 ml + m + l is an integer. 
⋆ Fill in the details 3.6. Use the definitions of even and odd to prove that the product of
an even integer and an odd integer is even.
Proof: Let a be an even integer and b be an odd integer. Then a =
and b = for . Given that, we can see that a · b =
. Since is an integer, a · b (2 n )(2 o + 1) =
is . 
These examples may seem somewhat ridiculous since they are p roving such obvious facts. How-
ever, keep in mind that our goal is to learn techniques for wri ting proofs. As we proceed the proofs
will become more complicated, but we will continue to follow the same basic techniques we are
using here. In other words, the fact that we are proving facts about even and odd integers is not
at all important. What is important are the techniques we are learning in the process.
You may be asking yourself “why are we wasting our time provin g such obvious results”? If so,
ask yourself this: Would you rather be asked to prove more com plicated things right away?
Think about how you learned to read and write. You started by r eading books that only had a
few simple words. As you progressed, the books and the words i n them got longer. The vocabulary
increased. You encountered increasingly complex sentence and paragraph structures. The same
is true when you learned to write. You began by writing the let ters of the alphabet. Then you
learned to write words, followed by sentences, paragraphs, and eventually essays.
Learning to read and write proofs follows the same procedure . In order to know how to write
correct proofs you first need to see some examples of them. But you need to go beyond just seeing
them–you need to understand them. That is the goal of examples like the previous one. Your brain
needs to be engaged with the material as you work through the b ook. You must work through all
of the examples in order to get the most out of this book.

Direct Proofs 43
⋆ Exercise 3.7. Use the definition of even to prove that the product of two even integers is
even.
Proof:
⋆ Evaluate 3.8. Evaluate the following proof that supposedly uses the defini tion of odd to
prove that the product of two odd integers is odd.
Proof: By  definition  of  odd  numbers,  let  a  be  an  odd  integer  2n + 1  let
b  be  an  odd  integer  2q+1.   Then  (2n+1)(2q+1)  =  4nq+2n+1  =  2(2nq+1)+1.
Since  2nq + 1  is  an  integer,  2(2nq + 1) + 1  is  an  odd  integer   by  definition
of  odd. 
Evaluation
Sometimes students get frustrated because they think that t oo many details are required in
a proof. Why are mathematicians such sticklers on the detail s? The next example is the first of
many that will try to demonstrate why the seemingly little de tails matter.
⋆ Question 3.9. What is wrong with the following “proof” that the sum of an eve n and an
odd number is even?
Proof: Let  a=2n  be  an  even  integer  and  b  =  2m + 1  be  an  odd  integer.
Then   a  +  b  =  2n  +  2m  +  1  =  2(n  +  m  +  1 / 2). Since   we   wrote   a  +  b   as   a
multiple   of   2,    it   is   even. Therefore   the   sum   of   an   even   and   an   odd
number   is   even. 
Answer
We will find the following definitions useful throughout the b ook.

44 Chapter 3
Definition 3.10. Let b and a be integers with a 6 = 0 . We say that b is divisible by a if there
exists an integer c such that b = ac . If b is divisible by a , we also say that b is a multiple of
a , a is a factor or divisor of b , and that a divides b , written as a | b . If a does not divide b ,
we write a ∤ b .
Example 3.11. Since 6 = 2 · 3, 2 | 6, and 3 | 6. But 4 ∤ 6 since we cannot write 6 = 4 · c for any
integer c .
Example 3.12. Prove that the product of two even integers is divisible by 4.
Proof: Let 2 h and 2 k be even integers. Then (2 h )(2 k ) = 4( hk ). Since hk is an
integer, 4( hk ) is divisible by 4. 
⋆ Fill in the details 3.13. Prove that if x is an integer and 7 divides 3 x + 2, then 7 also
2 divides 15 x − 11 x − 14.
. Proof: Since 7 divides 3 x +2, we know that 3 x +2 = 7 a , where a is
Notice that
2 15 x − 11 x − 14  =  ( )( )
= a (5 x − 7).
.  Therefore
Example 3.14. Let a and b be integers such that a | b and b | a . Prove that either a = b or
a = − b .
Proof: If a | b , we can write b = ac for some integer c . Similarly, if b | a , we can
write a = bd for some integer d . Then we can write b = ac = ( bd ) c . Dividing both
sides by b (which is legal, since b | a implies b 6 = 0), we can see that cd = 1. Since c
and d are integers, we know that either c = d = 1 or c = d = − 1. In the first case,
we have that a = b , and in the second case, we have that a = − b . 
3 ⋆ Evaluate 3.15. Prove that if n is an integer, then n − n is divisible by 6.
3 Proof: We  have  n − n  =  (n − 1)n(n + 1),  the  product  of  three  consecutive
integers.    Among   three   consecutive   integers   at   least   one   is   even   and
exactly  one  is  divisible  by  3.   Since  2  and  3  do  not  have  common  factors,
3 6  divides   the   quantity  (n − 1)n(n + 1),  and  so   n − n  is   divisible   by  6. 
Evaluation

Direct Proofs 45
Definition 3.16. A positive integer p > 1 is prime if its only positive factors are 1 and p . A
positive integer c > 1 which is not prime is said to be composite .
⋆ Evaluate 3.17. Prove or disprove that if a is a positive even integer, then it is composite.
Proof: Let   a   be   an   even   number. By   definition   of   even,   a  =  2k   for
some   integer   k. Since   a > 0,   clearly   k > 0. Since   a   has   at   least   two
factors,  2  and  k,  a   is   composite. 
Evaluation
Note: Notice that according to the definitions given above, 1 is neither prime nor composite.
This is one of the many things that makes 1 special.
⋆ Exercise 3.18. Prove that 2 is the only even prime number.
Proof
⋆ Question 3.19. Did you notice that the proof in the solution to the previous e xercise (you
read it, right?) did not consider the case of 0 or negative eve n numbers. Was that O.K.?
Explain why or why not.
Answer
Definition 3.20. For a non-negative integer n , the quantity n ! (read “ n factorial” ) is defined
as follows. 0! = 1 and if n > 0 then n ! is the product of all the integers from 1 to n inclusive:
n ! = 1 · 2 ··· n .
Example 3.21. 3! = 1 · 2 · 3 = 6, and 5! = 1 · 2 · 3 · 4 · 5 = 120.
n Example 3.22. Prove that if n > 0, then n ! ≤ n .

46 Chapter 3
Proof: Since 1 ≤ n , 2 ≤ n , ··· , and ( n − 1) ≤ n , it is easy to see that
n !  =  1 · 2 · 3 ··· n
≤ n · n · n ··· n
n = n .

⋆ Evaluate 3.23. Prove that if n > 4 is composite, then n divides ( n − 1)!.
Proof: Since  n  is  composite,  n  =  ab  for  some  integers  1 < a < n − 1  and
1 < b < n − 1.   By   definition   of   factorial,   a | (n − 1)!   and   b | (n − 1)!.   Therefore
n  =  ab  divides   (n − 1)! 
Evaluation
Since the previous proof wasn’t correct, let’s fix it.
Example 3.24. Prove that if n > 4 is composite, then n divides ( n − 1)!.
Proof: If n is not a perfect square, then we can write n = ab for some integers a
and b with 1 < a < b < n − 1. Thus, ( n − 1)! = 1 ··· a ··· b ··· ( n − 1). Since a and
b are distinct numbers on the factor list, n = ab is clearly a factor of ( n − 1)!.
2 If n is a perfect square, then n = a for some integer 2 < a < n − 1. Since a > 2,
2 2 a < a = n . Thus, 2 a < n , so ( n − 1)! = 1 ··· a ··· 2 a ··· ( n − 1). Then a (2 a ) = 2 n
is a factor of ( n − 1)!, which means that n is as well. 
⋆ Question 3.25. Why was it O.K. to assume 1 < a < b < n − 1 in the previous proof?
Answer
⋆ Question 3.26. In the second part of the previous proof, why could we say that a > 2?
Answer
Example 3.27. Prove the Arithmetic Mean-Geometric Mean Inequality , which states that for
all non-negative real numbers x and y ,
x + y √
. xy ≤
2

Direct Proofs 47
√ √ √ √
Proof: Since x and y are non-negative, x and y are real numbers, so x − y
is a real number. Since the square of any real number is greate r than or equal to 0
we have
√ √ 2
x − y ) ≥ 0. (
Expanding (recall the FOIL method?) we get
√
x − 2 xy + y ≥ 0.
√
Adding 2 xy to both sides and dividing by 2, we get
√ x + y
≥ xy ,
2
yielding the result. 
The previous example illustrates the creative part of writi ng proofs.  The proof started out
√ √
x − y , which doesn’t seem to be related to what we wanted to prove. B ut hopefully considering
after you read the entire proof you see why it makes sense. If y ou are saying to yourself “I would
√ √
x − y ?,” or “How do you know where to start?,” I am never have thought of starting with
afraid there are no easy answers. Writing proofs is as much of an art as it is a science. There are
three things that can help, though. First, don’t be afraid to experiment . If you aren’t sure where
to begin, try starting at the end. Think about the end goal and work backwards until you see a
connection. Sometimes working both backward and forward ca n help. Try some algebra and see
where it gets you. But in the end, make sure your proof goes fro m beginning to end. In other
words, the order that you figured things out should not necess arily dictate the order they appear
in your proof.
The second thing you can do is to read example proofs . Although there is some creativity
necessary in proof writing, it is important to follow proper proof writing techniques. Although there
are often many ways to prove the same statement, there is ofte n one technique that works best for
a given type of problem. As you read more proofs, you will begi n to have a better understanding of
the various techniques used, know when a particular techniq ue might be the best choice, and become
better at writing your own proofs. If you see several proofs o f similar problems, and the proofs look
very similar, then when you prove a similar problem, your pro of should probably resemble those
proofs. This is one area where some students struggle—they s ubmit proofs that look nothing like
any of the examples they have seen, and they are often incorre ct. Perhaps it is because they are
afraid that they are plagiarizing if they mimic another proo f too closely. However, mimicking a
proof is not the same as plagiarizing a sentence. To be clear, by ‘mimic’, I don’t mean just copy
exactly what you see. I mean that you should read and understa nd several examples. Once you
understand the technique used in those examples, you should be able to see how to use the same
technique in your proof. For instance, in many of the example s related to even numbers, you may
have noticed that they start with statement like “Assume x is even. Then x = 2 a for some integer
a .” So if you need to write a proof related to even numbers, what so rt of statement might make
sense to begin your proof?
The third thing that can help is practice .  This applies not only to writing proofs, but to
learning many topics. An analogy might help here. Learning i s often like sports—you don’t learn
how to play basketball (or insert your favorite sport, video game, or other hobby that takes some
skill) by reading books and/or watching people play it. Thos e things can be helpful (and in some
cases necessary), but you will never become a proficient bask etball player unless you practice.
Practicing a sport involves running many drills to work on th e fundamentals and then applying

48 Chapter 3
the skills you learned to new situations. Learning many topi cs is exactly the same. First you need
to do lots of exercises to practice the fundamental skills. T hen you can apply those skills to new
situations. When you can do that well, you know you have a good understanding of the topic. So
if you want to become better at writing proofs, you need to wri te more proofs.
⋆ Question 3.28. What three things can help you learn to write proofs?
1.
2.
3.

Implication and Its Friends 49
3.2  Implication and Its Friends
This section is devoted to developing some of the concepts th at will be necessary for us to discuss
the ideas behind the next few proof techniques.
Although not technically interchangeable, you may sometim es see the word statement instead of
proposition . Context should help you determine whether or not a given usa ge of the word statement
should be understood to mean proposition . We saw the following in the previous chapter, but it is
worth giving the definition again (stated slightly differentl y here so it better fits with our usage in
this context).
Definition 3.29. An implication is a proposition of the form “if p , then q ,” where p and q
are propositions. p is called the premise and q is called the conclusion .
It is sometimes written as p → q , which is read “ p implies q .” It is a statement that asserts
that if p is a true proposition then q is a true proposition.
An implication is true unless p is true and q is false.
Example 3.30. The proposition “If I do well in this course, then I can take th e next course”
is an implication. However, the proposition “I can do well in this course and take the next
course” is not an implication.
Example 3.31. Consider the implication
a “If you read xkcd , then you will laugh.”
If you read xkcd and laugh, you are being consistent with the proposition. If you read xkcd and
do not laugh , then you are demonstrating that the proposition is false.
But what if you don’t read xkcd ? Are you demonstrating that the proposition is true or
false? Does it matter whether or not you laugh? It turns out th at you are not disproving it
in this case–in other words, the proposition is still true if you don’t read xkcd , whether or not
you laugh. Why? Because the statement is not saying anything about laughing by itself. It is
only asserting that IF you read xkcd , then you will laugh. In other words, it is a conditional
statement , with the condition being that you read xkcd . The statement is saying nothing about
anything if you don’t read xkcd .
So the bottom line is that if you do not read xkcd , the statement is still true.
a If you are unfamiliar with xkcd , go to http://xkcd.com , but don’t get distracted for too long!
⋆ Question 3.32. When is the implication “If you read xkcd , then you will laugh” false?
Answer

50 Chapter 3
⋆ Exercise 3.33. Consider the implication “If you build it, they will come.” W hat are all of
the possible ways this proposition could be false?
Solution
Given an implication p → q , there are three related propositions. We will introduce ea ch and
discuss how they are related to each other.
Definition 3.34. The contrapositive of a proposition of the form “if p , then q ” is the propo-
sition “if q is not true, then p is not true” or “if not q , then not p ” or ¬ q →¬ p .
⋆ Question 3.35. What is the contrapositive of the proposition “If you know Ja va, then you
know a programming language”?
Answer
Theorem 3.36. An implication is true if and only if its contrapositive is tr ue. Stated another
way, an implication and its contrapositive are equivalent .
⋆ Fill in the details 3.37. Prove Theorem 3.36 .
Proof: Let p → q be our implication. According to the definition of implicati on,
it is false when p is true and q is false and otherwise. Put another
way, it is true unless p is true and q is false.  The contrapositive, ¬ q → ¬ p , is
is false, and true otherwise. Notice that this is false when ¬ q is true and
equivalent to q being and being true. Thus, the contrapositive is
true unless and . But this is
exactly when p → q is true. 
Definition 3.38. The inverse of a proposition of the form “if p , then q ” is the proposition
“if p is not true, then q is not true” or “if not p , then not q ” or ¬ p →¬ q .

Implication and Its Friends 51
⋆ Question 3.39. What is the inverse of the proposition “If you know Java, then you know
a programming language”?
Answer
⋆ Question 3.40. Are a proposition and its inverse equivalent? Explain, usin g the proposition
3.39 as an example. from Question
Answer
Definition 3.41. The converse of a proposition of the form “if p , then q ” is the proposition
“if q , then p ” or q → p .
⋆ Question 3.42. What is the converse of the proposition “If you know Java, the n you know
a programming language”?
Answer
⋆ Question 3.43. Are a proposition and its converse equivalent? Explain usin g the proposi-
tion about Java/programming languages.
Answer
As you have just seen, the inverse and converse of an implication are not equivalent to the
implication. However, it turns out that the inverse and converse of a proposition are equivalent to
each other.
Theorem 3.44. The inverse of an implication is true if and only if the convers e of the im-
plication is true. Stated another way, the inverse and converse of an implication are
equivalent to each other .
You will be asked to prove Theorem 3.44 in Problem 3.2 . If you think about it in the right way,
3.1 summarizes what we know. it should be fairly easy to prove. Table

52 Chapter 3
™
Implication p → q
Equivalent
Contrapositive ¬ q →¬ p
™
Converse q → p
Equivalent
Inverse ¬ p →¬ q
Table 3.1: Implication and friends
Example 3.45. Here is an example of an implication and its friends:
1. Implication If I get to watch “The Army of Darkness,” then I will be happy.
2. Inverse If I do not get to watch “The Army of Darkness,” then I will not b e happy.
3. Converse If I am happy, then I got to watch “The Army of Darkness.”
4. Contrapositive If I am not happy, then I didn’t get to watch “The Army of Darkne ss.”
⋆ Question 3.46. Using the propositions from the previous example, answer th e following
questions.
(a) Give an explanation of why an implication might be true, but the inverse false.
Answer
(b) Explain why an implication is saying the exact same thing as its contrapositive . (Don’t
just say “By Theorem 3.36 .”)
Answer
Implications can be tricky to fully grasp and it is easy to get your head turned around when
dealing with them. We will discuss them in quite a bit of detai l throughout the next few sections
in order to help you understand them better.

Proof by Contradiction 53
3.3  Proof by Contradiction
In this section we will see examples of proof by contradiction .  For this technique, when trying to
prove a statement, we assume that its negation is true and ded uce incompatible statements from
this (i.e. we prove something we know to be false). This impli es that the original statement must
be true.
When applied to a proposition, we assume that the premise is t rue but the conclusion is false,
with the goal still to show that something that is false is tru e. Since we “obtained a contradiction,”
it must be that the conclusion is true. We will explain in more detail the idea behind this proof
technique after a few examples.
Example 3.47. Prove that if 5 n + 2 is odd, then n is odd.
Proof: Assume that 5 n + 2 is odd, but that n is even. Then n = 2 k for some
integer k . This implies that 5 n + 2 = 5(2 k ) + 2 = 10 k + 2 = 2(5 k + 1), which is
even. But this contradicts our assumption that 5 n + 2 is odd. Therefore it must be
the case that n is odd. 
The idea behind this proof is that if we are given the fact that 5 n + 2 is odd, we are asserting
that n must be odd. How do we prove that n is odd? We could try a direct proof, but it
is actually easier to use a proof by contradiction in this cas e. The idea is to consider what
would happen if n is not odd. What we showed was that if n is not odd, then 5 n + 2 has to
be even. But we know that 5 n + 2 is odd because that was our initial assumption. How can
5 n + 2 be both odd and even? It can’t. In other words, our proof lea d to a contradiction–an
impossibility. Therefore, something is wrong with the proo f. But what? If n is indeed even,
our proof that 5 n + 2 is even is correct. So there is only one possible problem– n must not be
even. The only alternative is that n is odd. Can you see how this proves the statement “if
5 n + 2 is odd, then n is odd?”
Note: If you are somewhat confused at this point that’s probably O.K . Keep reading, and re-
read this section a few times if necessary. At some point you w ill have an “Aha” moment and
the idea of contradiction proofs will make sense.
√
Example 3.48. Prove that if n = ab , where a and b are positive integers, then either a ≤ n
√
or b ≤ n .
√
n or Proof: Let’s assume that n = ab but that the statement “either a ≤
√ √ √
b ≤ n ” is false. Then it must be the case that a > n and b > n . But then
√ √
n n = n . But this contradicts the fact that ab = n . Since our assumption ab >
√ √
that a > n and b > n lead to a contradiction, it must be false. Therefore it
√ √
n or b ≤ n .  must be the case that either a ≤
Sometimes your proofs will not directly contradict an assum ption made but instead will con-
tradict a statement that you otherwise know to be true. For in stance, if you ever conclude that
0 > 1, that is a contradiction. The next example illustrates thi s.

54 Chapter 3
√ 1
⋆ Fill in the details 3.49. Show, without using a calculator, that 6 − 35 < .
10
√ 1 1
35 ≥ . If we multiple Proof: Assume that 6 − . Then 6 − ≥
10 10
both sides by 10 and do a little arithmetic, we can see that 59 ≥ .
Squaring both sides we obtain , which is clearly .
√ 1
35 < Thus it must be the case that 6 − . 
10
Now that we have seen a few examples, let’s discuss contradic tion proofs a little more formally.
Here is the basic concept of contradiction proofs: You want t o prove that a statement p is true.
You “test the waters” by seeing what happens if p is not true. So you assume p is false and use
proper proof techniques to arrive at a contradiction. By “co ntradiction” I mean something that
cannot possibly be true. Since you proved something that is n ot true, and you used proper proof
techniques, then it must be that your assumption was incorre ct. Therefore the negation of your
assumption—which is the original statement you wanted to pr ove—must be true.
⋆ Evaluate 3.50. Use the definition of even and odd to prove that if a and b are integers and
ab is even, then at least one of a or b is even.
Proof   1: By   definition   of   even   numbers,   let   a   be   an   even   integer   2n,   and
by    the    definition    of    odd    numbers,    let    b    be    an    odd    integer    2q  +  1. Then
(2n)(2q +  1)  =  4nq +  2n  =  2(2nq +  1).    Since   2nq +  1   is   an   integer,   2(2nq +  1)
is   an  even  integer   by   definition   of   even.
Evaluation
Proof   2: If   true,    either   one   is   odd   and   the   other   even,    or   they   are   both
even,   so   we   will   show   that   the   product   of   an   even   and   an   odd   is   even,   and
that  the   product  of   two  evens   integers   is   even.
Let   a  =  2k   and   b  =  2x  +  1. (2k)(2x  +  1)  =  4kx  +  2k  =  2(2kx  +  k). 2kx  +  k   is   an
integer   so   2(2kx + k)   is   even.
Let   a   =   2k   and   b   =   2x. (2k)(2x)   =   4kx   =   2(2kx)   since    2kx   is   an   integer,
2(2kx)  is   even.
Thus,   if   a  and  b  are  integers,   ab  is   even,   at  least   one  of   a  or   b  is   even.
Evaluation

Proof by Contradiction 55
Proof   3: Let    a    and    b    be    integers    and    assume    that    ab    is    even, but    that
neither    a    nor    b    is    even. Then    both    a    and    b    are    odd,    so    a   =   2n  +  1    and
b   =   2m  +  1   for   some   integers   n   and   m. But   then   ab   =   (2n  +  1)(2m  +  1)   =
4nm + 2n + 2m  + 1  =  2(2nm + n + m)  + 1,   which   is   odd   since   2nm  + n + m   is   an
integer.   This   contradicts   the   fact   that   ab   is   even.   Therefore   eith er   a   or   b
must  be   even.
Evaluation
For some students, the trickiest part of contradiction proo fs is what to contradict. Sometimes
the contradiction is the fact that p is true. At other times you arrive at a statement that is clear ly
false (e.g. 0 > 1). Generally speaking, you should just try a few things (e.g . do some algebra) and
see where it leads. With practice, this gets easier. In fact, with enough practice this will probably
become one of your favorite techniques. When a direct proof d oesn’t seem to be working this is
usually the next technique I try.
Example 3.51. Let a , a , . . . , a be real numbers. Prove that at least one of these numbers 1 2 n
is greater or equal to the average of the numbers.
Proof: The average of the numbers is A = ( a + a + . . . + a ) /n . Assume that none 1 2 n
of these numbers is greater than or equal to A . That is, a < A for all i = 1, 2, . . . n . i
Thus ( a + a + . . . + a ) < nA . Solving for A , we get A > ( a + a + . . . + a ) /n = A , 1 2 n 1 2 n
which is a contradiction. Therefore at least one of the numbe rs is greater than or
equal to the average. 
Our next contradiction proof involves permutations . Here is the definition and an example in
case you haven’t seen these before.
Definition 3.52. A permutation is a function from a finite set to itself that reorders the
elements of the set. Since we haven’t formally discussed fun ctions yet, the following informal
definition will probably make more sense to some of you: a permutation of a set of objects is
an ordering of those objects.
Example 3.53. Let S be the set { a , b , c } . Then ( a , b , c ), ( b , c , a ) and ( a , c , b ) are permutations
of S . ( a , a , c ) is not a permutation of S because it repeats a and does not contain b . ( b , d , a ) is
not permutations of S because d is not in S , and c is missing.
⋆ Exercise 3.54. List all of the permutations of the set { 1, 2, 3 } . (Hint: There are 6.)
Answer

56 Chapter 3
Note: In many contexts, when a list of objects occurs in curly braces , the order they are
listed does not matter (e.g. { a , b , c } and { b , c , a } mean the same thing). On the other hand,
when a list occurs in parentheses , the order does matter. Thus, ( a , b , c ) and ( b , c , a ) do not
mean the same thing.
Example 3.55. Let ( a , a , . . . , a ) be an arbitrary permutation of the numbers 1, 2, . . . , n , 1 2 n
where n is an odd number. Prove that the product ( a − 1)( a − 2) ··· ( a − n ) is even. 1 2 n
Proof: Assume that the product is odd. Then all of the differences a − k must k
be odd. Now consider the sum S = ( a − 1)+( a − 2)+ ··· +( a − n ). Since the a ’s 1 2 n k
are a just a reordering of 1, 2, . . . , n , S = 0. But S is the sum of an odd number of
odd integers, so it must be odd. Since 0 is not odd, we have a con tradiction. Thus
our initial assumption that all of the a − k are odd is wrong, so at least one of k
them is even and hence the product is even. 
⋆ Question 3.56. Why did the previous proof begin by assuming that the product was odd?
Answer
⋆ Question 3.57. In the previous proof, we asserted that S = 0. Why was this the case?
Answer
We will use facts about rational/irrational numbers to demo nstrate some of the proof techniques.
In case you have forgotten, here are the definitions.
Definition 3.58. Recall that
• A rational number is one that can be written as p/q , where p and q are integers, with
q 6 = 0 .
• An irrational number is a real number that is not rational.
√
Example 3.59. Prove that 2 is irrational. We present two slightly different proofs. In b oth,
we will use the fact that any positive integer greater than 1 c an be factored uniquely as the
product of primes (up to the order of the factors).

Proof by Contradiction 57
√ a
, where a and b are positive integers with b 6 = 0. We can Proof 1:  Assume that 2 =
b
assume a and b have no factors in common (since if they did, we could cancel t hem and
use the resulting numerator and denominator as a and b ). Multiplying by b and squaring
2 2 2 both sides yields 2 b = a . Clearly 2 must be a factor of a . Since 2 is prime, a must have
2 2 2 2 2 as a factor, and therefore a has 2 as a factor. Then 2 b must also have 2 as a factor.
2 But this implies that 2 is a factor of b , and therefore a factor of b . This contradicts the
√
2 must be irrational. fact that a and b have no factors in common. Therefore
√ a
Proof 2:  Assume that , where a and b are positive integers with b 6 = 0. Multiplying 2 =
b
2 2 2 2 by b and squaring both sides yields 2 b = a . Now both a and b have an even number
2 2 of prime factors. So 2 b has an odd number of primes in its factorization and a has
an even number of primes in its factorization. This is a contr adiction since they are the √
same number. Therefore 2 must be irrational.
2 2 ⋆ Question 3.60. In proof 2 from the previous example, why do a and b have an even
number of factors?
Answer
Now that you have seen a few more examples, it is time to begin t he discussion about how/why
contradiction proofs work. We will start with the following idea that you may not have thought
of before. It turns out that if you start with a false assumpti on, then you can prove that anything
is true. It may not be obvious how (e.g. How would you prove tha t all elephants are less than 1
foot tall given that 1 + 1 = 1?), but in theory it is possible. Th is is because statements of the form
“ p implies q ” are true if p (called the premise ) is false, regardless of whether or not q (called the
conclusion ) is true or false.
Example 3.61. The statement “If chairs and tables are the same thing, then t he moon is
made of cheese” is true. This may seem weird, but it is correct . Since chairs and tables are
not the same thing, the premise is false so the statement is tr ue. But it is important to realize
that the fact that the whole statement is true doesn’t tell us anything about whether or not
the moon is made of cheese. All we know is that if chairs and tables were the same thing, then
the moon would have to be made out of cheese in order for the statement to be true.
Example 3.62. Consider what happens if your parents tell you “If you clean y our room, then
we will take you to get ice cream.” If you don’t clean your room and your parents don’t take
you for ice cream, did your parents tell a lie? No. What if they do take you for ice cream?
They still haven’t lied because they didn’t say they wouldn’ t take you if you didn’t clean your
room. In other words, if the premise is false, the whole state ment is true regardless of whether
or not the conclusion is true.
It is important to understand that when we say that a statemen t of the form “ p implies q ” is
true, we are not saying that q is true. We are only saying that if p is true, then q has to be true .

58 Chapter 3
We aren’t saying anything about q by itself. So, if we know that “ p implies q ” is true, and we also
know that p is true, then q must also be true. This is a rule called modus ponens , and it is at the
heart of contradiction proofs as we will see shortly.
⋆ Exercise 3.63. It might help to think of statements of the form “ p implies q ” as rules where
breaking them is equivalent to the statement being false. Fo r instance, consider the statement
“If you drink alcohol, you must be 21.” If we let p be the statement “you drink alcohol” and
q be the statement “you are 21,” the original statement is equi valent to “ p implies q ”.
1. If you drink alcohol and you are 21, did you break the rule?
2. If you drink alcohol and you are not 21, did you break the rul e?
3. If you do not drink alcohol and you are 21, did you break the r ule?
4. If you do not drink alcohol and you are not 21, did you break t he rule?
5. Generalize the idea. If you have a statement of the form “ p implies q ”, where p and q
can be either true or false statements, exactly when can the s tatement be false?
6. If you do not drink alcohol, does it matter how old you are?
7. Can a statement of the form “ p implies q ” be false if p is false? Explain.
Now we are ready to explain the idea behind contradiction pro ofs. We want to prove some
statement p is true. We begin by assuming it is false—that is, we assume ¬ p is true. We use this
fact to prove that q —some false statement—is true. In other words, we prove that the statement
“ ¬ p implies q ” is true, where q is some false statement. But if ¬ p is true, and “ ¬ p implies q ” is true,
modus ponens tells us that q is true. Since we know that q is false, something is wrong. We only
have two choices: either ¬ p is false or “ ¬ p implies q ” is false. If we used proper proof techniques
to establish that “ ¬ p implies q ” is true, then that isn’t the problem. Therefore, ¬ p must be false,
implying that p is true. That is why contradiction proofs work.
3.59 in light of this discussion. The only assump- Let’s analyze the second proof from Example √ √
tion we made was that 2 is rational ( ¬ p =“ 2 is rational”). From this (and only this), we were
2 2 able to show that a has both an even and an odd number of factors ( q =“ a has an even and an odd
number of factors”, and we showed that “ ¬ p implies q ” is true). Thus, we know for certain that if √
2 1 2 is rational, then a This fact is indisputable since has an even and an odd number of factors.
√
2 2 is rational, modus ponens implies that a has an even and an we proved it. If it is also true that
√ 2 1 2
2 is rational , then a We did not prove that a has an even and an odd number of factors. We proved that if
has an even and an odd number of factors. It is very important t hat you understand the difference between these
two statements.

Proof by Contradiction 59
2 odd number of factors. This is also indisputable. But we know that a cannot have both an even
and odd number of factors. In other words, we have a contradic tion. Therefore, something that
has been said somewhere is wrong. Everything we said is indis putable except for one thing–that √
2 is rational. That was never something we proved—we just ass umed it. So it has to be the case √
2 must be irrational. that this is false, which means that
To summarize, if you want to prove that a statement is true usi ng a contradiction proof, assume
the statement is false, use this assumption to get a contradi ction (i.e. prove a false statement), and
declare that it must therefore be true.
Notice that what q is doesn’t matter. In other words, given the assumption ¬ p , the goal in a
contradiction proof is to establish that any false statement is true. This is both a blessing and a
curse. The blessing is that any contradiction will do. The cu rse is that we don’t have a clear goal in
mind, so it can sometimes be difficult to know what to do. As ment ioned previously, this becomes
easier as you read and write more proofs.
If this discussion has been a bit confusing, try re-reading i t. The better you understand the
theory behind contradiction proofs, the better you will be a t writing them. We will revisit some of
these concepts in the chapter on logic, so the more you unders tand from here, the better off you
will be when you get there. O.K., enough theory. Let’s see som e more examples!
⋆ Fill in the details 3.64. Let a , b be real numbers. Prove that if a < b + ǫ for all ǫ > 0,
then a ≤ b .
a . Subtract- Proof: We will prove this by contradiction. Assume that
ing b from both sides and dividing by 2, we get > 0. Since the in-
b equality a < b + ǫ holds for every ǫ > 0 in particular it holds for ǫ = .
This implies that
a − b
= a < b + .
2
(to the previous equation), we If we
obtain a < b . But we started with the assumption that which is a
. Therefore, . 
a Hint: What assumption do we always make when doing a contradi ction proof?
b Same as the previous blank
The following beautiful proof goes back to Euclid.  It uses th e assumption that any integer
greater than 1 is either a prime or a product of primes.
Example 3.65 (Euclid) . Show that there are infinitely many prime numbers.
Proof: Assume that there are only a finite number of primes and label t he primes

60 Chapter 3
{ p , p , . . . , p } . Consider the number 1 2 n
N = p p ··· p + 1. 1 2 n
This is a positive integer that is clearly greater than 1. Obs erve that none of the
primes on the list { p , p , . . . , p } divides N , since division by any of these primes 1 2 n
leaves a remainder of 1. Since N is larger than any of the primes on this list, it
is either a prime or divisible by a prime outside this list. Bu t we assumed the list
above contained all of the prime numbers. This is a contradic tion. Therefore there
must be infinitely many primes. 
2 + bx + c = 0 does not ⋆ Fill in the details 3.66. If a , b , c are odd integers, prove that ax
have a rational number solution.
p
Proof: Suppose is a rational solution to the equation. We may assume that
q
p and q have no prime factors in common, so either p and q are both odd, or one
p
is a solution, we know that is odd and the other even. Since
q
= 0.
2 2 , we obtain ap + bpq + cq = 0. If we
2 2 which contradicts If both p and q are odd, then ap + bpq + cq is
the fact that it is .
If p is even and q odd, then
.
If p is odd and q even, then
.
Since all possibilities leads to a contradiction, .

One final note on contradiction proofs: Only use one when you r eally need it. If a direct proof
will work, use it. If you use a contradiction proof instead, y ou will just be making the proof more
complicated for no good reason. Some students seem to grab on to contradiction proofs and try to
use it for everything, but they are not the best choice in many cases.

Proof by Contraposition 61
3.4  Proof by Contraposition
Consider the statement “If it rains, then the ground will get wet.” It should be pretty easy to
convince yourself that this is essentially equivalent to th e statement “If the ground is not wet,
then it didn’t rain.”  In fact, since the second statement is j ust the contrapositive of the first,
3.36 tells us that they are equivalent. Again, by equivalent we simply mean that either Theorem
both statements are true or both statements are false. This i s the idea behind the proof technique
in this section.
Definition 3.67. A proof by contraposition is a proof of a statement of the form “if p ,
then q ” that proves contrapositive statement instead. That is, it p roves the equivalent statement
“if not q , then not p .”
Example 3.68. Prove that if 5 n + 2 is odd, then n is odd.
Proof: We will instead prove that if n is even (not odd), then 5 n +2 is even (not
odd). Since this is the contrapositive of the original state ment, a proof of this will
prove that that the original statement is true.
Assume n is even. The n = 2 a for some integer a . Then 5 n + 2 = 5(2 a ) + 2 =
2(5 a + 1). Since 5 a + 1 is an integer, 2(5 a + 1) is even. 
Be careful with proof by contraposition. Do not make the mist ake of trying to prove the converse
or inverse instead of the contrapositive . In that case, you may (sometimes) write a correct proof,
but it would be a proof of the wrong thing.
In the next example we will see the similarities and difference s between contradiction proofs
and proofs by contraposition.
Example 3.69. Prove that if 5 n + 2 is even, then n is even.
Proof by contradiction: Proof by contraposition:
Assume that 5 n + 2 is even but that n is We will prove the equivalent statement
odd. Since n is odd, n = 2 k +1 for some that if n is odd, then 5 n + 2 is odd.
integer k . Therefore Assume n is odd. Then n = 2 k + 1 for
some integer k . Then we have that
5 n + 2  =  5(2 k + 1) + 2
5 n + 2  =  5(2 k + 1) + 2 =  10 k + 5 + 2
=  10 k + 5 + 2 =  10 k + 7
=  10 k + 7 =  2(5 k + 3) + 1
=  2(5 k + 3) + 1
which is odd since 5 k + 3 is an integer.
But we assumed that 5 n + 2 was even, Since 5 k +3 is an integer, this shows that
which is a contradiction. Therefore our 5 n + 2 is odd.
assumption that n is odd must be incor-
rect, so n is even.

62 Chapter 3
⋆ Evaluate 3.70. Let n be an integer. Use the definition of even/odd to prove that if 3 n + 2
is even, then n is even using a proof by contraposition.
Proof   1: We   need   to   show   that   if   n   is   even,   then   3n  +  2   is   even. If   n   is
even,   then   n  =  2k   for   some   integer   k.    Then   3n  +  2  =  3(2k  +  2)  =  6k  +  6  =
2(3k) + 2(3),   which   is   even   because   it   is   the   sum   of   two  even   integers .
Evaluation
Proof   2: We   need   to   show   that   if   n   is   odd,   then   3n  +  2   is   odd.    If   n   is   odd
then  n  =  2k + 1  for  some  integer  k.   Then  3n + 2  =  3(2k + 1) + 2  =  6k + 3 + 2  =
6 k + 1),   which   is   clearly   odd. 6k + 5  =  5(
5
Evaluation
Proof   3: We   need   to   show   that   if   n   is   odd,   then   3n  +  2   is   odd.    If   n   is   odd
then   n  =   2k  +  1   for   some   integer   k. Then   3n  +  2  =  3(2k  +  1)  +  2  =  6k  +  5,
which   is   odd  by   the   definition   of  odd.
Evaluation

Other Proof Techniques 63
3.5  Other Proof Techniques
There are many other proof techniques. We conclude this chap ter with a small sampling of the
more common and/or interesting ones. We will see a few other i mportant proof techniques later in
the book.
Definition 3.71. A trivial proof is a proof of a statement of the form “if p , then q ” that
doesn’t use p in the proof.
2 2 Example 3.72. Prove that if x > 0, then ( x + 1) − 2 x > x .
Proof: It is easy to see that
2 2 ( x + 1) − 2 x =  ( x + 2 x + 1) − 2 x
2 = x + 1
2 >   x .
Notice that we never used the fact that x > 0 in the proof. 
Definition 3.73. A proof by counterexample is used to disprove a statement by giving an
example of it being false.
Example 3.74. Prove or disprove that the product of two irrational numbers is irrational.
√ √ √
3.59 that 2 is irrational. But 2 ∗ 2 = 2, Proof: We showed in Example
which is an integer so it is clearly rational. Thus the produc t of 2 irrational number
is not always irrational. 
Example 3.75. Prove or disprove that “Everybody Loves Raymond” (or that “E verybody
Hates Chris”).
Proof: Since I don’t really love Raymond (I also don’t hate Chris, in case you
care), the statement is clearly false. 
⋆ Exercise 3.76. Prove or disprove that the sum of any two primes is also prime.
Proof

64 Chapter 3
Definition 3.77. A proof by cases breaks up a statement into multiple cases and proves each
one separately.
3.24 and 3.66 ), but it We have already seen several examples of proof by cases (e.g. Examples
never hurts to see another example.
2 Example 3.78. Prove that if x 6 = 0 is a real number, then x > 0.
Proof: If x 6 = 0, then either x > 0 or x < 0.
2 If x > 0 (case 1), then we can multiply both sides of x > 0 by x , giving x > 0.
2 2 If x < 0 (case 2), then we can write y=-x, where y > 0.  Then x = ( − y ) =
2 2 2 2 ( − 1) y = y > 0 by case 1 (since y > 0). Thus x > 0. In either case, we have
2 shown that x > 0. 
⋆ Fill in the details 3.79. Let s be a positive integer. Prove that the closed interval [ s , 2 s ]
contains a power of 2.
Proof: If s is a power of 2 then
If s is not a power of 2, then it is strictly between two powers of 2. That is,
r − 1 r 2 < s < 2 for some integer r . Then


If and Only If Proofs 65
3.6  If and Only If Proofs
Sometimes we will run into “if and only if” (abbreviated iff ) statements. That is, statements of the
form p if and only if q . This is equivalent to the statement “ p implies q and q implies p .” Thus,
to prove that an iff statement is true, you need to prove a state ment and its converse . “ p implies
q ” is sometimes called the forward direction and the converse is sometimes called the backwards
direction . Sometimes the converse statement is proven by contraposition , so that instead of proving
q implies p , ¬ p implies ¬ q is proven.
⋆ Question 3.80. Why is there a choice between proving q implies p and proving ¬ p implies
¬ q when proving the backwards direction?
Answer
Example 3.81. Prove that x is even if and only if x + 10 is even.
Proof: If x is even, then x = 2 k for some integer k . Then x + 10 = 2 k + 10 =
2( k + 5). Since k + 5 is an integer, then x + 10 is even. Conversely, if x + 10 is even,
then x + 10 = 2 k for some integer k . Then x = ( x + 10) − 10 = 2 k − 10 = 2( k − 5).
Since k − 5 is an integer, then x is even. Therefore x is even iff x + 10 is even. 
As we have mentioned before, the examples in this section are quite trivial and may seem
ridiculous–since they are so obvious, why are we bothering t o prove them? The point is to use the
proof techniques we are learning. We will use the techniques on more complicated problems later.
For now we want the focus to be on proper use of the techniques. That is more easily accomplished
if you don’t have to think too hard about the details of the pro of.
⋆ Exercise 3.82. Prove that x is odd iff x + 20 is odd using direct proofs for both directions

66 Chapter 3
⋆ Exercise 3.83. Prove that x is odd iff x + 20 is odd using using a direct proof for the
forward direction and a proof by contraposition for the back ward direction.
⋆ Fill in the details 3.84. The two most common ways to prove p iff q are
1. Prove that and , or
and . 2. Prove that
⋆ Evaluate 3.85. Use the definition of odd to prove that x is odd if and only if x − 4 is odd.
Proof   1: Assume   x   is   odd.    Then   x  =  2k  +  1   for   some   integer   k.    Then   x − 4  =
2k + 1 − 4  =  2k − 3,  which  is  odd.   Now  assume  that  x − 4  is  odd.   Since  (2k + 1) − 4
is   odd,  then   x  =  2k + 1  is   clearly   odd.
Evaluation
Proof   2: Assume  x  is  odd.   Then  x  =  2k + 1,  so  x − 4  =  (2k + 1) − 4  =  2(k − 2) + 1,
which   is    odd   since   k − 2   is    an   integer. Now    assume   x − 4   is    even. Then
x − 4  =  2k   for   some   integer   k. Then   x  =  2k  +  4  =  2(k  +  2),   which   is   even
since   k + 2  is   an  integer.
Evaluation

Common Errors in Proofs 67
3.7  Common Errors in Proofs
If you arrive at the right conclusion, does that mean your pro of is correct? Some students seem to
think so, but this is absolutely false. Let’s consider the fo llowing example.
16 1
Example 3.86. Is the following proof that = correct? Why or why not?
64 4
Proof: This  is  true  because  if  I  cancel  the  6  on  the  top  and  the  bottom,
1 1 6 16 ✓ ✓
= = .  I   get
64 4 64 ✓ ✓
Evaluation: You probably know that you can’t cancel arbitrary digits in a fraction,
so this is not a valid proof. In addition, consider this: If th is proof is correct, then
1 6 16 1 ✁
= = 1, which is clearly false. it could be used to prove that =
61 1 61 ✁
Note: The point of the previous example is this: Don’t confuse the fa ct that what you are trying
to prove is true with whether or not your proof actually proves that it is true. An incorrect
proof of a correct statement is no proof at all.
One rookie mistake that I see often is proof by example , where the writer attempts to prove
something in general by proving it for one particular case an d assuming it must therefore work for
all of the other cases.
⋆ Question 3.87. What is wrong with this ‘proof’ that the sum of two even intege rs is even?
Proof: Let  x  and  y  be  even  integers.   Assume  x  =  4  and  y  =  6,  which  are
both   even.    Then   x  +  y  =  10  =  2 ∗ 5,   which   is   even   since   5   is   an   integer.
Thus,   the  sum   of   two  even  integers   is   even. 
Answer
Just because a proof seems work out, it does not mean that it is a proof of the correct statement.
3.87 is a correct proof of the fact that the sum of 4 and 6 is For instance, the proof in Question
even. But it is certainly not a proof that the sum of any two even numbers is even.
Let’s see an example of a supposed proof of something that is n ot even true. Hopefully I do not
need to convince you that the proof cannot be valid (since the statement is false).
Example 3.88. What is wrong with this ‘proof’ that one more than an even numb er is divisible
by 3?
Proof: Notice  that  14 + 1  =  15  =  3 ∗ 5  which  is  clearly  divisible   by  3.   Since
14  =  2 ∗ 7   is   even,  we  just   showed   that  one  more  than  an  even  number
is   divisible   by   3. 
Evaluation: This only shows that one more than 14 is divisible by 3. Notice that

68 Chapter 3
10 is even, but 10+1 = 11 is not divisible by 3, so the statement that is supposedly
being proven here is clearly not true!
Hopefully this example helps you see the problem with proof by example .  If the technique
worked, then the proof in the previous example is a valid proo f of the false statement that one
more than an even number is divisible by 3. But since that stat ement is false, it can’t have been a
valid proof. Indeed, as we already mentioned, the proof does show that the statement is true for
the given even number (in this case, 14), but that does not imp ly anything about the validity of
the statement for any other even numbers.
If you want to prove something for a general collection of num bers (e.g. even number, integers,
etc.), then your proof has to be general enough to include all possible values. For instance, if you
want to prove something about odd numbers, then you let x = 2 k + 1 where k is an integer. Notice
that no matter which odd integer you want to consider, you can pick k to obtain that value. Thus,
if you prove something about the value x = 2 k + 1, then you have proven it for all odd values of
x . However, if you show it is true for x = 7 (for instance), you have only shown that it is true for
x = 7.
Another common mistake when writing proofs is to make one or m ore invalid assumptions
without realizing it. This is another case where you end up pr oving a different statement (usually
a more specific statement) than the one you set out to prove. Th e problem is that when you make
this sort of mistake, the proof can sometimes seems to “work” because you get the conclusion you
want. Thus, your proof might actually be a valid proof, but it is of the wrong statement. Thus, it
isn’t always obvious that you even made a mistake.
The next few examples should illustrate what can go wrong if y ou aren’t careful.
⋆ Question 3.89. What is wrong with this ‘proof’ that the sum of two even intege rs is even?
Proof: Let   x   and   y   be   even   integers. Then   x  =  2a   for   some   integer
a   and   y  =  2a   for   some   integer   a. So   x  +  y  =  2a  +  2a  =  2(a  +  a). Since
a  +  a   is   an   integer,   2(a  + a)   is   even,   so   the   sum   of   two   even   integers
is   even. 
Answer
Since the statement in the previous example is true, it can be difficult to appreciate why the
proof is wrong. The proof seems to prove the statement but as y ou saw in the solution, it actually
doesn’t. It proves a more specific statement (In this case, it is a proof of the fact that the sum of
an even number with itself is even when it was supposed to be a p roof of the fact that the sum of
any two even numbers is even.).
If it seems like we are being too nit-picky, consider the next example which gives a supposed
proof that the sum of two even numbers is divisible by 4 (hopef ully you can quickly convince
yourself that this is not a true statement).

Common Errors in Proofs 69
⋆ Question 3.90. What is wrong with the following ‘proof’ that the sum of two ev en integers
is divisible by 4?
Proof: Let   x   and   y   be   two   even   integers. Then   x   =   2a   for   some
integer  a  and  y  =  2a  for  some  integer  a.   So  x + y  =  2a + 2a  =  4a.   Since
a  is  an  integer,  4a  is  divisible  by  4,  so  the  sum  of  two  even  integers  i s
divisible   by   4. 
Answer
Another common mistake students make when trying to prove an identity/equation is to start
with what they want to prove and work both sides of it until the y demonstrate that they are equal.
I want to stress that this is an invalid proof technique .  Again, if this seems like I am making
something out of nothing, consider this example:
⋆ Question 3.91. Consider the following supposed proof that − 1 = 1.
Proof:
− 1 = 1
2 2 ( − 1) = 1
1 = 1
Therefore − 1  =  1. 
How do you know that this proof is incorrect?  (Think about the obvious reason, not any
technical reason.)
Answer
Notice that each step of algebra in the previous proof is corr ect. For instance, if a = b , then
2 2 2 2 a = b is correct. And ( − 1) and 1 are both equal to 1. So the majority of the proof contains
proper techniques. It contains just one problem: It starts b y assuming something that isn’t true.
Unfortunately, one error is all it takes for a proof to be inco rrect.
Note: When writing proofs, never assume something that you don’t already know to be true!
In particular, if you are trying to prove an equality, never st art with the equality and work both
sides until you get the same thing. As demonstrated in the pre vious example, this is not a valid
proof technique.

70 Chapter 3
⋆ Question 3.92. When you are given an equation to prove, should you prove it by writing
it down and working both sides until you get them both to be the same? Why or why not?
Answer
Let’s be clear about this issue. If you known an equation is co rrect, you can work both sides
of it until you get to some desired conclusion. However, if yo u have an equation and you do not
know whether or not it is correct, you cannot start your proof by considering that equation. As
Example 3.91 demonstrated, if an equation is not correct , sometimes you can work both sides until
they are the same, which gives the illusion that you have prov en that it is correct, which is clearly
not possible. Hopefully this makes it clear to you that begin ning a proof with an unknown equation
(e.g. the equation you are trying to prove) and using it in you r proof is not valid.
⋆ Question 3.93. You are given an equation. You work both sides of it until they are the
same. Should you now be convinced that the equation is correc t? Why or why not?
Answer
Note: If you already know that an equation is true, then working both sides of it (for some
purpose other than demonstrating it is true) is a valid technique. However, it is more common
to start with a known equation and work just one side until it i s what we want.
There are plenty of other common errors in proofs. We will see more examples of them through-
out the remainder of the book (although we will focus more on c orrect proof techniques!), especially
in the Evaluate examples. I want to say that you will likely see other example s of errors in proofs
as you write your own proofs, but that would be mean. Probably accurate, but still mean.

More Practice 71
3.8  More Practice
Now you will have a chance to practice what you have learned th roughout this chapter with some
more exercises.  Now that they aren’t in a particular section , you will have to figure out what
technique to use.
⋆ Exercise 3.94. Let p < q be two consecutive odd primes (two primes with no other primes
between them). Prove that p + q is a composite number. Further, prove that it has at least
three, not necessarily distinct, prime factors. (Hint: thi nk about the average of p and q .)
Proof:
y ⋆ Evaluate 3.95. Prove or disprove that if x and y are rational, then x is rational.
Proof   1: Because  x  and  y  are  both  rational,  assume  x  =  a / b  where  a  and  b  are
integers  and  b 6 =  0.   We  can  assume  that  a  and  b  have  no  factors  in  common
(since  if  they   did  we  could  cancel  them   and  use  the   resulting  numbers as  our
y a y y
new   a  and  b).   Then   x = ,   so   x is   rational. y b
Evaluation
y Proof   2: Notice    that    x is    just    x    multiplied by    itself y    times. A    rational
y number   multiplied   by   a  rational  number   is   rational,   so  x is   rational.
Evaluation
Since none of the proofs in the previous example were correct , you need to prove it.

72 Chapter 3
y ⋆ Exercise 3.96. Prove or disprove that if x and y are rational, then x is rational.
Proof:
⋆ Evaluate 3.97. Prove or disprove that if x is irrational, then 1 /x is irrational.
Proof   1: If    x    is    rational,    assume    it    is    an    integer. If    x    is    an    integer,    i t    is
rational.    1 / x   is   an   integer   over   an   integer,   so   it   is   rational.    Therefore   if   x
is   rational,   1 / x   is   rational,   so   by   contrapositive   reasoning,   if   x   is   irrational,
1 / x  is   irrational.
Evaluation
Proof   2: Assume    that   x   is    irrational. Then    it   cannot   be    expressed   as    an
integer   over   an  integer.   Then   clearly   1 / x   cannot   be   expressed   as   an  integer
over   an  integer.
Evaluation
p Proof   3: Assume   that   x   is   rational.   Then   x  = ,   where   p   and  q   are   integers
q
1 1 q
= ,   so   it   is   rational. Since   we   proved   the and   q 6 =   0. But   then = p
x p q
contrapositive,   the   statement  is   true.
Evaluation

More Practice 73
Proof   4: We    will    prove    the    contrapositive. Assume    that    1 / x    is rational.
Since  it  is  rational,  1 / x  =  a / b  for  some  integers  a  and  b,  with  b 6 =  0.   Solving
for  x  we  get   x  =  b / a,   so  x  is   rational.
Evaluation
Proof   5: I   will   prove   the   contrapositive   statement: If   1 / x   is   rational,   then
1 a x   is   rational. Assume   1 / x   is   rational. Then = for   some   integers   a   and
x b
b 6 =  0.   We   know   that   1 / x 6 =  0   (since   otherwise   x · 0  =  1,   which   is   impossible),
a =  1. so  a 6 =  0.   Multiplying   both  sides  of  the  previous  equation  by  x  we  get  x
b
b Now   if   we   multiply   both   sides   by (which   we   can   do   since   a 6 =  0),   we   get
a
b .   Since   a  and  b  are  integers   with   a 6 =  0,  x  is   rational. x  =
a
Evaluation
p ⋆ Evaluate 3.98. Mersenne primes are primes that are of the form 2 − 1, where p is prime.
Are all numbers of this form prime? Give a proof/counterexam ple.
p Proof   1: Restate   the   problem   as   if   2 − 1   is   prime   then   p   is   prime.    Assume   p
p st is   not   prime   so   p  =  st,   where   s   and   t   are   integers. Thus   2 − 1  =  2 − 1  =
s st − s st − 2s s (2 − 1)(2 +  2 + ··· +  2 + 1).    Because   neither   of   these   factors   is   1   or
p 2 − 1
p → 2 − 1  is   not  prime   (contradiction)
→ p  is   prime
p → All   numbers  of   the   form  2 − 1  (with  p   a  prime)   are  prime.
Evaluation
p p Proof   2: Numbers   of   the   form   2 only   have   2   as   a   factor. Since   2 − 1   is
clearly   odd,   it   does   not   have   2   as   a   factor.   Therefore   it   must   not   have   any
factors.   So  it   is   prime.
Evaluation

74 Chapter 3
p ⋆ Exercise 3.99. Let p be prime. Prove that not all numbers of the form 2 − 1 are prime.
Proof:

Reading Comprehension Questions 75
3.9  Reading Comprehension Questions
From Section 3.1
Question 3.1. Because it was (perhaps incorrectly) assumed that you have h eard the term ⋆
proof before, it was never formally defined in the chapter. Let’s ma ke sure you don’t go any further
without having a good definition. So, what is a proof ? Feel free to look up the definition (online or
in a dictionary) if you need to.
⋆ Question 3.2. Let’s say someone correctly proves statement A . Does that mean A is a true
statement, that you are just pretty sure that it is true, or th at it may or may not be true based on
whether or not you understand the argument being made in the p roof? Explain your answer.
⋆ Question 3.3. True or false: Every even number is not odd. Explain your answ er.
⋆ Question 3.4. If b is divisible by a , is it always the case that a is divisible by b ? Explain using
an example.
⋆ Question 3.5. Can a number be both composite and prime ? Explain.
⋆ Question 3.6. Which are prime ? Which of the following numbers are composite ? Which are
neither? Which are both?
1, 3, 4, 6, 38, 27, 97, 150, 173, 999983, 999985
⋆ Question 3.7. Compute 6! and 7!. Did you compute 7! the easy way or the hard wa y?
⋆ Question 3.8. For what values of n is n ! prime?
From Section 3.2
Question 3.9. If the proposition A implies B is true, does that mean the proposition B implies ⋆
A is true? Prove or give a counterexample.
⋆ Question 3.10. True or false: If the inverse of an implication is true, then t he implication is
also true. Explain your answer.
⋆ Question 3.11. True or false: If the inverse of an implication is true, then t he converse of the
implication is also true. Explain your answer.
⋆ Question 3.12. What can you say about an implication and its contrapositive ?
3.3 From Sections
⋆ Question 3.13. In your own words, explain the idea behind contradiction pro ofs.  Include
specifics like how one goes about writing a proof by contradic tion and why it is a valid proof
technique. (The goal of this question is to help you better un derstand the technique and to convince
you that it is indeed a valid technique, so put some thought in to this one!)
⋆ Question 3.14. Give all of the permutations of the set { cow, chicken, rabbit }
⋆ Question 3.15. True or false: Every integer is a rational number. Explain yo ur answer.
⋆ Question 3.16. Prove that there is no smallest positive rational number. (H int: Use contradic-
tion!)

76 Chapter 3
From Section 3.4
Question 3.17. Explain why proof by contraposition is a valid proof techniq ue. ⋆
⋆ Question 3.18. Explain the difference between a proof by contradiction and a p roof by contra-
position, particularly as it applies to proving statements of the form p → q .
⋆ Question 3.19. True or false: Every irrational number is not an integer. Exp lain your answer.
√
⋆ Question 3.20. Prove that if x > 0 is irrational, then x is irrational using
(a) proof by contradiction.
(b) proof by contraposition.
From Section 3.5
Question 3.21. True or false: Every rational number is an integer. Prove you r answer. ⋆
2 ⋆ Question 3.22. Prove that an integer n and n have the same parity (that is, they are both
even or both odd).
From Section 3.6
Question 3.23. If you want to prove that A if and only if B is true (where A and B are ⋆
statements of some sort), can you just show that A implies B ? If not, explain why that does not
work and what you would have to do instead (or in addition).
⋆ Question 3.24. You want to prove that p if and only if q is true.
(a) Is showing that p implies q and ¬ q implies ¬ p a valid technique? Explain why or why not.
(b) Is showing that ¬ q →¬ p and q → p a valid technique? Explain why or why not.
2 ⋆ Question 3.25. Prove that an integer n is even if and only if n is even.
3.7 From Sections
⋆ Question 3.26. Proof by counterexample is a valid proof technique. Proof by example is not.
Explain the difference.
⋆ Question 3.27. If I want to prove some equation, should I write down the equat ion and work
both sides until they are the same? Explain why this is or is no t a valid proof technique.
⋆ Question 3.28. What is wrong with the following proof?
Proof: Assume  a  =  b,  where  a  and  b  are  not  zero.   Multiplying  both  sides  by
2 2 2 2 2 a,  we  get  a =  ab.   Subtracting  b from  both  sides,  we  get  a − b =  ab − b ,
which   is   equivalent   to   (a − b)(a  +  b)   =   (a − b)b. Dividing   by   a − b,    we   get
(a + b)  =  b,  which   implies   2b  =  a,  but  since  a  =  b,  2b  =  b,  and  dividing   by  b ,  we
finally   conclude   that  2  =  1. 

Problems 77
3.10  Problems
Problem 3.1. Prove that a number and its square have the same parity. That i s, the square of
an even number is even and the square of an odd number is odd.
Problem 3.2. Prove that the inverse of an implication is true if and only if the converse of the
implication is true.
Problem 3.3. Let a and b be integers. Consider the problem of proving that if at least one of a or
3.50 ? Explain, using b is even, then ab is even. Is this equivalent to the statement from Evaluate
the appropriate terminology from this chapter.
Problem 3.4. Let a and b be integers. Consider the statement “ If ab is even, then at least one of a
or b is even. ” Rephrase this statement using the word odd instead of even (but you cannot use the
phrase not odd ). Using terminology from this chapter, how did you come up wi th the alternative
phrasing?
Problem 3.5. Prove or disprove that there are 100 consecutive positive in tegers that are not
2 perfect squares. (Recall: a number is a perfect square if it c an be written as a for some integer a .)
4 4 Problem 3.6. Consider the equation n + m = 625.
(a) Are there any integers n and m that satisfy this equation? Prove it.
(b) Are there any positive integers n and m that satisfy this equation? Prove it.
3 3 3 Problem 3.7. Consider the equation a + b = c over the integers (that is, a , b , and c have to all
be integers).
(a) Prove that the equations has infinitely many solutions.
(b) If we restrict a , b , and c to the positive integers, are there infinitely many solution s? Are there
any? Justify your answer. (Hint: Do a web search for “Fermat’ s Last Theorem.”)
Problem 3.8. Let n be an integer.
(a) Prove that if n is odd, then 3 n + 4 is odd.
(b) Is it possible to prove that n is odd iff 3 n + 4 is odd? If so, prove it. If not, explain why not
(i.e. give a counter example).
(c) If we don’t assume n has to be an integer, is it possible to prove that n is odd iff 3 n + 4 is odd?
If so, prove it. If not, explain why not (i.e. give a counter ex ample).
Problem 3.9. Prove that if n is an integer and 5 n + 4 is even, then n is even using a
(a) direct proof
(b) proof by contraposition
(c) proof by contradiction
2 Problem 3.10. Prove that a is even if and only if a is even.
2 Problem 3.11. Prove that n + 2 n + 1 is even if and only if n is odd.

78 Chapter 3
Problem 3.12. Let n be an integer.
(a) Prove that if n is odd, then 4 n + 3 is odd.
(b) Is it possible to prove that n is odd iff 4 n + 3 is odd? If so, prove it. If not, explain why not
(i.e. give a counter example).
Problem 3.13. Prove that ab is odd iff a and b are both odd.
Problem 3.14. Prove or disprove each of the following.
(a) Let k be an odd integer. Then a is even if and only if ka is even.
(b) Let k be an even integer. Then a is even if and only if ka is even.
(c) Let k be an integer. Then a is even if and only if ka is even.
Problem 3.15. Let n be an odd integer. For what values of k do n and nk have the same parity?
Prove your claim.
Problem 3.16. Let n be an even integer. For what values of k do n and nk have the same parity?
Prove your claim.
Problem 3.17. Prove or disprove: Every positive integer can be written as t he sum of the squares
of two integers.
Problem 3.18. Prove that the product of two rational numbers is rational.
Problem 3.19. Prove that the product of a non-zero rational number and an ir rational number
is irrational.
Problem 3.20. Prove or disprove that c is irrational if and only if c + 1 is irrational.
2 Problem 3.21. Prove or disprove that c is rational if and only if c is rational.
2 Problem 3.22. Prove or disprove that n − 1 is composite whenever n is a positive integer greater
than or equal to 1.
2 Problem 3.23. Prove or disprove that n − 1 is composite whenever n is a positive integer greater
than or equal to 3.
Problem 3.24. Compute 7!.
Problem 3.25. Compute 8! / 6!.
Problem 3.26. List the permutations of the set { a , b , c , d } .
2 Problem 3.27. Prove or disprove that P = N P .
2 A successful solution to this will earn you an A in the course. You are free to use Google or whatever other
resources you want for this problem, but you must fully under stand the solution you submit.

Chapter 4: Sets, Functions, and Relations
4.1  Sets
4.1.1  Definitions
Definition 4.1. Sets
• A set is an unordered collection of objects.
• The objects in the set are called the elements of the set.
• If a belongs to the set A , then we write a ∈ A , read “ a is an element of A .”
• If a does not belong to the set A , we write a 6∈ A , read “ a is not an element of A .”
• Generally speaking, repeated elements in a set are ignored.
Note: The symbol ∈ should be read as is an element of , not exists in .
Example 4.2. The sets A = { 1, 2, 3 } , B = { 3, 2, 1 } , and C = { 1, 1, 1, 2, 2, 3 } actually represent
the same set since repeated values are ignored and the order e lements are listed does not matter.
Notice that 1 ∈ A and 3 ∈ A , but 4 6∈ A .
Let D = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } be the set of decimal digits. Then 4 ∈ D but 11 6∈ D .
Notice that the elements in a set are listed between curly bra ces. Thus, { 1, 2, 3 } is a set (where
order does not matter and duplicates are ignored), but [1, 2, 3] is a list (where order does matter
and duplicates are allowed). Also, 1, 2, 3 is just a list of thr ee numbers whereas { 1, 2, 3 } is the set
containing the numbers 1, 2, and 3.
Definition 4.3. Cardinality
• The number of elements in a set A , also known as the the cardinality of A , will be
denoted by | A | .
• If | A | is finite, we call A a finite set .
• If the set A has infinitely many elements, we write | A | = ∞ and we refer to A as an
infinite set .
Example 4.4. If A , B , C , and D are the sets from Example 4.2 , then | A | = 3, | B | = 3,
| C | = 3, and | D | = 10.
79

80 Chapter 4
⋆ Exercise 4.5. Give the set of prime numbers less than 10. What is its cardina lity?
Answer
Since we cannot list every element of an infinite set, we need a way of expressing the set so that
it is clear what elements it contains. If the elements of the s et follow some pattern, it is common
to list the first several elements and then conclude with . . . , indicating that the pattern continues.
There is no “right” number of elements to list when using this notation, but there needs to be
enough so that the pattern is evident. Often 3-5 elements suffi ces.
+ Example 4.6. The set of positive integers can be expressed as Z = { 1, 2, 3, . . . } . Notice that
+ | Z | = ∞ .
The set of positive integers that are a multiple of 5 can be exp ressed as { 5, 10, 15, 20, . . . } .
Hopefully it is clear that |{ 5, 10, 15, 20, . . . }| = ∞ .
The set of integer multiples of 5 can be expressed as { . . . , − 15, − 10, − 5, 0, 5, 10, 15, . . . } .
Hopefully it is clear that this is also an infinite set.
Definition 4.7. We say two sets are equal if they contain the same elements. That is ∀ x ( x ∈
A ↔ x ∈ B ) . If A and B are equal sets, we write A = B .
Note: We will normally denote sets by capital letters, like A , B , S , N , etc. Elements will be
denoted by lowercase letters, like a , b , r , etc.
⋆ Exercise 4.8. Let A = { 1, 2, 3, 4, 5, 6 } , B = { 1, 2, 3, 4, 5, 4, 3, 2, 1 } , C = { 6, 3, 4, 5, 1, 3, 2 } .
Then | A | = , | B | = , and | C | = .
Which of A , B , and C represent the same sets?
Definition 4.9. The following notation is pretty standard, and we will follow it in this book.
N = { 0, 1, 2, 3, . . . } the natural numbers .
Z = { . . . − 2, − 1, 0, 1, 2, . . . } the integers .
+ Z = { 1, 2, 3, . . . } the positive integers .
− Z = {− 1, − 2, − 3, . . . } the negative integers .
Q the rational numbers .
R the real numbers .
C the complex numbers .
∅ = {} the empty set or null set .

Sets 81
Note: There is no universal agreement of the definition of N . Although here it is defined as
+ { 0, 1, 2, 3, . . . } , it is sometimes defined as N = Z . The only difference is whether or not 0 is
included. I prefer the definition given here because then we h ave a notation for the positive
+ integers ( Z ) as well as the non-negative integers ( N ).
Example 4.10. Notice that | N | = | Z | = | R | = ∞ . But this may be a bit misleading. Do all
of these sets have the same number of elements? Believe it or n ot, it turns out that N and Z
do, but that R has many more elements than both of these. If it seems strange to talk about
whether or not two infinite sets have the same number of elemen ts, don’t worry too much about
it. We probably won’t bring it up again.
+ ⋆ Exercise 4.11. (a) | C | = , (b) | Z | = , (c) | ∅ | =
Another other common notation that is used express sets is ca lled set builder notation . It is
easier to understand through examples than by giving a forma l definition.
2 Example 4.12. Let S be the set of the squares of integers. We can express this as S = { n | n ∈
2 Z } or S = { n : n ∈ Z } . We call this set builder notation . We read the : or | as “such that.”
2 Thus, S is the set containing numbers of the form n such that n is an integer.
Example 4.13. Consider the set of integers that are one less than a positive power of 2. This
1 2 8 set contains elements such as 1 = 2 − 1, 3 = 2 − 1, and 255 = 2 − 1. We can express this set
n + in set builder notation as { 2 − 1 | n ∈ Z } .
1 2 3 We could also use the notation { 2 − 1, 2 − 1, 2 − 1, . . . } , since the pattern is evident.
However, it would be unwise to write it as { 1, 3, 7, 15, . . . } since it may or may not be evident
what the pattern is when expressed in this way.
⋆ Exercise 4.14. Use two different notations to express the set of even integers .
Answer
Example 4.15. Let T be the set of all integers that can be expressed as the sum of th e square
2 2 2 2 of two positive integers. This set contains elements such as 2 = 1 + 1 , 5 = 1 + 2 , and
2 2 2 2 + 25 = 3 + 4 . Then T = { n + m | n , m ∈ Z } .
In this case, expressing the set as something like { 2, 5, 8, 9, . . . } does not make sense at all
because there is no way of discerning a pattern.
Example 4.16. Use set builder notation to express C , the set of complex numbers.
Solution: C = { a + bi : a , b ∈ R } .

82 Chapter 4
⋆ Exercise 4.17. Use set builder notation to express Q , the set of all rational numbers.
Answer
Definition 4.18. Subsets
• If every element in A is also in B , we say that A is a subset of B and we write this as
A ⊆ B .
• If A ⊆ B and there is some x ∈ B such that x 6∈ A , then we say A is a proper subset
of B , denoting it by A ⊂ B .
• If there is some x ∈ A such that x 6∈ B , then A is not a subset of B , which we write as
A 6⊆ B .
Note: Some authors use ⊂ to mean the same thing as ⊆ . You will need to consider the context
in order to interpret it correctly.
Example 4.19. Let S = { 1, 2, . . . , 20 } , that is, the set of integers between 1 and 20, inclusive.
Let E = { 2, 4, 6, . . . , 20 } , the set of all even integers between 2 and 20, inclusive. Not ice that
E ⊆ S . Let P = { 2, 3, 5, 7, 11, 13, 17, 19 } , the set of primes less than 20. Then P ⊆ S , but
P 6⊆ E and E 6⊆ P .
2 ⋆ Exercise 4.20. Let S = { n | n ∈ Z } and A = { 1, 4, 9, 16 } . Answer each of the following,
including a brief justification.
(a) Is A ⊆ S ?
(b) Is A ⊂ S ?
(c) Is S ⊆ S ?
(d) Is S ⊂ S ?
(e) Is S ⊂ A ?

Sets 83
⋆ Exercise 4.21. Let A be the set of integers divisible by 6, B be the set of integers divisible
by 2, and C be the set of integers divisible by 3. Answer each of the follo wing, giving a brief
justification.
(a) Is A ⊆ B ?
(b) Is A ⊆ C ?
(c) Is B ⊆ A ?
(d) Is B ⊆ C ?
(e) Is C ⊆ A ?
(f) Is C ⊆ B ?
Example 4.22. The set
S = { Roxan, Jacquelin, Sean, Fatimah, Wakeelah, Ashley, Ruben, Leslie, Madeline }
is the set of students in a particular course. This set can be s plit into two subsets: the set
F = { Roxan, Jacquelin, Fatimah, Wakeelah, Ashley, Madeline } of females in the class, and the
set M = { Sean, Ruben, Leslie } of males in the class. Thus we have F ⊆ S and M ⊆ S . Notice
that it is not true that F ⊆ M or that M ⊆ F . Put another way, F 6⊆ M and M 6⊆ F
Example 4.23. Find all the subsets of { a , b , c } .
Solution: They are ∅ , { a } , { b } , { c } , { a , b } , { b , c } , { a , c } , and { a , b , c } .
3 Notice that there are 8 subsets. Also notice that 8 = 2 . As we will see shortly, that is not a
coincidence.
Notice that we wrote ∅ and not { ∅ } in the previous example. It turns out that ∅ 6 = { ∅ } . ∅ is
the empty set–that is, the set that has no elements. { ∅ } is the set containing the empty set. Thus,
{ ∅ } is a set containing the single element ∅ . You can use either ∅ or {} to denote the empty set,
but not { ∅ } .

84 Chapter 4
⋆ Exercise 4.24. Find all the subsets of { a , b , c , d } .
Definition 4.25. The power set of a set is the set of all subsets of a set. The power set of a
set A is denoted by P ( A ) .
Example 4.26. If A = { a , b , c } , example 4.23 implies that P ( A ) = { ∅ , { a } , { b } , { c } , { a , b } ,
{ b , c } , { a , c } , { a , b , c }} . Notice that the solution is a set, the elements of which are a lso sets.
An incorrect answer would be { ∅ , a , b , c , { a , b } , { b , c } , { a , c } , { a , b , c }} .  This is incorrect
because a is not the same thing as { a } (the set containing a ). { a }∈ P ( A ), but a 6∈ P ( A ). This
is a subtle but important distinction.
⋆ Exercise 4.27. Find P ( { a , b , c , d } ).
We will prove the following theorem in the next section after we have developed the appropriate
notation to do so.
n Theorem 4.28. Let A be a set with n elements. Then | P ( A ) | = 2 .

Sets 85
⋆ Exercise 4.29. Let A be a set with 4 elements.
. (a) | P ( A ) | =
. (b) | P ( P ( A )) | =
(c) | P ( P ( P ( A ))) | = .
⋆ Exercise 4.30. If one element is added to a finite set A , how much larger is the power set of
A after the element is added (relative to the size of the power s et before it is added)? Explain
your answer.
Answer

86 Chapter 4
4.1.2  Set Operations
We can obtain new sets by performing operations on other sets . In this section we discuss the
common set operations. Venn diagrams are often used as a pictorial representation of the relation -
ships between sets. We provide Venn diagrams to help visuali ze the set operations. In our Venn
diagrams, the region(s) in the darker color represent the el ements of the set of interest.
Definition 4.31.
The union of two sets A and B is the set containing ele-
ments from either A or B . More formally,
A ∪ B A B
A ∪ B = { x : x ∈ A or x ∈ B } .
Notice that in this case the or is an inclusive or . That
is, x can be in A , or it can be in B , or it can be in both.
Example 4.32. Let A = { 1, 2, 3, 4, 5, 6 } , and B = { 1, 3, 5, 7 } . Then A ∪ B = { 1, 2, 3, 4, 5, 6, 7 } .
⋆ Exercise 4.33. Let A be the set of even integers and B be the set of odd integers. Then
A ∪ B =
Definition 4.34.
The intersection of two sets A and B is the set containing
elements that are in both A and B . More formally, A ∩ B
A B
A ∩ B = { x : x ∈ A and x ∈ B } .
Example 4.35. Let A = { 1, 2, 3, 4, 5, 6 } , and B = { 1, 3, 5, 7, 9 } . Then A ∩ B = { 1, 3, 5 } .
⋆ Exercise 4.36. Let A be the set of even integers and B be the set of odd integers. Then
A ∩ B =

Sets 87
Definition 4.37.
The difference (or set-difference )  of sets A and B is
the set containing elements from A that are not in B . More
formally,
A \ B A B
A \ B = { x : x ∈ A and x 6∈ B } .
The set difference of A and B is sometimes denoted by
A − B .
Example 4.38. Let A = { 1, 2, 3, 4, 5, 6 } , and B = { 1, 3, 5, 7, 9 } . Then A \ B = { 2, 4, 6 } and
B \ A = { 7, 9 } .
⋆ Exercise 4.39. Let A be the set of even integers and B be the set of odd integers. Then
A \ B = and B \ A = .
4.28 . We can now prove Theorem
n Example 4.40. Let A be a set with n elements. Then | P ( A ) | = 2 .
a and the idea from the solution to Exercise 4.24 . Clearly Proof: We use induction
1 if | A | = 1, A has 2 = 2 subsets: ∅ and A itself.
n − 1 Assume every set with n − 1 elements has 2 subsets. Let A be a set with n
elements. Choose some x ∈ A . Every subset of A either contains x or it doesn’t.
Those that do not contain x are subsets of A \{ x } . Since A \{ x } has n − 1 elements,
n − 1 the induction hypothesis implies that it has 2 subsets. Every subset that does
contain x corresponds to one of the subsets of A \{ x } with the element x added.
That is, for each subset S ⊆ A \{ x } , S ∪{ x } is a subset of A containing x . Clearly
n − 1 there are 2 such new subsets. Since this accounts for all subsets of A , A has
n − 1 n − 1 n 2 + 2 = 2 subsets. 
a We will cover induction more fully and formally later. But si nce this use of induction is pretty intuitive,
4.24 , it serves as a useful foreshadowing of things to come. especially in light of Example
Definition 4.41.
Let A ⊆ U . The complement of A with respect to U is
just the set difference U \ A . More formally, U
A
A
A = { x ∈ U : x 6∈ A } = U \ A .
In words, A is the set of everything not in A . Other com-
c ′ mon notations for set complement include A and A .

88 Chapter 4
Note: Often the set U , which is called the universe or universal set , is implied and we
just use A to denote the complement. We usually follow this convention here. Further, when
talking about several sets, we will usually assume they have the same universal set.
Example 4.42. Let U = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } be the universal set of decimal digits and
A = { 1, 3, 5, 7, 9 } is the set of odd digits. A = { 0, 2, 4, 6, 8 } ⊂ U be the set of even digits. Then
⋆ Exercise 4.43. Let A be the set of even integers and B be the set of odd integers, and let
the universal set be U = Z . Then A = and B = .
It should not be too difficult to convince yourself that the fol lowing theorem is true.
Theorem 4.44. Let A be a subset of some universal set U . Then
A ∩ A = ∅ , and
A ∪ A = U .
The various intersecting regions for two and three sets can b e seen in Figures 4.1 and 4.2 .
( A ∪ B ∪ C ) C
A ∩ B ∩ C
( A ∪ B )
A ∩ B ∩ C A ∩ B ∩ C
A ∩ B A ∩ B
A ∩ B ∩ C
A ∩ B
B ∩ C A ∩ B ∩ C A ∩
A ∩ B ∩ C
A B
A B
Figure 4.1: Venn diagram for two sets.
Figure 4.2: Venn diagram for three sets.
Definition 4.45. Two sets A and B are disjoint or mutually exclusive if A ∩ B = ∅ . That
is, they have no elements in common.
Example 4.46. Let A be the set of prime numbers, B be the set of perfect squares, and C
be the set of even numbers. Then A and B are clearly disjoint since if a number is a perfect
square, it cannot possibly be prime (although 0 and 1 are not p rime for different reasons than
the rest of the elements of B ). On the other hand, A and C are not disjoint since they both
contain 2, and B and C are not disjoint because they both contain 4.

Sets 89
⋆ Exercise 4.47. Let A be the set of even integers and B be the set of odd integers. Are A
and B disjoint? Explain.
Answer
Set identities can be used to show that two sets are the same. Table 4.1 gives some of the most
common set identities. In these identities, U is the universal set. We won’t provide proofs for most
of these, but we will present a few examples and a technique th at will allow you to verify that they
are correct in Section 4.1.3 .
N ame Identity
commutativity A ∪ B = B ∪ A
A ∩ B = B ∩ A
associativity A ∪ ( B ∪ C ) = ( A ∪ B ) ∪ C
A ∩ ( B ∩ C ) = ( A ∩ B ) ∩ C
distributive A ∩ ( B ∪ C ) = ( A ∩ B ) ∪ ( A ∩ C )
A ∪ ( B ∩ C ) = ( A ∪ B ) ∩ ( A ∪ C )
identity A ∪ ∅ = A
A ∩ U = A
complement A ∪ A = U
A ∩ A = ∅
domination A ∪ U = U
A ∩ ∅ = ∅
idempotent A ∪ A = A
A ∩ A = A
complementation ( A ) = A
′ DeM organ s A ∪ B = A ∩ B
A ∩ B = A ∪ B
absorption A ∪ ( A ∩ B ) = A
A ∩ ( A ∪ B ) = A
Table 4.1: Set Identities
These identities may look somewhat familiar.  They are essen tially the same as the logical
equivalences presented in Table 2.3 . In fact, if we equate T to U , F to ∅ , ∨ to ∪ , ∧ to ∩ , and ¬
to ̄(complement), the laws are identical. This is because lo gic operations and sets are both what
we call Boolean algebras . We won’t go into detail about this connection, but in case yo u run into
the concept in the future, you heard it here first!
Sometimes you need to find the number of elements in the union o f several sets. This is easy
if the sets do not intersect. If they do intersect, more care i s needed to make sure no elements are
missed or counted more than once. In the following examples w e will use Venn diagrams to help us
do this correctly. Later, we will learn about a more powerful tool to do this— inclusion-exclusion .

90 Chapter 4
Example 4.48. Of 40 people, 28 smoke and 16 chew tobacco. It is also known tha t 10 both
smoke and chew. How many among the 40 neither smoke nor chew?
Solution: We fill up the Venn diagram below as follows.  Since | Smoke ∩
Chew | = 10, we put a 10 in the intersection.  Then we put 28 − 10 = 18 in
the part that Smoke does not overlap Chew and 16 − 10 = 6 in the part of
Chew that does not overlap Smoke .  We have accounted for 10 + 18 + 6 = 34
people that are in at least one of the sets.  The remaining 40 − 34 = 6 people
outside these sets don’t smoke or chew (and probably don’t da te girls who do).
6
18 10 6
Smoke Chew
We truly hope that these numbers are not representative of th e number of people
who smoke and/or chew in real life. It’s bad for you. Don’t do i t. Really.
⋆ Exercise 4.49. In a group of 30 people, 8 speak English, 12 speak Spanish and 1 0 speak
French. It is known that 5 speak English and Spanish, 7 Spanis h and French, and 5 English
and French. The number of people speaking all three language s is 3. How many people speak
at least one of these languages?
Definition 4.50. The Cartesian product of sets A and B is the set A × B = { ( a , b ) | a ∈
A ∧ b ∈ B } . In other words, it is the set of all ordered pairs of elements f rom A and B .
Example 4.51. If A = { 1, 2, 3 } and B = { a , b } , then
A × B = { (1, a ), (1, b ), (2, a ), (2, b ), (3, a ), (3, b ) } , and
B × A = { ( a , 1), ( a , 2), ( a , 3), ( b , 1), ( b , 2), ( b , 3) } .
Notice that A × B 6 = B × A . If A 6 = B , this is always the case.

Sets 91
⋆ Exercise 4.52. Let A = { 1, 2, 3, 4 } , and B = { 3 } . Compute A × B .
A × B =
2 n n − 1 Definition 4.53. If A is a set, then A = A × A , and A = A × A .
Example 4.54. If B = { a , b } then
2 B = { ( a , a ), ( a , b ), ( b , a ), ( b , b ) } , and
3 B = { ( a , a , a ), ( a , b , a ), ( b , a , a ), ( b , b , a ), ( a , a , b ), ( a , b , b ), ( b , a , b ), ( b , b , b ) }
2 3 ⋆ Exercise 4.55. Let A = { 0, 1 } . Find A and A .
2 A =
3 A =
It shouldn’t be too difficult to convince yourself of the follo wing.
Theorem 4.56. If A and B are finite sets with | A | = n and | B | = m , then | A × B | = n · m .
Example 4.57. Let A and B be finite sets with | A | = 100 and | B | = 5. Then | A × B | =
2 4 4 100 ∗ 5 = 500, | A | = 100 ∗ 100 = 10, 000, and | B | = 5 = 625.
⋆ Exercise 4.58. Let A , B , and C be sets with | A | = 10, | B | = 50, and | C | = 20. Determine
the following
(a) | A × B | =
(b) | A × C | =
3 (c) | B | =
(d) | A × B × C | =

92 Chapter 4
⋆ Evaluate 4.59. If A × B = ∅ , what can we conclude about A and B ?
Solution   1: Assume  A  and  B  are  not  empty.   We  know  the  Cartesian  product
of  A  and  B,  denoted  by  A × B,  is  the  set  of  all  ordered  pairs  (a , b),  where  a ∈ A
and   b ∈ B. Therefore,   we   can   conclude   that   our   assumption   was   incorrect
because  if  each  set  is  not  empty,  (a , b)  is  in  the  cross  product,  but  A × B  = ∅ ,
so  at  least   one   of   the  sets   must  be   empty.
Evaluation
Solution   2: Notice    that    if    A   = ∅ and    B   = ∅ ,    A × B   = ∅ . Therefore, if
A × B  = ∅ ,  then   A  = ∅ and  B  = ∅ .
Evaluation
Solution   3: We   can   conclude   that   both   A   and   B   are   empty. I’ll   prove   it   by
contradiction.   Assume  that  A × B  = ∅ ,  but  that  it  is  not  the  case  that  both
A  and   B   are   empty.   Then   neither   A   nor   B   is   empty.   But   then   there   is   some
a ∈ A   and   some   b ∈ B,   and   (a , b) ∈ A × B,   which   implies   that   A × B 6 = ∅ . This
contradicts  our   assumption.   Therefore  both   A  and  B  are  empty.
Evaluation
Solution   4: At  least   one   of   A   or   B   is   empty   by   contradiction.   Assume   that
A × B  = ∅ ,   but  that   it   is   not  the   case   that   at  least   one  of   A   or   B  is   empty.
Then   neither   A   nor   B   is   empty. Then   there   is   some   a ∈ A   and   some   b ∈ B.
But   then   (a , b) ∈ A × B,   which   implies   that   A × B 6 = ∅ . This   contradicts   our
assumption.   Therefore  at  least   one  of   A  or   B  is   empty.
Evaluation

Sets 93
4.1.3  Set Proofs
The following theorem can be used to prove set identities.
Theorem 4.60. Two sets A and B are equal if and only if A ⊆ B and B ⊆ A .
Let’s see this theorem in action.
Example 4.61. Prove that A \ B = A ∩ B .
Proof: Let x ∈ A \ B . Then by definition of difference, x ∈ A and x 6∈ B . But if
x 6∈ B , then x ∈ B by definition of complement. Since x ∈ A and x ∈ B , x ∈ A ∩ B
by definition of intersection. Since whenever x ∈ A \ B , x ∈ A ∩ B , we have shown
B . that A \ B ⊆ A ∩
Now assume that x ∈ A ∩ B . Then x ∈ A and x ∈ B by definition of intersection.
By definition of complement, x 6∈ B . But if x ∈ A and x 6∈ B , then x ∈ A \ B
by definition of difference. Since whenever x ∈ A ∩ B , x ∈ A \ B , we have that
B ⊆ A \ B . A ∩
Since we have shown that A \ B ⊆ A ∩ B and that A ∩ B ⊆ A \ B , by Theorem 4.60
A \ B = A ∩ B . 
That was the long, drawn-out version of the proof. The purpos e of all of the detail is to
make the technique clear. Here is a proof without any extrane ous details.
Proof: We will prove this by showing set containment both ways.
B .  Therefore Let x ∈ A \ B . Then x ∈ A and x 6∈ B . This implies that x ∈
B . Since A \ B implies x ∈ A ∩ B , A \ B ⊆ A ∩ B . x ∈ A ∩
Now assume that x ∈ A ∩ B . Then x ∈ A and x ∈ B . Then x 6∈ B , and therefore
x ∈ A \ B . Since x ∈ A ∩ B implies x ∈ A \ B , A ∩ B ⊆ A \ B . 
The proofs in the previous example are called set containment proofs since we showed set
4.60 tells us that if containment both ways. The technique is pretty straightfor ward: Theorem
X ⊆ Y and Y ⊆ X , then X = Y . Thus, to prove X = Y , we just need to show that X ⊆ Y and
Y ⊆ X . But how do we show that one set is a subset of another? This is e asy: To show that
X ⊆ Y , we show that every element from X is also in Y . In other words, we assume that x ∈ X
and use definitions and logic to show that x ∈ Y . Assuming we do not use any special properties
about x other than the fact that x ∈ X , then x is an arbitrary element from X , so this shows that
X ⊆ Y . Showing that Y ⊆ X uses exactly the same technique.
Note: Be careful. To prove that X = Y , you generally need to prove two things: X ⊆ Y and
Y ⊆ X . Do not forget to do both. On the other hand, if you are asked to prove that X ⊆ Y ,
you do not need to (and should not) show that Y ⊆ X .
Let’s see another example of this type of proof. This proof wi ll provide a few more details than
necessary in order to further explain the technique.
Example 4.62. Prove the first De Morgan’s Laws: Given sets A and B , ( A ∪ B ) = A ∩ B .
( A ∪ B ). Then x 6∈ A ∪ B (by definition of complement). Thus Proof: Let x ∈

94 Chapter 4
x 6∈ A and x 6∈ B (by definition of union), which is the same thing as x ∈ A
and x ∈ B (by definition of complement). But then we have that x ∈ A ∩ B (by
( A ∪ B ), definition of intersection). Notice that x was an arbitrary element from
and we showed that x ∈ A ∩ B . Therefore, every element in ( A ∪ B ) is also in
A ∩ B . In other words, ( A ∪ B ) ⊆ A ∩ B .
Now, let x ∈ A ∩ B . Then x ∈ A and x ∈ B . This means that x 6∈ A and x 6∈ B
which is the same as x 6∈ A ∪ B . But this last statement asserts that x ∈ ( A ∪ B ).
A ∩ B ⊆ ( A ∪ B ). Hence
Since we have shown that the two sets contain each other, they are equal by Theorem
4.60 . 
You have already seen a few correct ways to prove that A \ B = A ∩ B . Can you spot the
problem(s) in the following ‘proofs’ of this? These proofs u se the alternative notation of A − B for
set difference.
⋆ Evaluate 4.63. Use a set containment proof to prove that if A and B are sets, then A − B =
B . A ∩
Proof   1: Assume   x ∈{ A − B } so   x ∈ A   and   x   is   not ∈ B.   This   means   x ∈ A   and
B.   Therefore  x ∈ A ∩ B.   Thus   A − B  =  A ∩ B.
Evaluation
Proof   2: B   is   the   other   part   of   the   universal   that   does   not   contain   any
part  of  B.   A ∪ B  means  all  intersection  part  of  A  and  the  universal  that  does
not   contain   any   part   of   B.   Therefore   it   returns   all   elements   that   are   in   A
but  not  in   B  which   are  A − B.   Thus,   A − B  =  A ∩ B.
Evaluation
Proof   3: To   prove   that   A − B  =  A ∩ B,   first   let   x ∈ A − B.    By   definition   of
the   difference  of   sets,   this   means   that   x  is   an  element   of   A   that  is   not  i n
B,   or   in   other   words,   x ∈ A   and   x 6∈ B. This   is   the   same   as   x ∈ A ∩ B,   thus
proving  that   A − B ⊆ A ∩ B.
Now   let   x ∈ A ∩ B. This   means   that   x ∈ A   and   x 6∈ B,   so   it   is   in   A,   but   not
in   B,   which   is   what   we   just   proved   in   the   previous   statement,   thus proving
B. that  A − B  =  A ∩
Evaluation

Sets 95
Sometimes we can do a set containment proof in one step instea d of two. This only works if
every step of the proof is reversible. We illustrate this ide a next.
Example 4.64. Prove that A \ ( B ∪ C ) = ( A \ B ) ∩ ( A \ C ).
Proof: We have
x ∈ A \ ( B ∪ C ) ↔ x ∈ A ∧ x 6∈ ( B ∪ C )
↔ ( x ∈ A ) ∧ (( x 6∈ B ) ∧ ( x 6∈ C ))
↔ ( x ∈ A ∧ x 6∈ B ) ∧ ( x ∈ A ∧ x 6∈ C )
↔ ( x ∈ A \ B ) ∧ ( x ∈ A \ C )
↔ x ∈ ( A \ B ) ∩ ( A \ C ).

Note: The proof in the previous example works because every step is r eversible. You can only
write something like ‘ α ↔ β ’ in a proof if α → β and β → α are both true. When attempting
to shortcut proofs with this technique, make sure each step t ruly is reversible.
⋆ Fill in the details 4.65. Use a set containment proof to show that
( A ∪ B ) ∩ C = ( A ∩ C ) ∪ ( B ∩ C ).
Solution: We have,
x ∈ ( A ∪ B ) ∩ C
↔ x ∈ ( A ∪ B ) ∧ by def. of intersection
) ∧ x ∈ C by ↔ ( x ∈ A ∨
↔ ( x ∈ A ∧ x ∈ C ) ∨ by
↔ ∨ ( x ∈ B ∩ C )   by
↔ x ∈ ( A ∩ C ) ∪ ( B ∩ C ). by

96 Chapter 4
4.2  Remainders and Rounding
In this section we will introduce some mathematical notatio n that allows us to think about remain-
ders when doing division in a different, and often more conveni ent, way than you may be used to.
We will also see the floor and ceiling functions, which allow u s to round down or up, depending on
our preference.
Definition 4.66. The mod operator is defined as follows: for integers a and n such that a ≥ 0
and n > 0 , a mod n is the integral non-negative remainder when a is divided by n . Observe
that this remainder is one of the n numbers
0,  1,  2, . . . , n − 1.
When we are working with the mod operator, we say we are are per forming modular arithmetic .
Example 4.67. Here are some example computations:
6 mod 5 = 1 1961 mod 37 = 0 234 mod 100 = 34
11 mod 5 = 1 1966 mod 37 = 5 38 mod 15 = 8
16 mod 5 = 1 1 mod 5 = 1 15 mod 38 = 15
⋆ Exercise 4.68. Compute the following:
(a) 345 mod 100 = (d) 15 mod 9 = (g) 19 mod 12 =
(b) 23 mod 15 = (e) 27 mod 9 = (h) 31 mod 12 =
(c) 15 mod 4 = (f) 7 mod 12 = (i) 47 mod 12 =
Definition 4.69. For integers a , b , and n , where n > 0 , we say that a is congruent to b
modulo n if n divides a − b (that is, a − b = kn for some integer k ). We write this as a ≡ b
(mod n ) .
There are a few other (equivalent) ways of defining congruence modulo n .
• a ≡ b (mod n ) iff a and b have the same remainder when divided by n .
• a ≡ b (mod n ) iff a − b is a multiple of n .
• a ≡ b (mod n ) iff a − b = kn for some integer k .
If a − b 6 = kn for any integer k , then a is not congruent to b modulo n , and we write this as
a 6≡ b (mod n ) .

Remainders and Rounding 97
Example 4.70. Notice that 21 − 6 = 15 = 3 · 5, so 21 ≡ 6 (mod 5).
Notice that if a ≡ b (mod n ) and 0 ≤ b < n , then b is the remainder when a is divided by n .
2 Example 4.71. Prove that for every integer n , n (mod 4) is either 0 or 1.
Proof: Since every integer is either even (of the form 2 k ) or odd (of the form
2 k + 1) we have two possibilities:
2 2 (2 k ) =  4 k ≡ 0  (mod 4), or
2 2 (2 k + 1) =  4( k + k ) + 1 ≡ 1  (mod 4).
2 Thus, n has remainder 0 or 1 when divided by 4. 
Example 4.72. Prove that the sum of two squares of integers leaves remainde r 0, 1 or 2 when
divided by 4.
Proof: According to Example 4.71 , the squares of integers have remainder 0 or 1
when divided by 4. Thus, when we add two squares, the possible remainders when
divided by 4 are 0 (0 + 0), 1 (0 + 1 or 1 + 0) , and 2 (1 + 1). 
Example 4.73. Prove that 2003 is not the sum of two squares.
4.72 we know that Proof: Notice that 2003 ≡ 3 (mod 4). Thus, by Example
2003 cannot be the sum of two squares. 
The proof of the following is left as an exercise. Recall that iff is shorthand for if and only if .
Theorem 4.74. a ≡ b (mod n ) iff a mod n = b mod n .
Example 4.75. Since 1961 mod 37 = 0 and 356 mod 37 = 23, and 0 6 = 23, we know that
1961 6≡ 356 (mod 37) by Theorem 4.74 .
Note: Our definition of mod requires that n > 0 and a ≥ 0 . It is possible to define a mod n
when a is negative. Unfortunately, there are two possible ways of d oing so based on how you
define the remainder when the dividend is negative. One possi ble answer is negative and the
other is positive. They always differ by n , so computing one from the other is easy.
Example 4.76. Since − 13 = ( − 2) ∗ 5 − 3 and − 13 = ( − 3) ∗ 5 + 2, we might consider the
remainder of − 13 / 5 as either − 3 or 2. Thus, − 13 mod 5 = − 3 and − 13 mod 5 = 2 both seem
like reasonable answers. Fortunately, the two possible ans wers differ by 5. In fact, you can
always obtain the positive possibility by adding n to the negative possibility.

98 Chapter 4
⋆ Exercise 4.77. Fill in the missing numbers that are congruent to 1 (mod 4) (li sted in
increasing order)
, -11, , -3, 1, 5, , , 17,
Definition 4.78. The floor of a real number x , written ⌊ x ⌋ , is the largest integer that is less
than or equal to x . The ceiling of a real number x , written ⌈ x ⌉ , is the smallest integer that is
greater than or equal to x .
Example 4.79. ⌊ 4. 5 ⌋ = 4, ⌈ 4. 5 ⌉ = 5, ⌊ 7 ⌋ = ⌈ 7 ⌉ = 7.
In general, if n is an integer, then ⌊ n ⌋ = ⌈ n ⌉ = n .
⋆ Exercise 4.80. Determine each of the following.
1. ⌊ 9. 9 ⌋ = 3. ⌊ 9. 00001 ⌋ = 5. ⌊ 9 ⌋ =
2. ⌈ 9. 9 ⌉ = 4. ⌈ 9. 00001 ⌉ = 6. ⌈ 9 ⌉ =
The following Theorem and Corollary are somewhat obvious, b ut since floors and ceiling can
trip people up, they are useful to have written down explicit ly.
Theorem 4.81. Let a be an integer and x be a real number. Then a ≤ x if and only if a ≤⌊ x ⌋ .
Proof: If a ≤⌊ x ⌋ , then a ≤⌊ x ⌋≤ x is clear. On the other hand, assume a ≤ x .
Then a is an integer that is less than or equal to x . Since ⌊ x ⌋ is the largest integer
that is less than or equal to x , a ≤⌊ x ⌋ . 
Corollary 4.82. Let a , b , and c be integers. Then a ≤ b/c if and only if a ≤⌊ b/c ⌋ .
Proof: Since b/c is a real number, this is a special case of Theorem 4.81 . 

Functions 99
4.3  Functions
This section is meant as a review of what you hopefully alread y learned in an earlier course, probably
in high school. Thus, it is pretty brief. But we do try to cover all of the important material and
provide enough examples to illustrate the concepts.
4.3.1  Definitions
Definition 4.83. Let A and B be sets.  Then a function f from A to B assigns to each
element of A exactly one element from B . We write f : A → B if f is a function from A to
B . If a ∈ A and f assigns to a the value b ∈ B , we write f ( a ) = b . We also say that f maps
a to b .
If A = B , we sometimes say f is a function on A .
2 Example 4.84. If A = B = N , we can define a function f : A → B by f ( x ) = x . Then
f (1) = 1, f (2) = 4, f (3) = 9, etc. Although f ( x ) is defined for all x ∈ A , not every b ∈ B is
mapped to by f . For instance, there is no a ∈ A for which f ( a ) = 5.
√
Example 4.85. Notice that we can define f ( x ) = x on the positive real numbers, but we √ √
2 is not an integer. Similarly, since − 1 = i 6∈ R , cannot define it on the positive integers since
we cannot define it on the real numbers. We can let it be a function from R to C , though. But
we won’t because this course is complex enough even without c omplex numbers.
Definition 4.86. Let f be a function from A to B .
1. We call A the domain of f .
2. We call B the codomain of f .
3. The range of f is the set { b | f ( a ) = b for some a ∈ A } . In other words the range is the
subset of B that are actually mapped to by f .
2 Example 4.87. Let A = B = N and f : A → B be defined by f ( x ) = x . Then the domain
2 and codomain of f are both N , and the range is { a | a ∈ N } , which is a proper subset of the
codomain.
4.3 gives a pictorial representation of a function.  Notice that in this example every Figure
element in A has precisely one arrow going from it. So if I ask “what is f ( x )?”, there is always an
answer and it is always unique. On the other hand, there is a po int in B that has two arrows going
to it and several points that have no arrows going to them. Thi s is fine.
4.4 does not represent a function since there are several points in A which have two Figure
arrows going from them and several with no arrows at all. The p roblem here is that if I ask “what
is f ( x )?”, sometimes there is no answer and sometimes there are mul tiple answers. Thus, f would
not represent a function.

100 Chapter 4
Figure 4.3: Pictorial represen- Figure 4.4: This picture does
tation of a function from A to B . not represent a function.
Note: In figures 4.3 and 4.4 , the dots represent all of the elements of the sets A and B and
the gray ovals are mainly there to help identify which dots ar e in which set. However, in these
sorts of diagrams it is more common for the dots to represent o nly some of the elements. You
need to let the context help you determine how to properly int erpret these diagrams.
Example 4.88. Give a formal definition of a function that assigns to an age th e number of
complete decades someone of that age has lived. For instance , f (34) = 3 and f (5) = 0. Be
sure to indicate what the domain and codomain are.
Solution: It isn’t hard to see that the domain and codomain are both N . Thus
we want a function f : N → N . One way to define f is by f ( x ) = ⌊ x/ 10 ⌋ .
⋆ Exercise 4.89. Give a formal definition of a function that returns the parity of an integer.
That is, it returns 0 for even numbers and 1 for odd numbers. Be sure to indicate what the
domain and codomain are.
Answer
Definition 4.90. Let f : A → B be a function.
• f is said to be injective or one-to-one if and only if f ( a ) = f ( b ) implies that a = b . In
other words, f maps every element of A to a different element of B .
• f is said to be surjective or onto if and only if for every b ∈ B , there exists some a ∈ A
such that f ( a ) = b . In other words, every element in B gets mapped to by some element
in A .
• f is said to be bijective or a one-to-one correspondence if it is both injective and
surjective.

Functions 101
Figure 4.5: Pictorial represen- Figure 4.6: Pictorial represen- Figure 4.7: Pictorial represen-
tation of a one-to-one function. tation of an onto function. tation of an bijective function.
Example 4.91. For each of the following functions from Z to Z , we determine whether or not
they are one-to-one and onto.
(a) Let f ( x ) = x + 2. Notice that if f ( a ) = f ( b ), then a + 2 = b + 2 so a = b . Thus, f is
one-to-one. Also notice that for any b ∈ Z , f ( b − 2) = b − 2 + 2 = b , so f is onto.
2 (b) Let g ( x ) = x . Since g (1) = g ( − 1) = 1, g is not one-to-one. Also notice that there is no
2 integer a such that g ( a ) = a = 5, so g is not onto.
(c) Let h ( x ) = 2 x . If h ( a ) = h ( b ), then 2 a = 2 b so a = b . Thus, h is one-to-one. But there is
no integer a such that h ( a ) = 2 a = 3, so a is not onto.
(d) Let r ( x ) = ⌊ x/ 2 ⌋ . Notice that r (0) = ⌊ 0 / 2 ⌋ = ⌊ 0 ⌋ = 0 and r (1) = ⌊ 1 / 2 ⌋ = ⌊ 0 ⌋ = 0, so r is
not one-to-one. But for any integer b , r (2 b ) = ⌊ 2 b/ 2 ⌋ = ⌊ b ⌋ = b , so r is onto.
The functions in the previous exercise were specifically cho sen to demonstrate that all four
possibilities of being or not being one-to-one and onto (one -to-one and onto, one-to-one and not
onto, not one-to-one but onto, and not one-to-one or onto) ar e possible.
The following theorem should come as no surprise if you take a few minutes to think about it
(and you should take a few minutes to think about it until you are convinced it is correct).
Theorem 4.92. Let f : A → B be a function, and let A and B be finite.
1. If f is one-to-one, then | A |≤| B | .
2. If f is onto, then | A |≥| B | .
3. If f is bijective, then | A | = | B | .

102 Chapter 4
⋆ Exercise 4.93. Let’s test your understanding of the material so far. Answer each of the
following true/false questions, giving a very brief justifi cation/counterexample.
If f : A → B is onto, then the domain and range are not only the same size, b ut they (a)
are the same set.
(b) If f : A → A , then f must be one-to-one and onto.
(c) If f : A → B is both one-to-one and onto, then A and B have the same number of
elements.
Let f (1) = 2 and f (1) = 3. Then f is a valid function. (d)
3 Let f : R → R be defined by f ( x ) = x . Then f is one-to-one and onto. (e)
√ +
Let f : R → R be defined by f ( x ) = x .  Then f is a function that is neither (f)
one-to-one nor onto.
The range of a function is always a subset of the codomain. (g)
(h) A function that is one-to-one is guaranteed to be onto.
(i) Let a , b ∈ Z , with a 6 = 0, and define f : Z → Z by f ( x ) = ax + b . Then f is one-to-one
and onto.
(j) Let a , b ∈ Z , with a 6 = 0, and define f : N → N by f ( x ) = ax + b . Then f is one-to-one
and onto.
(k) Let a , b ∈ R , with a 6 = 0, and define f : R → R by f ( x ) = ax + b . Then f is one-to-one
and onto.

Functions 103
Definition 4.94. Let f be a one-to-one correspondence from A to B .  The inverse of f ,
− 1 − 1 denoted by f , is the function such that f ( b ) = a whenever f ( a ) = b .
A function that has an inverse is called invertible . Said another way, a function is invertible
if and only if it is one-to-one and onto.
− 1 Note: It is important to note that the function f is not the same thing as 1 /f . This is an
unfortunate case when a notation can be interpreted in two di fferent ways. That is, in some
− 1 cases, a means the inverse function and in other cases it means 1 /a . Usually the context
will help you determine which one is the correct interpretat ion.
Procedure 4.95. One method of finding the inverse of a function is to replace f ( x ) (or
whatever the name of the function is) with y and solve for x (or whatever the variable is).
Finally, replace y with x and you have the inverse. However, it is important to note tha t this
only works if f is a one-to-one correspondence, so you typically need to ver ify that first.
Example 4.96. Let f : Z → Z be defined by f ( x ) = x + 2. Notice that f is a one-to-one
correspondence, so it has an inverse. We let y = x + 2. Solving for x , we get x = y − 2. Thus,
− 1 f ( x ) = x − 2.
2 Example 4.97. Let f : R → R be defined by f ( x ) = x . Then f does not have an inverse
since it is not one-to-one.
3 Example 4.98. Let f : R → R be defined by f ( x ) = x . We leave it to the reader to prove
that f is one-to-one and onto. Given that, we can find it’s inverse. √
√ √ 3 3 3 3 3
Let y = x . Taking the third root of both sides, we obtain y = x = x . Or x = y .
√ − 1 3
x . Thus, the inverse of f is given by f ( x ) =
√ 3
3 x = x (similarly for any odd power). However, Notice that the previous example works because
√
2 it does not work for squares since x = | x | (similar for any even power). The fact that the absolute
2 value shows up should clue you into the fact that x is not one-to-one, so it can’t be invertible.
⋆ Exercise 4.99. Let f ( x ) = 7 x + 2 be a function over R .  You can assume that f is a
− 1 one-to-one correspondence. Find f .

104 Chapter 4
Definition 4.100. Let g be a function from A to B and f a function from B to C .  The
composition of f and g , denoted by f ◦ g , is defined as ( f ◦ g )( x ) = f ( g ( x )) for any x ∈ A .
In other words, to compose f with g , we first compute g ( x ). Then we plug in g ( x ) into the
formula for f .
Note: Look closely at the notation. f ◦ g has f before g , so it might seem like it should be
g ( f ( x )) –in other words, apply f first, then then g . But that is not how it is defined.
Also notice that to compose f with g , it is necessary that the range of g is a subset of the
domain of f since otherwise it would be impossible to compute.
2 Example 4.101. Let f and g be functions on Z defined by f ( x ) = x and g ( x ) = 2 x − 5.
Compute f ◦ g and g ◦ f , simplifying your answers.
Solution:
2 2 ( f ◦ g )( x )  = f ( g ( x )) = f (2 x − 5) = (2 x − 5) = 4 x − 20 x + 25.
2 2 ( g ◦ f )( x )  = g ( f ( x )) = g ( x ) = 2 x − 5.
Notice that in the previous example, f ◦ g 6 = g ◦ f . In other words, the order in which we
compose functions matters since the result usually not the s ame (although occasionally it is).
⋆ Exercise 4.102. Let f and g be functions on R defined by f ( x ) = ⌊ x ⌋ and g ( x ) = x/ 2.
Compute f ◦ g and g ◦ f , simplifying your answers.
( f ◦ g )( x )  =
( g ◦ f )( x )  =
Definition 4.103. We define the identity function , ι : A → A , by ι ( x ) = x . A A
The subscript can be omitted if the domain/codomain is clear.
− 1 Theorem 4.104. Let f be an invertible function from A to B .  Then f ◦ f = ι and
B
− 1 f ◦ f = ι .
A
− 1 Proof: Let a ∈ A and define b = f ( a ) . Then by definition, f ( b ) = a , so
− 1 − 1 − 1 − 1 ( f ◦ f )( a ) = f ( f ( a )) = f ( b ) = a . Thus, f ◦ f = ι .
A
− 1 − 1 − 1 Conversely, if b ∈ B and we define a = f ( b ) , then ( f ◦ f )( b ) = f ( f ( b )) =
− 1 f ( a ) = b . Thus, f ◦ f = ι . 
B

Functions 105
Example 4.105. Prove or disprove that f ( x ) = 2 x + 1 and g ( x ) = 2 x − 1, defined over the
real numbers, are inverses.
Solution: Notice that ( f ◦ g )( x ) = f (2 x − 1) = 2(2 x − 1) + 1 = 4 x − 1 6 = x .
According to Theorem 4.104 , this implies that f and g are not inverses.
⋆ Exercise 4.106. Let’s test your understanding of the material so far. Answer each of the
following true/false questions, giving a very brief justifi cation/counterexample.
Let a , b ∈ Z and define f : Z → Z by f ( x ) = ax + b . Then f is invertible. (a)
Let a , b ∈ Z and define f : N → N by f ( x ) = ax + b . Then f is invertible. (b)
(c) Let a , b ∈ R and define f : R → R by f ( x ) = ax + b . Then f is invertible.
2 − 1 2 (d) If f ( x ) = x , then f ( x ) = 1 /x .
√ n
Let n be a positive integer. Then the function x is invertible on R . (e)
√ n
(f) Let n be a positive integer. Then the function x is invertible on N .
√ + n
(g) Let n be a positive integer. Then the function x is invertible on R (the positive
real numbers).
+ 2 Let f and g be functions on Z defined by f ( x ) = x and g ( x ) = 1 /x . Then f ◦ g = g ◦ f . (h)
2 (i) Let f and g be functions on Z defined by f ( x ) = ( x + 1) and g ( x ) = x + 1. Then
f ◦ g = g ◦ f .

106 Chapter 4
(j) Let f ( x ) = ⌊ x ⌋ and g ( x ) = ⌈ x ⌉ be defined on the real numbers. Then f ◦ g = g ◦ f .
(k) Let f ( x ) = ⌊ x ⌋ and g ( x ) = ⌈ x ⌉ be defined on the real numbers. Then f and g are
inverses of each other.
√ 2
(l) Let f ( x ) = x and g ( x ) = x be defined over the positive real numbers. Then f and
g are inverses of each other.

Functions 107
4.3.2  Function Proofs
In this section we give more in depth examples of proving thin gs about functions.
Procedure 4.107. To show that a function f is one-to-one, you just need to show that when-
ever f ( a ) = f ( b ) , then a = b .
Example 4.108. Let f ( x ) = 2 x − 3 be a function on the integers. Show that f is one-to-one.
Solution: Let a , b ∈ Z and assume that f ( a ) = f ( b ). Then 2 a − 3 = 2 b − 3.
Adding 3 to both sides, we get 2 a = 2 b . Dividing both sides by two, we obtain
a = b . Therefore, f ( x ) = 2 x − 3 is one-to-one.
⋆ Question 4.109. Previously we mentioned that ‘working both sides’ was not an appropriate
proof technique. Why is it O.K. in the previous example?
Answer
⋆ Exercise 4.110. Prove that f ( x ) = 5 x is one-to-one over the real numbers.
Proof
Procedure 4.111. To show that a function f is not one-to-one, we simply need to find two
values a 6 = b in the domain such that f ( a ) = f ( b ) . That is, we just need to show that there are
two different numbers in the domain that are mapped to the same value in the codomain.
2 Example 4.112. Let f ( x ) = x be a function on the integers. Show that f is not one-to-one.
Solution: Notice that f ( − 1) = f (1) = 1. Thus, f ( x ) is not one-to-one.
⋆ Exercise 4.113. Let f ( x ) = ⌊ x ⌋ be a function on R . Prove that f is not one-to-one.
Proof

108 Chapter 4
Procedure 4.114. To show that a function f is onto, we need to show that for an arbitrary
b ∈ B , there is some a ∈ A such that f ( a ) = b . That is, show that every value in B is mapped
to by f .
3 Example 4.115. Let f ( x ) = x be a function on the real numbers. Show that f is onto.
ä Ä ä Ä √ √ 3
3 3 3 / 3
= b = b . Since every b ∈ R is Solution: Let b ∈ R . Then f b = b
√ 3
mapped to (from b ), f is onto.
⋆ Exercise 4.116. Let f ( x ) = 2 x + 1 be a function on R . Show that f is onto.
Proof
Procedure 4.117. To show that a function f is not onto, we just need to find some b ∈ B
such that there is no a ∈ A with f ( a ) = b . In other words, we just need to find one value that
isn’t mapped to by f .
3 Example 4.118. Let f ( x ) = x be a function on the integers. Show that f is not onto.
3 Solution: There is no integer a such that a = 2.  In other words, 2 is not
mapped to. Thus, f ( x ) is not onto.
⋆ Exercise 4.119. Let f ( x ) = ⌊ x ⌋ be a function on R . Prove that f is not onto.
Proof
It is important to remember that whether or not a function is o ne-to-one or onto might depend
on the domain/codomain over which the function is defined. Fo r instance, notice that in the last
two examples we used the same function but on different domains /codomains.  In one case the
function was onto, and in the other case it wasn’t.

Functions 109
2 ⋆ Exercise 4.120. Consider the function f ( x ) = x .
2 (a) Prove or disprove that f ( x ) = x is one-to-one on Z .
Answer
2 (b) Prove or disprove that f ( x ) = x is one-to-one on R .
Answer
2 (c) Prove or disprove that f ( x ) = x is one-to-one on N .
Answer
⋆ Exercise 4.121. Let f ( x ) = 3 x − 5 be a function over R . Prove that f has an inverse and
then find it.

110 Chapter 4
⋆ Exercise 4.122. Determine which of the following functions from Z to Z is one-to-one
and/or onto. Prove your answers.
(a) f ( x ) = x − 7
Answer
4 (b) g ( x ) = x
Answer
(c) h ( x ) = 3 x
Answer
(d) r ( x ) = ⌊ x/ 2 ⌋
Answer

Functions 111
Example 4.123. Let f be a function from B to C , and g be a function from A to B . If both
f and g are one-to-one, prove that f ◦ g is one-to-one.
Direct Proof:
For any distinct elements x , y ∈ A , g ( x ) 6 = g ( y ), since g is one-to-one. Since f is
also one-to-one, then f ( g ( x )) 6 = f ( g ( y )), which is the same as ( f ◦ g )( x ) 6 = ( f ◦ g )( y ).
Therefore f ◦ g is one-to-one. 
Proof by Contradiction:
Assume f ◦ g is not one-to-one. Then there exist distinct elements x , y ∈ A such
that ( f ◦ g )( x ) = ( f ◦ g )( y ). This is equivalent f ( g ( x )) = f ( g ( y )). Since f is one-
to-one, it must be the case that g ( x ) = g ( y ). But x 6 = y , and g is one-to-one, so
g ( x ) 6 = g ( y ). This is a contradiction. Therefore f ◦ g is one-to-one. 

112 Chapter 4
4.4  Partitions and Equivalence Relations
Partitions and equivalence relations are not only fun and in teresting to learn about, they have
various applications, including some related to software t esting that we will explore later.
Definition 4.124. Let S 6 = ∅ be a set. A partition of S is a collection of non-empty, pairwise
disjoint subsets of S whose union is S .
Example 4.125. Define E = { 2 k : k ∈ Z } and O = { 2 k + 1 : k ∈ Z } . Clearly E is the set of
even integers and O is the set of odd integers. Since E ∩ O = ∅ and E ∪ O = Z , { E , O } is a
partition of Z . Put another way, we can partition the integers based on pari ty.
Example 4.126. We can partition the socks in our sock drawer by color. In othe r words, we
put all of the black socks in one set, the white ones in another , the green ones in another, etc.
For simplicity, we can put all of the multi-color socks in a si ngle set.
Example 4.127. We can partition the set of all humans by putting each person i nto a set
based on the first letter of their first name. So Adam and Adele go into set A and Zeek goes
a into set Z , for instance. The sets in the partition are A , B , . . . Z .
a For simplicity, we assume everyone’s name is written using t he Roman alphabet.
Example 4.128. Let A = { 1, 5, 8 } , B = { 2, 3 } , C = { 4 } , D = { 6, 9 } , and E = { 7, 10, 11, 12 } .
Then the sets A , B , C , D , and E form a partition of the set { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 } .
Example 4.129. When choosing test cases for the factorial method in Example 5.89 , we
+ − thought about 3 subsets of Z : { 0 } , Z , and Z . These cases form a partition of Z since they
+ − are disjoint and Z = { 0 }∪ Z ∪ Z . This is good since it means we covered at least one value of
the different types, and we didn’t ‘overtest’ any of the cases b y unknowingly duplicating values
from the same case.
⋆ Exercise 4.130. You must decide on test cases for a method int maximum(int a,int b)
that returns the maximum of its arguments. How would you part ition the possible inputs into
sets such that if it is correct for one (or a few) tests of cases from that set, it is probably correct
for the rest of the cases in that set? Notice that the set of inp uts is Z × Z .
Answer

Partitions and Equivalence Relations 113
Most of the partitions we talk about will be based on some mean ingful characteristic of the
elements of a set–like parity, color, or sign. But this is not inherent in the definition. For instance,
4.128 do not seem to have any significant meaning. Some, the sets in the partition from Example
like the one in Example 4.125 , will have a precise mathematical definition. Others, like t he one in
4.126 will not. Examples
⋆ Exercise 4.131. Define a partition on Z that contains more than one subset.
Answer
Example 4.132. Let 3 Z = { 3 k : k ∈ Z } , 3 Z + 1 = { 3 k + 1 : k ∈ Z } , and 3 Z + 2 = { 3 k + 2 :
a Since k ∈ Z } .
(3 Z ) ∪ (3 Z + 1) ∪ (3 Z + 2) = Z and
(3 Z ) ∩ (3 Z + 1) = ∅ , (3 Z ) ∩ (3 Z + 2) = ∅ , (3 Z + 1) ∩ (3 Z + 2) = ∅ ,
{ 3 Z , 3 Z + 1, 3 Z + 2 } is a partition of Z .
a The notation in this example may seem a bid odd at first. How are you supposed to interpret “3 Z + 1”? Is
this 3 times the set Z plus 1? What does it mean to do algebra with sets and numbers? I won’t get into all of
the technical details, but here is a short answer. You can thi nk of “3 Z + 1” as just a name. Sure, it may seem
like an odd name, but why can’t we name a set whatever we want? S ome people name their kids Jon Blake
Cusack 2.0 and get away with it. You can also think of “3 Z + 1” as describing how to create the set—by taking
every element from Z , multiplying it by 3, and then adding 1. Thus, you can think of “3 Z + 1” as being both
an algebraic expression and a name.
⋆ Exercise 4.133. Let I = R \ Q (the set of irrational numbers).  Prove that { Q , I } is a
partition of R .
Proof
Recall that when a list of number is given between parenthese s (e.g.  (1, 2, 3)), it typically
denotes an ordered list. That is, the order that the element a re listed matters. So, for instance,
(1, 2) and (2, 1) are not the same thing.
Next we will develop an alternative way of thinking about par titions: equivalence relations.
After defining some terms and providing a few examples, we wil l make the connection between
partitions and equivalence relations more clear.
Definition 4.134. Let A , B be sets. A relation (or binary relation ) from A to B is a subset
of the Cartesian product A × B .
Given a relation R , we say that x is related to y if ( x , y ) ∈ R . We sometimes write this

114 Chapter 4
as xRy . An alternative notation is x ∼ y .
If R is a relation from A to A , we sometimes say R is a relation on A .
Example 4.135. Let A be the set of all students at this school and B be the set of all courses
at this school. We can define a relation R by saying that xRy if student x has taken course y .
Said another way, we can define R by saying that ( x , y ) ∈ R if student x has taken course y .
2 Example 4.136. We can define a relation R = { ( a , a ) : a ∈ Z } . That is, x is related to y if
2 y = x .
Example 4.137. We can define a relation on Z by saying that x is related to y if they have
the same parity. Thus, (2, 0), (234, − 342), (3, 17) are all in R , but (2, 127) is not.
⋆ Question 4.138. Define R = { ( a , b ) : a , b ∈ Z and a < b } . Is R a relation? Explain.
Answer
+ ⋆ Question 4.139. Is { (1, 2), (345, 7), (43, 8675309), (11, 11) } a relation on Z ? Explain.
Answer
Definition 4.140. A relation R on set A is said to be reflexive if for all x ∈ A , xRx (or
( x , x ) ∈ R ).
⋆ Exercise 4.141. Let P be the set of all people. Which of the following relations on P are
reflexive? Explain why or why not.
(a) T = { ( a , b ) : a , b ∈ P and a is taller than b }
(b) N is the relation with a related to b iff a ’s name starts with the same letter as b ’s name.
(c) C is the relation defined by ( a , b ) ∈ C if a and b have been to the same city.
(d) K = { ( a , b ) : a , b ∈ P and a does not know who b is }
(e) R = { (Barack Obama, George W. Bush) } .
(a) T :

Partitions and Equivalence Relations 115
(b) N :
(c) C :
(d) K :
(e) R :
Definition 4.142. A relation R on set A is said to be symmetric if for all x , y ∈ A , xRy
implies yRx (or ( x , y ) ∈ R implies ( y , x ) ∈ R ).
⋆ Exercise 4.143. Which of the relations from Example 4.141 are symmetric? Explain why
or why not.
(a) T :
(b) N :
(c) C :

116 Chapter 4
(d) K :
(e) R :
Definition 4.144. A relation R on set A is said to be anti-symmetric if for all x , y ∈ A ,
xRy and yRx implies x = y (or ( x , y ) ∈ R and ( y , x ) ∈ R implies x = y ).
⋆ Question 4.145. Let R be a relation on Z .
(a) If (1, 1) ∈ R , can you tell whether or not R is anti-symmetric? Explain.
Answer
(b) What if (1, 2) and (2, 1) are both in R ? Can you tell whether or not R is anti-symmetric?
Answer
⋆ Question 4.146. An alternative definition of anti-symmetric is that if x 6 = y , then ( x , y )
and ( y , x ) are not both in the relation. Why is this definition equivale nt?
Answer
Note: The definition of anti-symmetric is sometimes misunderstood . Let’s call elements of
the form ( x , x ) diagonal elements and elements of the form ( x , y ) where x 6 = y off-diagonal
a Then the definition of anti-symmetric is only dealing with off- diagonal elements. It elements.
is saying nothing about the diagonal elements. In other words , it is not saying that ( x , x ) ∈ R
for any, let alone all, values of x . But it also isn’t saying ( x , x ) 6∈ R . It is simply saying that
the only way for both ( x , y ) and ( y , x ) to be in R is if x = y .
The alternative definition given in the previous question may help a little. Notice that the
definition there starts with ‘if x 6 = y ...’ So what does the definition say about the case x = y ?
Nothing. It never mentions it.
You could redefine it as follows: R is anti-symmetric if for all non-diagonal elements ( x , y ) ∈

Partitions and Equivalence Relations 117
R , ( y , x ) 6∈ R . But that can be problematic if you forget that x 6 = y is required.
a These terms come from thinking about the elements of a relati on as elements in a matrix indexed by the
members of the set. If this doesn’t make sense, don’t worry to o much about it.
⋆ Exercise 4.147. Which of the relations from Example 4.141 are anti-symmetric? Explain
why or why not.
(a) T :
(b) N :
(c) C :
(d) K :
(e) R :
⋆ Question 4.148. Answer each of the following. Include a brief justification/ example.
(a) If a relation is not symmetric, is it anti-symmetric?
Answer
(b) If a relation is not anti-symmetric, is it symmetric?
Answer

118 Chapter 4
(c) Can a relation be both symmetric and anti-symmetric?
Answer
⋆ Exercise 4.149. Give an example of a relation on any set of your choice that is b oth
symmetric and anti-symmetric. Justify your answer.
Answer
Definition 4.150. A relation R on set A is said to be transitive if for all x , y , z ∈ A ,
xRy and yRz implies xRz (or (( x , y ) ∈ R and ( y , z ) ∈ R ) implies ( x , z ) ∈ R ).
⋆ Exercise 4.151. Which of the relations from Example 4.141 are transitive? Explain why
or why not.
(a) T :
(b) N :
(c) C :
(d) K :
(e) R :

Partitions and Equivalence Relations 119
Definition 4.152. A relation which is reflexive, symmetric and transitive is ca lled an equiv-
alence relation .
Example 4.153. Let S = { All Human Beings } , and define the the relation M by ( a , b ) ∈ M
a as b . Show that M is an equivalence relation. if a has the same (biological) mother
Proof: ( Reflexive ) a has the same mother as a , so ( a , a ) ∈ M and M is reflexive.
( Symmetric ) If a has the same mother as b , then b clearly has the same mother
as a . Thus, ( a , b ) ∈ M implies ( b , a ) ∈ M , so M is symmetric.
( Transitive ) If a has the same mother as b , and b has the same mother as c , then
clearly a has the same mother as c . In other words, ( a , b ) ∈ M and ( b , c ) ∈ M
implies that ( a , c ) ∈ M , so M is transitive.
Since M is reflexive, symmetric, and transitive, it is an equivalenc e relation. 
a The important assumption we are making is that each person ha s exactly one mother.
⋆ Exercise 4.154. Which of the relations from Example 4.141 are equivalence relations?
Explain why or why not.
(a) T :
(b) N :
(c) C :
(d) K :
(e) R :

120 Chapter 4
Definition 4.155. A relation which is reflexive, anti-symmetric and transitiv e is called a
partial order .
⋆ Exercise 4.156. Which of the relations from Example 4.141 are partial orders? Explain
why or why not.
(a) T :
(b) N :
(c) C :
(d) K :
(e) R :
⋆ Exercise 4.157. Let X be a collection of sets. Let R be the relation on X such that A is
related to B if A ⊆ B . Prove that R is a partial order on X .
Proof: ( Reflexive )
( Anti-symmetric )
( Transitive )

Partitions and Equivalence Relations 121

Labeling the lines of these proofs with what property we are p roving isn’t strictly necessary.
However, it does make the proofs a little easier to read.
⋆ Exercise 4.158. Consider the relation R = { (1, 2), (1, 3), (1, 5), (2, 2), (3, 5), (5, 5) } on the
set { 1, 2, 3, 4, 5 } . Prove or disprove each of the following.
(a) R is reflexive
Answer
(b) R is symmetric
Answer
(c) R is anti-symmetric
Answer
(d) R is transitive
Answer
(e) R is an equivalence relation
Answer
(f) R is a partial order
Answer
Next we show that congruence modulo n (See Definition 4.69 ) is an equivalence relation.

122 Chapter 4
Theorem 4.159. Let n be a positive integer. Let R be the relation on the set of integers defined
by R = { ( a , b ) : a ≡ b (mod n ) } . Then R is an equivalence relation.
Proof: We need to show that R is reflexive, symmetric, and transitive.
( Reflexive ) Clearly a − a = 0 · n , so a ≡ a (mod n ) . Thus, R is reflexive.
( Symmetric ) Assume ( a , b ) ∈ R . Then a ≡ b (mod n ) , which implies a − b = kn
for some integer k . So b − a = ( − k ) n , and since − k is an integer, b ≡ a (mod n ) .
Therefore, ( b , a ) ∈ R . Thus, R is symmetric.
( Transitive ) Assume ( a , b ), ( b , c ) ∈ R . Then a ≡ b (mod n ) and b ≡ c (mod n ) .
Thus, a − b = kn for some integer k and b − c = ln for some integer l . Given these,
we can see that
a − c = ( a − b ) + ( b − c ) = kn + ln = ( k + l ) n .
Since k + l is an integer, a ≡ c (mod n ) . Thus ( a , c ) ∈ R , so R is transitive. 
Notice that if we let n = 2 in the previous theorem, we essentially have the relation from
4.137 . Example
⋆ Fill in the details 4.160. Let R be the relation on the set of ordered pairs of positive
+ + integers (that is, Z × Z ) such that (( a , b ), ( c , d )) ∈ R if and only if ad = bc . Show that R is
a an equivalence relation.
Proof: We need to show that R is reflexive, symmetric, and transitive.
∈ R for ( Reflexive ) Since ab = ba for all positive integers,
all ( a , b ). Thus R is reflexive.
( Symmetric ) Assume (( a , b ), ( c , d )) ∈ R .  Then we know that ad = .
We can rearrange this as cb = .  Thus, ∈ R , so R is
.
( Transitive ) Assume that (( a , b ), ( c , d )) ∈ R and (( c , d ), ( e , f )) ∈ R .  Then we
and .  Solving the sec- know that
ond for c , we get c = .  Plugging it into the first we get ad =
. Multiplying both sides by f , and canceling the d on both sides
. Thus, ∈ R , so R is transitive. yields

a In this example, R is a relation on a set of ordered pairs. Thus, the elements of R are ordered pairs of
ordered pairs. Don’t let this confuse you. The elements of a r elation are always ordered pairs. What each part

Partitions and Equivalence Relations 123
of the pair is depends on the underlying set. If it is the set of animals, then the elements of the relation are
ordered pairs of animals. If it is Z , then the elements of the relation are ordered pairs of integ ers. And if it is
+ + Z × Z , then the elements of the relation are ordered pairs of order ed pairs of positive integers.
Definition 4.161. Let R be an equivalence relation on a set S . Then the equivalence class
of a , denoted by [ a ] , is the subset of S containing all of the elements that are related to a .
More formally,
[ a ] = { x ∈ S : xRa } .
If x ∈ [ a ] , we say that x is a representative of the equivalence class [ a ] . Note that any element
of an equivalence class can serve as a representative.
Example 4.162. The equivalence class of 3 modulo 8 is [3] = { 8 k + 3 : k ∈ Z } . Notice that
[11] = { 8 k + 11 : k ∈ Z } = { 8 k + 3 : k ∈ Z } = [3]. In fact, [3] = [8 l + 3] for all integers l . In
other words, any element of the form 8 l + 3, where l is an integer, can serve as a representative
of [3]. Further, we can call this class [3], [11], [19], etc. I t doesn’t really matter since they all
represent the same set of integers. Of course, [3] is the most logical choice.
Example 4.163. Notice that if our relation is congruence modulo 3, we can defi ne three
equivalence classes:
[0]  = { 3 k : k ∈ Z } ,
[1]  = { 3 k + 1 : k ∈ Z } , and
[2]  = { 3 k + 2 : k ∈ Z } .
It isn’t too difficult to see that Z = [1] ∪ [2] ∪ [3], and that these three sets are disjoint. In other
words, the equivalence classes { [1], [2], [3] } form a partition of Z . As we will see shortly, this is
not a coincidence.
Lemma 4.164. Let R be an equivalence relation on a set S . Then two equivalence classes are
either identical or disjoint.
Proof: Let a , b ∈ S , and assume [ a ] ∩ [ b ] 6 = ∅ (that is, that they are not disjoint).
We need to show that [ a ] = [ b ] . First, let x ∈ [ a ] ∩ [ b ] (which exists since [ a ] ∩ [ b ] 6 = ∅ ).
Then xRa and xRb , so by symmetry aRx and by transitivity aRb .
Now let y ∈ [ a ] . Then yRa . Since we just showed that aRb , then yRb by transitivity.
Thus y ∈ [ b ] . Therefore [ a ] ⊆ [ b ] .
A symmetric argument proves that [ b ] ⊆ [ a ] . Therefore, [ a ] = [ b ] . 
Let’s bring together some of the examples of partitions with examples of equivalence relations
and classes.

124 Chapter 4
Example 4.165. We just saw that congruence modulo 3 is an equivalence relati on with three
4.132 , we equivalence classes, { 3 k : k ∈ Z } , { 3 k + 1 : k ∈ Z } , and { 3 k + 2 : k ∈ Z } . In Example
defined a partition of Z using these same three subsets.
Example 4.166. In Example 4.137 we defined a relation on Z based on parity.  It is not
difficult to see that the equivalence classes of that relation are [0] = E and [1] = O . Notice
these are the same subsets we used to partition Z in Example 4.125 .
Example 4.167. In Example 4.127 we defined a partition of people according to the first
letter of their first name. The sets in the partition were A , B , . . . , Z .
We can define an equivalence relation on the set of all people b y saying a is related to b if a ’s
name starts with the same letter of the alphabet as b ’s name. In a series of previous exercises,
you proved that this defines an equivalence relation. Notice that the equivalence classes are the
sets A , B , . . . , Z (which we can think of as, for instance [ Adam ], [ Betty ], . . . , [ Zeek ]). Again,
4.127 . these are the same sets that we used to partition people into i n Example
In these examples, there seems to be a connection between the equivalence classes of the relation
and the sets in a partition. As the next theorem illustrates, this is no coincidence.
Theorem 4.168. Let S 6 = ∅ be a set. Every equivalence relation on S induces a partition of
S and vice-verse.
Proof: By Lemma 4.164 , if R is an equivalence relation on S then
⋃
S = [ a ],
a ∈ S
and [ a ] ∩ [ b ] = ∅ if a is not related to b . This proves the first half of the theorem.
Conversely, let ⋃
S = S , where S ∩ S = ∅ if α 6 = β , α α β
α
be a partition of S . We define the relation R on S by letting aRb if and only if they
belong to the same S . Since the S are mutually disjoint, it is clear that R is an α α
equivalence relation on S and that for a ∈ S , we have [ a ] = S .  α α
Equivalence classes of an equivalence relation and partiti ons of sets are essentially the same
thing. The main difference is in how we look at it. When thinking about equivalence relations/-
classes, the focus is on what it means for two things to be rela ted. When thinking about partitions,
the focus is on what it means for an element to be in a particula r subset of the partition.
Example 4.169. In light of Theorem 4.168 , we can say that the relation defined by congruence
modulo 4 partitions the set of integers into precisely 4 equi valence classes: [0], [1], [2], and [3].
That is, given any integer, it is contained in one (and only on e) of these classes.
More generally, if n > 2, Z can be partitioned into n sets, [0], [1], . . . , [ n − 1], each of which
is an equivalence class of the relation defined by congruence modulo n .
When we think about the partition, we are focused on the conce pt that each number x
goes into one of the n subsets based on the value x mod n . On the other hand, when we think

Partitions and Equivalence Relations 125
about the relation of congruence modulo n , we are focused on the idea that x and y are in the
same equivalence class iff x ≡ y (mod n ).
For more discussion and some applications of partitions and equivalence relations, see Sec-
5.10 . tion

126 Chapter 4
4.5  Reading Comprehension Questions
From Section 4.1.1
Question 4.1. Let A = { 1, 2, 3, 4, 5, 6 } and B = { 2, 4, 6 } .  Which of the following notations ⋆
makes sense? Explain what is wrong with the ones that do not ma ke sense.
(a) 3 ⊆ A . (b) 3 ∈ A . (c) { 3 }∈ A . (d) { 3 }⊆ A . (e) B ∈ A . (f) B ⊆ A .
⋆ Question 4.2. What is |{ 1, 2, 2, 3, 4, 5, 5 }| ?
⋆ Question 4.3. Let A = { 1, 2, 3, 4, 5, 6 } , B = { 2, 4, 6 } , and C = { 1, 3, 5, 7 } .
(a) (i) Is B ⊆ A ? (ii) Is C ⊆ A ? (iii) Is A ⊆ B ?
(b) Find | A | , | B | and | C | .
(c) Are A , B , and C finite or infinite sets?
+ + ⋆ Question 4.4. (a) Is Z ⊆ Z ? (b) Is Z ⊆ Z ? (c) Is Z ⊆ Q ? (d) Is Q ⊆ R ? (e) Is R ⊆ Q ?
⋆ Question 4.5. Use a reasonable mathematical notation to express the set of perfect cubes (e.g.
3 3 numbers like 8 = 2 and − 27 = ( − 3) ).
⋆ Question 4.6. Use a reasonable mathematical notation to express the set of all numbers that
have at most 2 digits past the decimal point. For instance, th e set contains 7, 3.4, and 45.98, but
does not contain 867.5309. (Hint: There is a really easy way t o express this if you give it a little
bit of thought. On the other hand, do not overthink it or you wi ll come up with something more
complicated than necessary.)
⋆ Question 4.7. Let A be a set. Is A ∈ P ( A )? Is A ⊆ P ( A )?
⋆ Question 4.8. Let A be a set with | A | = 5. How many subsets does A have? (Hint: don’t work
too hard on this one!)
⋆ Question 4.9. Let A = { a , b , c , d , e } .
(a) What are | A | and | P ( A ) | ?
(b) Is {{ a } , { b , c } , { a , c , e }} ⊆ A ? If not, explain why not.
(c) Is { b , c , e }⊆ A ? If not, explain why not.
(d) Is { b , c , e }∈ A ? If not, explain why not.
(e) Is {{ a } , { b , c } , { a , c , e }} ⊆ P ( A )? If not, explain why not.
(f) Is { b , c , e }⊆ P ( A )? If not, explain why not.
(g) Is { b , c , e }∈ P ( A )? If not, explain why not.
From Section 4.1.2
Question 4.10. Let U = { a , b , c , d , . . . , z } (the letters in the English alphabet) be the universal ⋆
V (the consonants), and R = { a , b , d , g , k , p , v } (some set, V = { a , e , i , o , u } (the vowels), C =
random letters). Find each of the following: (a) C ∪ R (b) C ∩ R (c) V ∩ R (d) R \ C (e) C ∪ R

Reading Comprehension Questions 127
⋆ Question 4.11. True or False?
(a) A ∩ B ⊆ A
(b) A ∪ B ⊆ A
(c) A \ B ⊆ B
(d) The intersection of the complements of two sets is the sam e as the complement of the union of
the two sets.
⋆ Question 4.12. Let A = { 1, 2, 3, 4 } and B = { u , v , w , x , y , z } .
(a) Give 3 examples of elements in A × B .
2 (b) Give 3 examples of elements in A .
(c) What is | A × B | ?
3 (d) What is | A | ?
2 (e) What is | P ( A × B ) | ?
⋆ Question 4.13. The image to the right (which originated
https://9gag.com/gag/4169218 ) is a joke based on from
the U2 song “With or without you,” and in particular the
lyric “I can’t live with or without you” which is sung by the
lead singer, Bono. What is wrong with the Venn diagram?
Draw a correct Venn Diagram that expresses where Bono
can’t live.
From Section 4.1.3
Question 4.14. Let A and B be sets. ⋆
(a) Let’s say that I can prove that whenever x ∈ A , then x ∈ B . What did I just prove?
(b) Let’s assume I have the proof from part (a), but I can also p rove that whenever x ∈ B , then
x ∈ A . Now what have I proven?
⋆ Question 4.15. Give an informal proof of the second version of De Morgan’s la w (See Table 4.1 )
by describing the sets on both sides of the inequality and con cluding that they are the same.
⋆ Question 4.16. Use a set containment proof to prove the first complement law. That is, if A is
A = U . a set and U is the universal set, prove that A ∪
From Section 4.2
Question 4.17. How can you use the mod operator to determine whether an integ er is even or ⋆
odd?
⋆ Question 4.18. If you want to know what time it is 8 hours from now, can you use m odular
arithmetic to help you compute that? Explain. Does the answe r change in any way if you are
working with 24-hour military time versus 12-hour times wit h am/pm? Explain how the calculation
can be done in both cases (using modular arithmetic, assumin g it is appropriate).

128 Chapter 4
⋆ Question 4.19. Given integers a , b , and n , explain how you can determine whether or not a ≡ b
(mod n ). Hint: There may be a helpful Theorem from this section.
⋆ Question 4.20. Is the floor of the ceiling of a number always the same as the cei ling of the floor
of a number? Explain, giving examples as necessary.
From Section 4.3.1
Question 4.21. Let f : Z → Z be a function defined by f ( x ) = 2 x . ⋆
(a) What is the domain of f ?
(b) What is the codomain of f ?
(c) What is the range of f ?
⋆ Question 4.22. Let A = { 1, 2, 3, 4 } and B = { 2, 4, 6, 8 } .  Give an example of each of the
following. If it is not possible, explain why.
(a) A function f : A → B that is one-to-one.
(b) A function f : A → B that is not one-to-one.
(c) A function f : A → B that is onto.
(d) A function f : A → B that is not onto.
(e) A function f : A → B that is bijective.
⋆ Question 4.23. Let A = { 1, 2, 3, 4 } and B = { 2, 4, 6, 8, 10, 12 } . Give an example of each of the
following. If it is not possible, explain why.
(a) A function f : A → B that is one-to-one.
(b) A function f : A → B that is not one-to-one.
(c) A function f : A → B that is onto.
(d) A function f : A → B that is not onto.
(e) A function f : A → B that is bijective.
x ⋆ Question 4.24. Let f ( x ) = 2 and g ( x ) = x + 2. Find f ◦ g and g ◦ f .
4.3.2 From Section
⋆ Question 4.25. Is each of the following true or false? If it is false, explain why.
(a) To show that f is one-to-one, you need to show that if a = b , then f ( a ) = f ( b ).
(b) To show that f is not one-to-one, you only need to find two values in the domain that map to
the same element of the codomain.
(c) To show that f is onto, you need to show that every element of the domain gets mapped to
some element of the codomain.

Reading Comprehension Questions 129
(d) To show that f is onto, you can show that the range and codomain are exactly t he same set.
(e) To show that f is not onto, you need to show that no elements of the range are mapped to.
(f) To show that f is invertible, you need to show that f is one-to-one and that f is onto.
3 ⋆ Question 4.26. Let f : R → R be defined by f ( x ) = x − 8. Prove that f is invertible and find
its inverse.
From Section 4.4
⋆ Question 4.27. Let A = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } , B = { 2, 4, 6, 8, 10 } .
(a) Define a set C such that B , C is a partition of A .
(b) Define a set C such that B , C is a not partition of A because the sets are not disjoint.
(c) Define a set C such that B , C is a not partition of A because the union of the sets is not A .
(d) Define sets C and D such that B , C , D is a partition of A .
(e) Define sets C and D such that B ∩ D = C ∩ D = ∅ , and B ∪ C ∪ D = A , but B , C , D , is a not
partition of A .
⋆ Question 4.28. Is { (1, 3), (456, 901), (867, 5309) } a relation on Z ? Explain.
⋆ Question 4.29. Define a partial order on the set of all human beings. Briefly ex plain why it is
a partial order.
⋆ Question 4.30. Define an equivalence relation on the set of all cars.  Briefly e xplain why it
is an equivalence relation. Then define a partition of the set of all cars that corresponds to the
equivalence relation.  Give a clear definition of each equiva lence class (that is, each set in the
partition), and if possible give a representative element f rom each subset.
+ ⋆ Question 4.31. Let B be the relation on Z such that ( x , y ) ∈ B if x and y have the same
number of 1s in their binary representation. For example, 3 = 11 and 5 = 101 , so both 3 and 5 2 2
have two 1s in their binary representation. Thus, (3, 5) ∈ B and (5, 3) ∈ B . On the other hand,
(3, 2) 6∈ B since 2 = 10 has only one 1 in its binary representation. 2
(a) Is B an equivalence relation? Explain.
(b) Is B a partial order? Explain.
+ (c) Define a partition of Z based on the relation B . (Hint: The fact that I am asking this question
should clue you in on the answer to one or more of the previous q uestions.) In other words,
+ define sets B , B , B . . . such that Z = B ∪ B ∪ B ∪··· and B ∩ B = ∅ if i 6 = j . To be
1 2 3 1 2 3 i j
clear, I am looking for a clear definition of B for a given value of i . i
(d) Give the most obvious choice of a representative for each subset B . That is, choose an a such i i
that [ a ] = B . i i
(e) Give at least 4 elements of B . 2

130 Chapter 4
4.6  Problems
Problem 4.1. Draw a Venn diagram showing A ∩ ( B ∪ C ), where A , B , and C are sets.
Problem 4.2. Assume A , B , and C are sets. Prove each of the following set identities using a s et
containment proof based on the basic definitions of ∩ , ∪ , etc. (see examples 4.61 , 4.64 , and 4.65 ).
(a) ( A ∩ B ∩ C ) ⊆ ( A ∩ B ).
(b) A ∩ B ⊆ A ∪ B .
(c) ( A ∪ B ) \ ( A ∩ B ) = ( A \ B ) ∪ ( B \ A ).
(d) ( A − B ) \ C ⊆ A \ C .
Problem 4.3. Prove each of the following set identities using a set contai nment proof based on
the basic definitions of ∩ , ∪ , etc. (see examples 4.61 , 4.64 , and 4.65 ).
(a) A ∪ ( A ∩ B ) = A .
(b) A ∪ ( B ∩ C ) = ( A ∪ B ) ∩ ( A ∪ C )
(c) ( A \ B ) \ C = ( A \ C ) \ ( B \ C ).
(d) A ∪ ( B ∩ C ) = ( C ∪ B ) ∩ A . (This one is a little tricky.)
Problem 4.4. Rusty has 20 marbles of different colors: black, blue, green, a nd yellow. Seventeen
of the marbles are not green, five are black, and 12 are not yell ow. How many blue marbles does
he have?
Problem 4.5. You need to settle an argument between your boss (who can fire y ou) and your
professor (who can fail you). They are trying to decide who to invite to the Young Accountants
Volleyball League. They want to invite freshmen who are stud ying accounting and are at least 6
feet tall. They have a list of all students.
(a) Your boss says they should make a list of all freshmen, a li st of all accounting majors, and a
list of everyone at least 6 feet tall. They should then combin e the lists (removing duplicates)
and invite those on the combined list. Is he correct? Explain . If he is not correct, describe in
the simplest possible terms who ends up on his guest list.
(b) Your professor says they should make a list of everyone wh o is not a freshman, a list of everyone
who does not do accounting, and a list of everyone who is under 6 feet tall. They should make
a fourth list that contains everyone who is on all three of the prior lists. Finally, they should
remove from the original list everyone on this fourth list, a nd invite the remaining students. Is
he correct? Explain. If he is not correct, describe in the sim plest possible terms who ends up
on his guest list.
(c) Give a simple description of how the guest list should be c reated.
Problem 4.6. Using words, explain what 53 mod 7 = 4 means.
Problem 4.7. Let a be a integer such a ≤ 17 / 3. What can you say about a ? Prove your claim.

Problems 131
Problem 4.8. Compute each of the following. If 2 answers are possible, giv e both.
(a) 23 mod 10 (d) 3 mod 5 (g) 13 mod 12 (j) − 7 mod 12
(b) − 14 mod 10 (e) 34 mod 5 (h) 144 mod 12 (k) 3 mod 2
(c) 8675309 mod 10 (f) − 8 mod 5 (i) 7 mod 12 (l) − 3 mod 2
Problem 4.9. Compute each of the following.
(a) ⌊ 2. 72 ⌋ (d) ⌈ 3. 1415 ⌉ (g) ⌊ 3 / 2 ⌋ (j) ⌈ 8. 675309 ⌉ mod 3
(b) ⌈ 2. 72 ⌉ (e) ⌊⌈ 3. 1415 ⌉⌋ (h) ⌊ 5 / 4 ⌋
(c) ⌊ 3. 1415 ⌋ (f) ⌈⌊ 3. 1415 ⌋⌉ (i) ⌊ 8. 675309 ⌋ mod 3
Problem 4.10. Prove or disprove: If a is a real number and n is an integer, then ⌊ a ⌋ mod n =
⌊ a mod n ⌋ .
Problem 4.11. Recall that a ≡ b (mod n ) iff a − b = kn for some integer k . Use this definition of
4.74 . (Note: This is an if and only if proof, so you need congruence modulo n to prove Theorem
to prove both ways.)
Problem 4.12. Let a , b ∈ R , a 6 = 0, and define f : R → R by f ( x ) = ax + b . Prove that f is
one-to-one and onto.
Problem 4.13. Let a and b be real numbers with a 6 = 0. Define f : R → R by f ( x ) = a x + b .
− 1 Show that f is invertible. Then find f .
Problem 4.14. Prove or disprove: if a , b , and c are real numbers with a 6 = 0, then the function
2 f ( x ) = a x + b x + c is invertible.
Problem 4.15. Prove that if f and g are onto, then f ◦ g is also onto.
Problem 4.16. Let f ( x ) = x + ⌊ x ⌋ be a function on R . (This one is a little tricky.)
(a) Prove or disprove that f is one-to-one.
(b) Prove or disprove that f is onto.
(c) Prove or disprove that f is invertible.
3 Problem 4.17. Find the inverse of the function f ( x ) = x + 1 over the real numbers.
+ Problem 4.18. Let f be the function on Z that maps x to the number of bits required to
represent x in binary. For instance, f (1) = 1, f (2) = 2, f (3) = 2, f (4) = 3, f (10) = 4, etc. Hint:
n The number 2 requires n + 1 bits to represent (a single 1 followed by n zeros). You may be able
to use this fact in one of your proofs.
(a) Prove or disprove that f is one-to-one.
(b) Prove or disprove that f is onto.
(c) Prove or disprove that f is invertible.

132 Chapter 4
Problem 4.19.
Consider the relation R = { (1, 2), (1, 3), (3, 5), (2, 2), (5, 5), (5, 3), (2, 1), (3, 1) } on set { 1, 2, 3, 4, 5 } .
Is R reflexive? symmetric? anti-symmetric? transitive? an equi valence relation? a partial order?
Problem 4.20. Let X be the set of all people. Which of the following are equivalen ce relations?
Prove it.
2 (a) R = { ( a , b ) ∈ X | a and b are the same height }
1
2 (b) R = { ( a , b ) ∈ X | a is taller than b }
2
2 (c) R = { ( a , b ) ∈ X | a is at least as tall as b }
3
2 (d) R = { ( a , b ) ∈ X | a and b have the same last name }
4
2 (e) R = { ( a , b ) ∈ X | a has the same kind of pet as b }
5
Problem 4.21. Repeat the previous problem, but which are partial orders? P rove it.
Problem 4.22. Define three different equivalence relations on the set of all T V shows. For each,
give examples of the equivalence classes, including one rep resentative from each. Prove that each
is an equivalence relation.
Problem 4.23. Define a relation on the set of all Movies that is not an equivalence relation.
Problem 4.24. Let A = { 1, 2, . . . , n } . Let R be the relation on P ( A ) (the power set of A ) such
that a , b ∈ P ( A ) are related iff | a | = | b | . Prove that R is an equivalence relation. What are the
equivalence classes of R ?

Chapter 5: Programming Fundamentals and Al-
gorithms
The purpose of this chapter is to cover some of the basic progr amming concepts you may have
picked up in previous classes while introducing you to some b asic algorithms and new terminology
that we will find useful as we continue our study of discrete ma thematics. We will also practice our
skills at writing proofs by sometimes proving that an algori thm does as specified.
Algorithms are presented in a syntax similar to Java and C++. This can be helpful since you
may already be familiar with one of these languages. On the ot her hand, this sort of syntax ties
our hands more than one often likes when discussing algorith ms. When discussing algorithms, we
often want to gloss over some of the implementation details. For instance, we may not care about
data types, or how parameters are passed (i.e. by value or by r eference), but by using a Java-like
syntax we are forcing ourselves to use particular data types and pass parameters in a certain way.
Consider an algorithm that swaps two values (we will see an im plementation of this shortly).
The concept is the same regardless of what type of data is bein g swapped. But given our choice of
syntax, we will give an implementation that assumes a partic ular data type. Most of the time the
algorithms presented can be modified to work with other data t ypes.
The issue of pass-by-value versus pass-by-reference is mor e complicated. We will have a brief
discussion of this later, but the bottom line is that wheneve r you implement an algorithm from any
source, you need to consider how this and other language-spe cific features might change how you
understand the algorithm, how you implement it, and/or whet her you even can .
5.1  Basic Syntax and Algorithms
There are various ways of defining what an algorithm is, and th ere are subtle details that matter
in certain contexts, but for our purposes, the following sim ple definition will suffice.
Definition 5.1. An algorithm is a clear and unambiguous set of instructions that accompli shes
a task in a finite amount of time.
Before we see our first algorithm, we need some notation.
Definition 5.2. The assignment operator , = , assigns to the left-hand argument the value
of the right-hand argument.
Example 5.3. The statement x = a + b means “assign to x the value of a plus the value of
b .”
Note: Most modern programming languages use = for assignment. Other symbols used include
:= , =: , << , ← , etc.
As it turns out, the most common symbol for assignment ( = ) is perhaps the most confusing
for someone who is first learning to program. One of the most co mmon assignment statements
is x = x + 1; . What this means is “assign to the x its current value plus one.” However,
what it looks like is the mathematical statement “ x is equal to x + 1 ”, which is false for every
133

134 Chapter 5
value of x . If this has tripped you up in the recent past or still does, fea r not. Eventually you
will instinctively interpret it correctly, probably forge tting you were ever confused by it.
In our algorithms, we will work with various types of data, bu t two will show up often and if you
do not know a programming language yet, they may be unfamilia r to you. An int is a variable
that stores an integer value (e.g. 45 or -123). A double or float is a variable that stores a real
number (e.g. 3.14159 or 0.8675309). Technically, these sto re approximations of real numbers, but
we won’t concern ourselves with that detail here. A boolean is a variable that can be either true
or false .
In algorithms, variables store values that we can work with.
Example 5.4. If I want to store a real number called x and have it store the va lue 5.5, I write
it as
double x = 5.5;
The “ double x ” part of the code is specifying that I want x to store a real number.  The
“ x = 5.5 ” part is specifying that I want to store the specific value 5.5 into x .
Note: In many programming languages, semicolons ( ; ) are used at the end of each statement.
Since this is not a programming class, do not worry too much ab out this.
Now we are ready for our first example of a simple algorithm. We will discuss the syntax after
presenting the algorithm since it will make more sense if we c an use an example to discuss it.
Example 5.5 (Area of a Trapezoid) . Write an algorithm that gives the area of a trapezoid
with height h and bases a and b .
Solution: One possible solution is
double TrapezoidArea( double a, double b, double h) {
return h*(a+b)/2;
}
The first line of most of our algorithms will give what is calle d a function prototype that specifies
3 important pieces of information about the algorithm:
1. What type of value/object is output by the algorithm. We wi ll often use the term returned
instead of output. They essentially mean the same thing.
2. The name of the algorithm.
3. The input to the algorithm, which we refer to as the parameters , given as a comma-separated
list between parentheses after the name. Each parameter is g iven by specifying what type of
data it is and the name we will call it in the algorithm.
In the previous example, the function prototype was
double TrapezoidArea( double a, double b, double h) {
We interpret it as follows:
1. This algorithm returns a real number (since the return typ e is double ).

Basic Syntax and Algorithms 135
2. The name of the algorithm is TrapezoidArea , which makes sense because it is computing the
area of a trapezoid.
3. The inputs/parameters are 3 real numbers, a , b , and h .
The curly brace ( { ) at the end of the first line is used to denote that everything b etween that and
the matching end curly brace ( } ) are the implementation of the algorithm. Curly braces are u sed
in general to denote blocks of code. In addition to being used in this context, they are al so used
for conditional statements and loops, as we will see later. T he simplest way to think about them
is that the are there to make it clear where a section (or block ) of code begins and ends.
The return keyword is used to indicate what value should be output/retu rned from the al-
gorithm. For instance, if someone calls x=TrapezoidArea(a, b, h) , then x will be assigned the
value h ∗ ( a + b ) / 2 since this is what was returned by the algorithm. Those who know Java , C ,
C++ , or just about any other programming language should alread y be familiar with this concept.
Example 5.6. If I execute the following code:
double a = 10.0
double b = 5.0
double h = 3.5
double x = TrapezoidArea(a,b,h);
Then the variable x will have the value (10. 0 + 5. 0) / 2. 5 = 4. 2857142857.
⋆ Exercise 5.7. Write an algorithm that returns the area of a square with side s of length s .
double areaSquare( double s) {
}
Example 5.8 (Swapping variables) . Write an algorithm that will interchange the values of
two variables, x and y . That is, the contents of x becomes that of y and vice-versa.
Solution: We introduce a temporary variable t in order to store the contents of
x in y without erasing the contents of y . For simplicity, we will assume the data is
of type Object . Here is the algorithm:
void swap(Object x, Object y) {
Object t = x; // Store x in a  temporary variable
x = y; // x now has the original value of y
y = t; // y now has the original value of x
}
Note: Note that a return type of void means that the algorithm does not return anything.
While some algorithms return values, other accomplish some task and there is no need to
return anything.
It can be very useful to be able to prove that an algorithm actu ally does what we think it does.
Then when an error is found in a program we can focus our attent ion on the portions of the code
that we are uncertain about, ignoring the code that we know is correct.

136 Chapter 5
Example 5.9. Prove that the algorithm in Example 5.8 works correctly.
Proof: Assume the values a and b are passed into swap . Then at the beginning
of the algorithm, x = a and y = b . We need to prove that after the algorithm is
finished, x = b and y = a .
After the first line, x and y are unchanged and t = a since it was assigned the value
stored in x , which is a . After the second line, x = b since it is assigned the value
stored in y , which is b . Currently x = b , y = b , and t = a . Finally, after the third
line, y = a since it is assigned the value stored in t , which is a . Since x is still b ,
and y = a , the algorithm works correctly. 
Note: The correctness of this algorithm (and a few others in this cha pter) is based on the
assumption that the variables are passed by reference rather than passed by value .
In C and C++, it is possible to pass by value or by reference, alth ough we didn’t use the
proper syntax to do so.  The * or & you sometimes see in argument lists is related to this.
In Java, everything is passed by value and it is impossible to p ass by reference.  However,
because non-primitive variables in Java are essentially re ference variables (that is, they store
a reference to an object, not the object itself), in some ways they act as if they were passed by
reference. This is where things start to get complicated. I do n’t want to get into the subtleties
here, especially since there are arguments about whether or not these are the best terms to use.
a Let me give an analogy instead.
If I share a Google Doc with you, I am passing by reference. We bo th have a reference to the
same document. If you change the document, I will see the chang es. If I change the document,
you will see the changes. On the other hand, if I e-mail you a Wo rd document, I am passing
by value. You have a copy of the document I have. Essentially, I copied the current value (or
contents) of the document and gave that to you. If you change th e document, my document
will remain unchanged. If I change my document, your document will remain unchanged. This
sounds pretty simple. However, it gets more complicated. In J ava, you can create a “primitive”
Word document, but in a sense you can’t create an “object” Wor d document. Instead, a Google
Doc is created and you are given access (i.e. a reference) to i t. This is why in some ways
primitive and object variables seem to act differently in Jav a.
I’ve already said too much. You will/did learn a lot more about this issue in another course.
Here is the bottom line: The assumption being made in the vario us swap algorithms is that when
a variable is passed in, the algorithm has direct access to that variable and not just a copy of
it. Thus if changes are made to that variable in the algorithm, it is changing the variable that
was passed in. This subtlety does not matter for most of the alg orithms here.
a http://stackoverflow.com/questions/373419/ . Inspired by a response on
Note: We should be absolutely clear that it is impossible to implement the swap method from
Example 5.8 in Java. In fact, there is no way to implement a method that swap s two arbitrary
values in Java. As we will see shortly, it is possible to implement a method that swaps two
elements from an array.

Basic Syntax and Algorithms 137
Note: One final note before we move on. Whether or not the swap method (or any method)
can be implemented, we can still use it in other algorithms as if it can. This is because when
discussing algorithms we are usually more concerned about t he idea behind the algorithm, not
all of the implementation details. Using a method like swap in another algorithm often makes it
easier to understand the overall concept of that algorithm. If we actually wanted to implement
an algorithm that uses swap in a context where it is impossible to implement, we would sim ply
need to replace the call to swap with the 3 lines of code contained in it, replacing the variab le
names as appropriate.
⋆ Question 5.10. Does the following swap algorithm work properly? Why or why n ot?
void swap(Object x, Object y) {
x = y;
y = x;
}
Answer
Example 5.11. Write an algorithm that will interchange the values of two va riables x and y
without introducing a third variable , assuming they are of some numeric type.
Solution: The idea is to use sums and differences to store the values. Assu me
that initially x = a and y = b .
void swap(number x, number y) {
// x = a+b          and   y = b x = x + y;
y = x - y; // x = a+b          and   y = a+b-b = a
x = x - y; // x = a+b-a = b   and   y = a
}
Notice that the comments in the code sort of provide a proof th at the algorithm is
correct, although keep reading for an important disclaimer .
Example 5.12. It was mentioned that the comments in the algorithm from Exam ple 5.11
provide a proof of its correctness. What possibly faulty ass umption is being made?
Solution: It is assumed that the arithmetic is performed with absolute precision,
and that is not always the case. For instance, after the first l ine we are told that
x = a + b .  What if a = 10, 000, 000, 000 and b =. 00000000001?  Will x really
be exactly 10, 000, 000, 000. 00000000001?  If it isn’t, the algorithm wi ll not work
properly.
When talking about algorithms abstractly, we often ignore t hese sorts of details,
but is is extremely important to realize when we are doing so.
5.27 explores whether or not the algorithm in Example 5.11 works for integer types– Problem
specifically 2’s complement numbers.

138 Chapter 5
Once again I want to emphasize that there can often be a huge di fference between an algorithm
as presented in a textbook and the implementation of an algor ithm in a programming language.
In this course, our focus is on the former. However, if you bec ome a programmer some day, it is
extremely important that you eventually understand some of the more subtle issues I have been
pointing out.

Remainders and Rounding Revisited 139
5.2  Remainders and Rounding Revisited
Java, C, C++, and many other languages use % instead of the wor d mod . For instance, you would
write int x = a % n instead of int x = a mod n .
Note: Recall earlier that we mentioned that a mod n has two possible values when a < 0 .
When using the mod operator in computer programs in situations where the divid end might be
negative, it is important to know which definition your progr amming language/compiler uses.
Java returns a negative number when the dividend is negative. In C , the answer depends on
the compiler.
⋆ Exercise 5.13. If you write a C program that computes − 45 mod 4, what are the two
possible answers it might give you?
Answer
The next exercise explores a reasonable idea: What if we want the answer to a mod b to always
be between 0 and b − 1, even if a is negative? In other words, we want to force the correct posi tive
answer even if the compiler for the given language might retu rn a negative answer.
⋆ Evaluate 5.14. Although different programming languages and compilers migh t return
different answers to the computation a mod b when a < 0, they always return a value between
− ( b − 1) and b − 1.  Given that fact, give an algorithm that will always return an answer
between 0 and b − 1, regardless of whether or not a is negative. Try to do it without using any
conditional statements.
Solution   1: Use  (a   (mod  b) + b − 1) / 2.   Since  it  always  returns  a  value  between
− (b − 1)   and  b − 1   by  adding   b − 1  to   both  sides   you   get  a   value   between  0  and
2b − 2.   You  then  divide   by  2  to  hit   the  target  range  of  a  return  value   that
is   between  0  and  b − 1   whether   the   number   is   positive   or   negative.
Evaluation
Solution   2: Just   return  the   absolute   value   of   a  mod  b.
Evaluation

140 Chapter 5
Solution   3: Use   the  following:
int c = a % b;
if (c<0) {
return -c;
} else {
return c;
}
Evaluation
Solution   4: Use  (a  mod  b)  mod  b.
Evaluation
⋆ Exercise 5.15. Devise a correct solution to the Evaluate 5.14 .
Answer:
⋆ Evaluate 5.16. Implement an algorithm that will round a real number x to the closest
integer, but rounds down at .5 . You can only use numbers, basic arithmetic (+, –, *, /), and
floor(y) and/or ceiling(y) (which correspond to ⌊ y ⌋ and ⌈ y ⌉ ). Don’t worry about the data
types (i.e. returning either a double or an int is fine as long as the value stored represents an
integer value).
Solution   1: return floor(x+.49) .
Evaluation

Remainders and Rounding Revisited 141
Solution   2: return floor(x+1/2) .
Evaluation
Solution   3: return ceiling(x+.5) .
Evaluation
Solution   4: return ceiling(x-.5) .
Evaluation
The floor function is important because in many programming l anguages, including Java, C,
and C++, integer division truncates . That is, when you compute n/k for integers n and k , the
result is rounded so it is closer to zero (as opposed to rounding down). That means that if n , k ≥ 0,
n/k rounds down to ⌊ n/k ⌋ . But if n < 0, n/k rounds up to ⌈ n/k ⌉ . So in Java, C, and C++,
3 / 4 = − 3 / 4 = 0, 11 / 5 = 2 and − 11 / 5 = − 2, for instance.
⋆ Exercise 5.17. Compute each of the following, assuming they are expression s in Java, C,
or C++.
(a) 9/10 = (e) 15/10 = (i) -5/10 =
(b) 10/10 = (f) 19/10 = (j) -10/10 =
(c) 11/10 = (g) 20/10 = (k) -15/10 =
(d) 14/10 = (h) 90/10 = (l) -20/10 =

142 Chapter 5
⋆ Evaluate 5.18. Let n and m be positive integers with m > 2. Assuming integer division
truncates, write an algorithm that will compute n/m , but will round the result instead of
truncating it (round up at or above . 5, down below . 5). For ins tance, 5 / 4 should return 1,
but 7 / 4 should return 2 instead of 1. You may only use basic integer a rithmetic, not including
the mod operator.
Solution   1: floor(n/m+0.5)
Evaluation
Solution   2: floor((n/m) + 1/2)
Evaluation
Solution   3: (int) (n/m+0.5)
Evaluation
Although the previous example may seem like it is based on an u nnecessary restriction, this is
taken from a real-world situation. When writing code for an e mbedded device (e.g. a thermostat
or microwave oven), code space is often of great concern.  Per forming just a single calculation
using doubles/floats can add a lot of code since it needs to add certain code to deal with the data
type. Sometimes the amount of code added is too much since emb edded processors have a lot less
space than the processor in your laptop or desktop computer. Because of this, some embedded
programmers do everything they can to avoid all non-integer computations in their code when it
is possible.
⋆ Exercise 5.19. Give a correct solution to round-instead-of-truncate prob lem from the pre-
vious example.
Answer:

If-Else Statements 143
5.3 If-Else Statements
Conditional statements allow an algorithm to do one of various things based on some co ndition. In
this section we introduce the most common conditional statement : the if-else statement.
Definition 5.20. The if-else control statement has the following syntax:
if (expression) {
blockA
} else {
blockB
}
where expression must evaluate to a boolean value, and blockA and blockB are 0 or more
statements (so they can be blank). If expression is true then the statements in blockA are
executed. Otherwise, the statements in blockB are executed.
Example 5.21. Write an algorithm that will determine the maximum of two int egers. Prove
your algorithm is correct.
Solution: The following algorithm will work.
int max( int x, int y) {
if (x  >= y) {
return x;
} else {
return y;
}
}
There are three possible cases. If x > y , then x is the maximum, and it is returned
since the algorithm returns x if x ≥ y . If x = y , then they are both the maximum,
so returning either is correct. In this case it returns x , the correct answer. If x < y ,
then y is the maximum and the algorithm returns y , which is the correct answer.
In any case it returns the correct answer.
⋆ Exercise 5.22. Write an algorithm that will determine the maximum of three n umbers that
5.21 . Prove that your algorithm is correct. uses the algorithm from Example
int max( int x, int y, int z) {
}
Proof

144 Chapter 5
The previous exercise is an example of something that you are already familiar with: code reuse .
We could have written an algorithm from scratch, but sometimes it is easie r to use one that already
exists. Not only is the resulting algorithm simpler, it is ea sier to prove that it is correct since we
know that the algorithm it uses is correct.
Example 5.23. Write an algorithm that determines whether a given integer i s between two
other integers. Have it return a boolean type (which is a variable type that can be either true
or false , as the name suggests).
Solution: Here is one possible solution:
int lo, int ho, in val) { boolean isBetween(
if (lo < val && val < hi) {
return true;
else {
return false;
}
}
Some people might prefer the conditional to be if(val > lo && val < hi) , which
is also perfectly fine.
In many programming languages, we can use the following shor thand version.
boolean isBetween( int lo, int ho, in val) {
return (lo < val && val < hi);
}
This is because the result of the boolean expression turns ou t to be equal to what
we want to return in each case. That is, when lo < val && val < hi is true , we
want to return true , and if it is false , we want to return false . So we can just
ditch the conditional statement in this case!
For simplicity, we will sometimes use print to output results and not worry about whitespace
(i.e. spaces and newlines). Think of it as being equivalent t o Java’s System.out.print(i+" ") or
C++’s cout< 0, b > 0, and c > 0. Also, the sum of any two of
them must be larger than the third in order to form a triangle. More specifically,
we need a + b > c , b + c > a , and c + a > b . Since we need all of these to be true,
this leads to the following algorithm.
int a, int b, int c) { IsItATriangle(
if (a>0 && b>0 && c>0 && a+b>c && b+c>a && a+c>b) {
return true;
else { return false; } }
}

Logic in programming 147
5.4  Logic in programming
There are often times when conditional expressions can be si mplified using logic. You are going to
2.3 while reading this section. Let’s start with a simple exampl e. want to refer back to Table
Example 5.29. The conditional statement if(!(x<0)) can be rewritten as if(x>=0) to make
it more readable.
Too easy. Let’s try a slightly more complicated one.
Example 5.30. Simplify the following code.
if (x<=0 && (x>0 || x <=0)) {
x=0;
}
Solution: If we let p be “ x<=0 ,” then ¬ p is “ x>0 ,” and the conditional statement
is equivalent to p ∧ ( ¬ p ∨ p ).  But using negation and identity, we can see that
p ∧ ( ¬ p ∨ p ) = p ∧ T = p . Thus, the code can be simplified to
if (x <=0) {
x=0;
}
That wasn’t so bad. Now we can do one that is a little trickier. Pay attention on this one!
Example 5.31. Simplify the following code as much as possible.
if ( !(x==0 || y=x . Thus, the
code becomes:
if (x!=0 && y>=x) {
x=y
}
This may not look much simpler, but it is definitely easier to u nderstand.
This simplification can also be done by defining p to be x==0 and q to be y0 && x0 && x>=y)) {
x=y;
}
⋆ Evaluate 5.33. Simplify the following code as much as possible.
if (x>0) {
if (x0) {
x=y;
}
}
Solution:    Because   the   second   if   is   in   the   first   one   which   is   if   (x > 0)
then  x > 0  is  duplicated  but  at  the  same  time  to  satisfy  the  second  one
we   just   need   to   keep   the   second   if   and   cut   the   first   one. x < y   and
x > 0   are   independent   conditions   so   they   cannot   be   more   simplified.
So  the   answer   is:
if (x0) {
x=y;
}
Evaluation

Logic in programming 149
⋆ Exercise 5.34. Simplify the following code as much as possible.
if (x>0) {
if (x0) {
x=y;
}
}
Although some of these examples may seem a bit contrived, in s ome sense they are realistic.
As code is refactored, code is added and removed in various pl aces, conditionals are combined
or separated, etc.  and sometimes it leads to conditionals th at are more complicated than they
need to be. In addition, when working on large teams, you will often work on code written by
others.  Since some programmers don’t have a good grasp on log ic, you will certainly run into
conditional statements that are way more complicated and co nvoluted than necessary. As I believe
these examples demonstrate, simplifying conditionals is n ot nearly as easy as one might think. It
takes great care to ensure that your simplified version is sti ll correct.
Note: There is an important difference between the logical operator s as discussed here and how
they are implemented in programming languages such as Java, C, and C++. It is something
that is sometimes called short circuiting . You may be familiar with the concept even if you
haven’t heard it called that before. It exploits the domination laws:
F ∧ q = F
T ∨ q = T
Example 5.35. Consider the following algorithm:
if (x<0 || y<0) {
x=y;
}
The conditional statement here involves an or ( p ∨ q ). Notice that when x < 0, then because of
the or , the conditional statement is true regardless of what the va lue of y is. Most programming
languages with therefore not even check the second part of th e conditional in this case.
In general, when executing a conditional statement of the fo rm p ∨ q , p is evaluated first.
If it is true, the conditional is evaluated as true without de termining the truth value of q . If p
is false, then then q is evaluated and its truth value used.

150 Chapter 5
⋆ Exercise 5.36. Based on how short circuiting works with conditionals of the form p ∨ q ,
explain what it does with conditionals of the form p ∧ q .
Note: If you forget that code short circuits, bad things can occasio nally happen. Because of
short circuiting, some of the code in your conditional state ment may never execute. The vast
majority of the time that is fine. However, there are rare case s when it might cause a problem.
Here is a simple example. Say you want to increment both x and y , and then check if either is
at least 100. Most sensible people would implement it like th is:
x++;
y++;
if ( x==100 || y==100) {
// do  something
}
That code will always work just fine. Alternatively, you can tr y to be clever and do this (but
don’t! Keep reading):
if ( ++x==100 || ++y==100) {
// do  something
}
First notice that the ++ comes before the variable, so each variables is incremented before
being compared to 100, which is what we want. However , if x becomes 100, then short circuiting
means that y will never get incremented, and that is incorrect!
Although this is a rather contrived example, there are certa inly cases where this comes up
in real code, especially when dealing with certain types of d ata structures.
Below is a more complicated example involving short circuit ing. Earlier examples did not make
demonstrate the advantages to short circuiting, other than skipping the execution of a little code,
but it is very important in several contexts.  The one in the ne xt example involves checking if
something exists before trying to access it. This helps to av oid things like segmentation faults (C,
C++), IndexOutOfBoundsException (Java), and null pointers (many languages).
The example below uses a list , which is exactly what it sounds like–an ordered list of 0
or more items of some sort (the list in the example contains in tegers).  If you have a list, call-
ing list.isEmpty() will return true if the list is empty and false if it is not empty. Calling
list.get(i) will get the i th element from the list (where we use 0 to get the first element , 1
for the second, etc., for reasons I do not wish to get into righ t now). If there is no i th element,
list.get(i) will crash the program or return some bogus value, depending on how the list was
implemented. This means it is important to know that an item e xists in a list before trying to
access it. This leads to the next example.

Logic in programming 151
⋆ Evaluate 5.37. Rewrite the following segment of code so that it is as simple a s possible
and logically equivalent.
if ( !(list.isEmpty() && list.get(0) >=100) && !(list.get(0) <100) ) {
x++;
else { }
x--;
}
Solution   1: The   second   and   third   statements   mean   the   same   thing. Also, if
the  second  is  true  then  we  got  a  value  so  we  know  the  list  is  not  empty,  so
the   first   statement   is   unnecessary. This   leads   to   the   following   equi valent
code:
if (list.get(0)  >= 100) {x++;} else {x--;}
Evaluation
Solution   2: I  used   DeMorgan’s   law   to   obtain:
if (!list.isEmpty() || list.get(0) < 100) {
x++;
else { }
x--;
}
Evaluation
Solution   3: Let    a    be list.isEmpty() and    b    be list.get(0)>=100 . But    then
¬ b  = list.get(0)<100 .   The   original   expression   is ¬ (a ∧ b) ∧¬ ( ¬ b).   But
¬ (a ∧ b) ∧¬ ( ¬ b) = ¬ (a ∧ b) ∧ b  =  ( ¬ a ∨¬ b) ∧ b
= ( ¬ a ∧ b) ∨ ( ¬ b ∧ b)  =  ( ¬ a ∧ b) ∨ F  = ¬ a ∧ b
So  my  simplified   code   is
if ( !list.isEmpty() && list.get(0) >= 100 ) {
x++;
else { }
x--;
}
Evaluation

152 Chapter 5
⋆ Question 5.38. In the solutions to the previous problem we said that the final solution was
correct. But there might be a catch. Go back to the original co de and the final solution and
look closer. Is the final solution really equivalent to the original? Explain why or why not.
Evaluation
Let’s reinforce the point from the previous question. The co de from the third solution and the
original code are logically equivalent. However, they are not actually equivalent when implemented
in most programming languages. Why? Because of short circui ting. What happens when you call
get on an empty list? Does it return some bogus value? Or crash? Ei ther way, the original code
will either crash or return a bogus value. However, the code f rom the third solution will always
work correctly because short circuiting prevents the call t o the get that would cause the problem.

Bitwise Operations 153
5.5  Bitwise Operations
In this section we will consider bitwise operations . But first we need to review a few concepts you
are probably already familiar with.
Recall that a boolean variable is one that is either true or false.  Recall that a bit can have
the value 0 or 1. A bit can be used to represent a Boolean variab le by assigning 0 to false and 1
5.1 shows the truth tables for the various boolean operators tha t are available in to true. Table
many languages. Notice that they are identical to the operat ors we discussed earlier except that
we have replaced T and F with 1 and 0 and have used the notation from Java/C/C++ instea d of
the mathematical notation.
AN D OR XOR IF F
p   q ( p && q ) ( p || q ) p ! = q ( p == q )
1  1 1 1 0 1
1  0 0 1 1 0
0  1 0 1 1 0
0  0 0 0 0 1
Table 5.1: Truth Tables for the Boolean Operators
We don’t usually think about != being XOR and == being IFF (or biconditional). We usually
think of them in their more natural interpretation: ‘not equ al’ and ‘equal’.
Note: A note of caution: Although Java is a lot like C and C++, how it de als with logical
expressions is very different. Java has an explicit boolean type and you can only use the logical
operators on boolean values. Further, conditional stateme nts in Java require boolean values. In
C and C++, the int type is used as a boolean value, where 0 is false, and anything else is true.
This is very convenient, but can also cause some confusion.
Example 5.39. In C/C++, (5&&6) , (5||0) , (4!=5) are all true.  In Java the first two
statements are illegal.
Now it’s time to extend the concept of boolean operators to in teger data types (including int ,
short , long , byte , etc.).
Definition 5.40. A bitwise operation is a boolean operation that operates on the individual
bits of its argument(s).
Definition 5.41. The complement or bitwise NOT , usually denoted by ~ , just flips each
bit.
Example 5.42. Assume 10011001 is in binary. Then ~10011001=01100110 . If this were a
32-bit integer, the answer would be 11111111111111111111111101100110 since the leading 24
bits (which we assume to be 0) would be flipped.

154 Chapter 5
Note: For simplicity, the rest of the examples will assume numbers are represented with 8 bits.
The concept is exactly the same regardless of how many bits are used for a particular data type.
⋆ Fill in the details 5.43. 255 is 11111111 in binary. ~11111111=00000000 , which is 0 in
decimal. Therefore, ~255=0 .
in binary, and Similarly, we can see that ~240=15 since 240 is
~ = , which is in decimal.
⋆ Exercise 5.44. ~11000110 =
Definition 5.45. The following are the two-operator bitwise operators.
• Bitwise AND , denoted by & , applies ∧ to the corresponding bits of each argument.
• Bitwise OR , denoted by | , applies ∨ to the corresponding bits of each argument.
• Bitwise XOR , denoted by ^ , applies ⊕ to the corresponding bits of each argument.
We will present examples in table form rather than ‘code form ’ since it is much easier to see
what is going on when the bits are lined up.
Example 5.46. 01011101 01011101 01011101
& 11010100 | 11010100 ^ 11010100
01010100 11011101 10001001
Note: It is important to remember that & and && are not the same thing! The same holds for
| and || . It is equally important to remember that ^ does not mean exponentiation in most
programming languages.
⋆ Exercise 5.47. 11110000 11110000 11110000
& 11001100 | 11001100 ^ 11001100
Note: Remember: boolean operators and the bitwise operators are d ifferent!

The for loop 155
5.6  The for loop
Here is the first of the two types of loops we will consider.
Definition 5.48. The for loop has the following syntax:
for (initialize;condition;increment) {
blockA
}
where
• initialize is one or more statements that set up the initial conditions a nd is executed
once at the beginning of the loop.
• condition is the condition that is checked each time through the loop. It must evaluate
to a boolean value. If condition is true, the statements in blockA are executed followed
by the code in increment . This process repeats until condition is false.
• increment is code that ensures the loop progresses. It is executed at the end of every
loop. Typically increment is just a simple increment statement (e.g. i++ ), but it can be
anything.
Example 5.49. Write an algorithm that returns n ! when given n .
Solution: Here is one possible algorithm.
int factorial( int n) {
if (n==0) { return 1;
} else {
int fact = 1;
for ( int i=1;i<=n;i++) {
fact = fact*i;
}
return fact;
}
}
⋆ Question 5.50. Does the factorial algorithm from Example 5.49 ever do something un-
expected? If so, what does it do, when does it do it, and what sh ould be done to fix it?
Answer

156 Chapter 5
⋆ Evaluate 5.51. Evaluate these algorithms that supposedly compute n ! for values of n > 0.
Don’t worry about what they do when n ≤ 0.
Solution   1:
int fact = 1;
for ( int i=0;i<=n;i++) {
fact = fact*i;
}
return fact;
Evaluation
Solution   2:
int fact = 1;
for ( int i=2;i<=n;i++) {
fact = fact*i;
}
return fact;
Evaluation
Solution   3:
int fact = 1;
for ( int i=n;i>0;i--) {
fact = fact*i;
}
return fact;
Evaluation
Solution   4:
int fact = 1;
for ( int i=1;imax) {
max = X[i];
}
}
return max;
}
If your primary language is Java, you might wonder why we did n ot use X.length in the
previous algorithm. There are two reasons. First, not all la nguages store the length of an array as
part of the array. For example, C and C++ do not. In these langu ages you always need to pass
the length along with an array. Second, sometimes you want to be able to process only part of an
array. Written as we did above, the algorithm will return the maximum of the first n elements of
an array. The algorithm works as long as the array has at least n elements.

Arrays 159
Note: If an algorithm has an array and a variable n as parameters, you can probably assume
n is the length of the array unless it is otherwise specified.
⋆ Exercise 5.55. Give an algorithm that will return true if an array of integer s either starts
or ends with a 0, and false otherwise. Assume array indexing s tarts at 0 and that the array
is of length n . Use only one conditional statement. Be sure to deal with the possibility of an
empty array.
int [] a, int n) { boolean startsOrEndsWithZero(
}
⋆ Question 5.56. Does the solution given for the previous exercise properly d eal with arrays
of size 0 and 1? Prove it.
Answer
Example 5.57. Implement a method that swaps two elements of an array that wo rks in Java
and other languages that can’t pass by reference.
Solution: Here is a method that swaps two elements of an integer array. Except
for the type of the parameter and temp variable, this works for any data type.
swap( int [] X, int a, int b) {
int temp = X[a];
X[a]=X[b];
X[b]=temp;
}
I don’t want to get into the technical details of pass-by-val ue versus pass-by-
reference since that is really the subject of another course . But briefly, this works
because when the array is passed we have access to the individ ual array elements.
Therefore when we change them, they are changed in the origin al array.

160 Chapter 5
Example 5.58. An array ( X [0], . . . X [ n − 1]) is given. Without introducing another array, put
its entries in reverse order.
Solution: Observe that we want to exchange the first and last element, th e second
and second-to-last element, etc. That is, we want to exchang e X [0] ↔ X [ n − 1],
X [1] ↔ X [ n − 2], . . . , X [ k ] ↔ X [ n − k − 1]. But what value of k is correct? If we
go all the way to n − 1, the result will be that every element is swapped and then
swapped back, so we will accomplish nothing. Hopefully you c an see that if we swap
elements when k < n − k − 1, we will swap each element at most once. The “at most
once” is because if the array has an odd number of elements, th e middle element
occurs when k = n − k − 1, but we can skip it since it doesn’t need to be swapped
with anything. Notice that k < n − k − 1 if and only if 2 k < n − 1. Since k and n
are integers, this is equivalent to 2 k ≤ n − 2. This is equivalent to k ≤⌊ ( n − 2) / 2 ⌋
by Corollary 4.82 . Thus, we need to swap the elements 0, 1, . . . , ⌊ ( n − 2) / 2 ⌋ with
elements n − 1, n − 2, . . . , n − 1 −⌊ ( n − 2) / 2 ⌋ = n −⌊ n/ 2 ⌋ , respectively. The following
algorithm implements this idea.
int [] X, int n) { reverseArray(
for ( int i=0;i<=(n-2)/2;i++) {
swap(X,i,n-i-1);
}
}
⋆ Question 5.59. The previous algorithm went until i was ( n − 2) / 2, not ⌊ ( n − 2) / 2 ⌋ . Why
is this O.K.? Does it depend on the language? Explain.
Answer
⋆ Question 5.60. Does the following algorithm correctly reverse the element s of an array?
Explain.
reverseArray( int [] X, int n) {
for ( int i=0;i=a.length , the expression in the if statement will evaluate to false
regardless of the truth value of a[x]!=0 . Therefore, many languages will simply not evaluate
the second part of the expression—they will short circuit , as we have discussed previously. And
it turns out that this is a very good thing! If short circuiting did not occur, that code would
crash whenever x>=a.length (If you do not see why, look back and try to figure it out). That
is one of the reasons many languages use short circuiting.
a On If x=a.length , the condition is guaranteed to be false, so we short circuit and

Arrays 163
never check the second condition which is good, because it would cause the code to crash!
Therefore, even though the statements if(x1) {
if (n*i>4) {
x=x+2*n;
else { }
x=x+n;
}
n=n-2;
i++;
}
return x;
}

The while loop 169
Answer
An interesting example of the use of a while loop is implement ing a simple algorithm to deter-
mine whether or not a positive integer is prime.
Theorem 5.79. Let n > 1 be a positive integer. Either n is prime or n has a prime factor no
√
n . greater than
Proof: If n is prime there is nothing to prove. Assume that n is composite. Then
n can be written as the product n = ab with 1 < a ≤ b , where a and b are integers.
√ √ √
If every prime factor of n were greater than n , then a > n and b > n . But
√ √
n n = n , which is a contradiction. Thus n must have a prime then n = ab >
√
factor no greater than n . 
Example 5.80. To determine whether 103 is prime we proceed as follows.  Obse rve that √
⌊ 103 ⌋ = 10 (According to Theorem 4.81 , we only need concern ourselves with the floor). We
now divide 103 by every prime no greater than 10. If one of thes e primes divides 103, then
103 is not a prime. Otherwise, 103 is a prime. Notice that 103 m od 2 = 1, 103 mod 3 = 1,
103 mod 5 = 3, and 103 mod 7 = 5. Since none of these remainders is 0, 103 is prime.
⋆ Exercise 5.81. Give a complete proof of whether or not 101 is prime.
Proof
⋆ Exercise 5.82. Give a complete proof of whether or not 323 is prime.
Proof
Example 5.83. Give an algorithm to determine if a given positive integer n is prime.
Solution: We first deal with a few base cases. If n = 1, it is not prime. Otherwise,
√
loop through all of the values, starting with 2 and going to n , determining whether
or not n is a multiple of any of them. If so, it is not prime. If we get thr ough all of
√
n which means it must be prime. this, then n has no factors less than or equal to
Here is the algorithm based on this description.

170 Chapter 5
boolean isPrime( int n) {
if (n <=1) { //  Anything less than 2 is not prime.
return false;
} else {
int i = 2;
while ( i  <= sqrt(n) ) {
if ( n%i==0 ) {
return false;
}
i++;
}
return true; // It had no  factors.
}
}
⋆ Exercise 5.84. Improve the algorithm from the previous example by making it about twice
as fast. Hint: The fact that I am asking you to make it twice as fast is a hint.
Note: It should be noted that although this algorithms in the last ex ample and exercise work,
they are not very practical for large values of n . In fact, there is no known algorithm that
can factor numbers efficiently on a “classical” computer. The m ost commonly used public-key
cryptosystems rely on the assumption that there is no efficien t algorithm to factor a number.
However, if you have a quantum computer, you are in luck. Shor ’s algorithm actually can
factor numbers efficiently.
Can we do the same thing for multiples of 3, 5, etc. to make the a lgorithm even faster? That
is, once we know that a number is not divisible by 3, we don’t re ally need to ask if it is divisible
by 6, 9, 12, etc. Similarly for 5, 7, 11, etc. Can we somehow mak e it skip all of these multiples as
we go? A first step would be to try to skip just multiples of eith er 2 or 3 (or both). If you can do
that, you can then take into account 5, etc. But does it genera lize? And would it help? I will leave
these as questions for you to ponder.

The while loop 171
⋆ Exercise 5.85. Use the fact that integer division truncates to write an algo rithm that
reverses the digits of a given positive integer. For example , if 123476 is the input, the output
should be 674321. You should be able to do it with one extra var iable, one while loop, one
mod operation, one multiplication by 10, one division by 10, and one addition.
int reverseDigits( int n) {
}

172 Chapter 5
5.10  More fun with Algorithms
Let’s start with an example of how understanding sets and set operations can help understand how
certain data structures work.
Example 5.86. In Java, the TreeSet class is one implementation of a set that has several
methods with perhaps unfamiliar names, but they do what shou ld be familiar things. Let’s
a discuss a few of them. Let A and B be TreeSet s.
(a) The method retainAll(TreeSet other) “ retains only the elements in this TreeSet that
are contained in the other TreeSet. In other words, removes from this TreeSet all of its e l-
ements that are not contained in other . ” It is not too difficult to see that A.retainAll(B)
b is computing A ∩ B .
(b) The method boolean containsAll(TreeSet other) “ returns true if this set contains all
of the elements of other (and false otherwise). ” Thus, A.containsAll(B) returns true iff
B ⊆ A .
(c) Even without documentation, it seems likely that A.size() is determining | A | .
(d) It also seems likely that A.isEmpty() is determining if A = ∅ .
a The method signatures and documentation have been modified f rom the official definition so we can focus
on the point at hand.
b Technically it is doing more than that. It is storing the resu lt in A . So it is like it is doing A = A ∩ B , where
= here means assignment, not equals.
n Here is a more advanced use of the while loop to compute exponents ( x ) more quickly than
5.52 . using a simple for loop as was done in Example
Example 5.87 (Faster Exponentiation) . Write an algorithm that is more efficient than the
n one from Example 5.52 to compute x , where x is a given real number and n is a given positive
integer.
Solution: The solutions from Example 5.52 requires about n − 1 multiplications.
Here we give a solution that requires no more than 2 log n multiplications, which 2
is significantly better! We’ll start with an example and then describe the process
in more general terms.
Let n = 11. We can write n = 8 + 2 + 1, which is just expressing n as a sum of
powers of 2. In other words, we express n in terms of its binary representation.
11 8+2+1 8 2 1 8 2 1 Then x = x = x x x . So if we can compute x , x , and x , then we only
11 need 2 more multiplications to get x . Notice that we can successively square x ,
2 4 8 giving the sequence x → x → x → x using just 3 more multiplications. So we can
11 compute x using only 5 multiplications instead of 10. Notice that 5 < 2 log 11.
2
n In general, we start by writing n in binary. We then express x in terms of the
binary representation of n . We then successively square x getting a sequence
k 2 4 8 2
, x → x → x → x →···→ x

More fun with Algorithms 173
k k +1 and we stop when 2 ≤ n < 2 . As we go, we multiply our answer by the current
power of x . Here is an implementation of this idea.
double power( double x, int n) {
double ans = 1;
double pow = x; // Stores x, x^2, x^4, etc.
int k = n;
while ( k!=0) {
if (k%2==0) {
k=k/2;
pow=pow*pow;
} else {
k=k-1;
ans=ans*pow;
}
}
return ans;
}
⋆ Exercise 5.88. Trace through the execution of power(2,23) . Give a table with the values
of k , pow , and ans at every step. How many steps did it take? Was it more efficient t han the
algorithm from Example 5.52 ? Did it use as few operations as we promised?
k pow ans
Now we will see some examples of how partitions and equivalen ce relations are relevant to
4.4 . algorithms. Feel free to skip the rest of this section if you d id not cover Section
When creating test cases for an algorithm, you always want to ensure that you are covering
‘all of the cases’. But what does that mean? It means you are th inking about how to partition all
of the possible inputs into several sets, where the elements in one set are somehow different from
those in another set, and are quite a lot like the other elemen ts in the set. Let’s see an example.

174 Chapter 5
Example 5.89. Consider the following function that returns n ! if n ≥ 0, and returns − 1 if
n < 0 ( n ! is undefined for negative values of n , but we have to return something, so why not a
negative number?)
int factorial( int n) {
if (n<0)         { return -1; }
else if (n==0) { return 1; }
else {
int fact = 1;
for ( int i=1;i<=n;i++) {
fact = fact*i;
}
return fact;
}
}
What values of n should we use to test factorial ?
Solution: There seems to be three different types of values based on the st ructure
of the code: 0, numbers less than 0, and numbers greater than 0 . This suggests
partitioning the possible test cases into these 3 classes. I f we test at least one number
from each of these, we know we have covered the code in the if , else if , and else
clauses. Since boundaries can sometimes cause problems, we should include those
for each part as well as an arbitrary value in each part. In lig ht of this, we might test
0, − 1, − 2, − 10, 1, 2, and 8. Since these cover all of the cases, they should provide
a pretty good evidence of whether or not factorial is implemented properly.
a But remember, testing never proves that code is correct!
It might be helpful to see another example of where equivalen ce relations and partitions are
useful in computer science.
Example 5.90. Consider a method setRewardChance(double chance) that sets the percent-
age chance that a player will be rewarded for completing some task. When the chance is set,
we may want to take some action based on the value. For instanc e, the chance should certainly
be non-negative, so we might want to throw some sort of error i f it is negative. Similarly, the
chance should not be above 100 (We are assuming the values are being interpreted as whole
percentages, so 100 means 100%). We may also want to treat the case of a 0% chance in a
special way. Further, chance below 20%, between 20 and 50% an d above 50% might all be
treated in different ways. This might lead to code such as the fo llowing.
setRewardChance( double chance) {
if (chance <0)           { /* Throw  an error  */ }
else if (chance ==0)    { /* deal  chance ==0 */ }
else if (chance <20)    { /* deal  with 0= 100 ) {
list.clear();
}
⋆ Question 5.11. Simplify the conditional statement if( !(x<=0 || y<=0) ) as much as possi-
ble.

Reading Comprehension Questions 177
From Section 5.5
⋆ Question 5.12. Assume x and y are integers stored on a computer using 8 bits. Let x = 37
(00100101 in binary), y = 112 (01110000 in binary). Compute ~ x , x & y , x | y , and x ^ y . Give your
answers in both binary and decimal.
5.6 From Section
⋆ Question 5.13. Exactly how many times does the following loop execute?
for ( int i=1;i=0 && i=0) .  Are they equivalent in most programming lan-
guages?  Explain why or why not.  If they are not equivalent, ex plain exactly how they differ.
In particular, is one right and one wrong, or do they accompli sh different goals?
5.8 From Section
Question 5.19. Let A be an array. Consider the statement ∀ x ( A [ x ]! = 0), where the universe ⋆
of discourse is { 0, 1, . . . , n − 1 } .
(a) Rephrase the statement in English.
(b) Write a function boolean foo(int []A, int n) that computes and returns the truth value
of the statement.
(c) What is a better name for foo ? In other words, what does it do?
⋆ Question 5.20. Let A be an array. Consider the statement ¬∃ x ( A [ x ] == 0), where the universe
of discourse is { 0, 1, . . . , n − 1 } .
(a) Rephrase the statement in English.

178 Chapter 5
(b) Write a function boolean bar(int []A, int n) that computes and returns the truth value
of the statement.
(c) What is a better name for bar ? In other words, what does it do?
⋆ Question 5.21. Given an array a of length n , give an algorithm that will determine the truth
value of ∀ x (( a [ x ] is even ) ∨ ( a [ x ] is a multiple of 3)).
From Section 5.9
⋆ Question 5.22. Rewrite the code from Questions 5.13 using a while loop.
⋆ Question 5.23. Rewrite the code from Questions 5.17 using a while loop that does not contain
a return statement in the loop.

Problems 179
5.12  Problems
Note: For the remainder of the book, whenever a problem asks for an a lgorithm, always assume
it is asking for the most efficient algorithm you can find. You wi ll likely lose points if your
algorithm is not efficient enough. We will use our intuitive de finition of efficient until we study
7 . algorithm analysis in Chapter
Problem 5.1. You are helping a friend debug the code below. He tells you “Th e code in the if
statement never executes. I have tried it for x=2 , x=4 , and even x=-1 , and it never gets to the code
inside the if statement.”
if ((x%2==0 && x<0) || !(x%2==0 || x<0)) {
// Do  something.
}
(a) Is he correct that the code inside the if statement does no t execute for his chosen values?
Justify your answer.
(b) Under what conditions, if any, will the code in the if stat ement execute?  Be specific and
complete.
Problem 5.2. Simplify the following code as much as possible:
if (x<=0 && x>0) {
doSomething();
else { }
doAnotherThing();
}
Problem 5.3. Simplify the following code as much as possible. (It can be si mplified into a single
if statement that is about as complex as the original outer if statement).
if ( (!x.size() <=0   && x.get(0)!=11) || x.size() >0 ) {
if ( !(x.get(0)==11 && (x.size() >13 || x.size() <13) )
&& (x.size() >0 || x.size()==13) ) {
// Do a few things.
}
}
Problem 5.4. Implement the swap operation for integers without using an a dditional variable and
without using addition or subtraction. (Hint: bit operatio ns)
Problem 5.5. Prove or disprove that the following method correctly compu tes the maximum of
two integers x and y , assuming that the minimum method correctly computes the minimum of x
and y .
int maximum( int x, int y) {
int min = minimum(x,y);
int max = x + y - min;
return max;
}
Problem 5.6. Give an algorithm int sumLarge(int []a,int n,int k) (where a is an array
with n elements) that returns the sum of all of the elements from the array a that are at least k
(as in a [ i ] ≥ k , not whose index is at least k ).

180 Chapter 5
Problem 5.7. Let a be an array with n elements. Give an algorithm int sum(int []a,int n)
that returns the sum of all of the elements from the array a .
Problem 5.8. Let a be an array with n elements. Give an algorithm that returns true if and only
if the elements of a are in increasing order. That is, if i < j , then a [ i ] ≤ a [ j ]. Call your algorithm
boolean increasing(int []a,int n) . (Hint: You do not have to check that a [ i ] ≤ a [ j ] for every
i < j . What is a simpler thing to check that is equivalent to this?)
Problem 5.9. Let a be an array with n elements. Give an algorithm sort(int []a,int n) that
sorts the elements of the array a in increasing order.
Problem 5.10. Let a be an array with n elements and assume that a [ i ] is the number of people
in room i of a hotel. The hotel can have at most capacity total guests. If they have too many
guests, they have to kick guests out in reverse order of room n umber (so larger room numbers get
kicked out first). Give an algorithm int tooMany(int []a,int n, int capacity) that returns
the room number k such that some or all guests in room k and all guests in rooms k +1 and beyond
must vacate; or -1 if there is enough space for everybody.
Problem 5.11. Give a recursive algorithm that computes n !. You can assume n ≥ 0.
Problem 5.12. Let a be an array with n elements. Give an algorithm mod(int []a,int n,int k)
that replaces each element a [ i ] from the array a with a [ i ] mod k .
Problem 5.13. Consider the following code.
int x, int y) { boolean notBothZero(
if (!(x==0 && y==0)) {
return true;
} else {
return false;
}
}
int x, int y) { boolean unknown1(
if (x!=0 && y!=0) {
return true;
} else {
return false;
}
}
int x, int y) { boolean unknown2(
if (x!=0 || y!=0) {
return true;
} else {
return false;
}
}
(a) Is unknown1 equivalent to notBothZero ? Prove or disprove it.
(b) Is unknown2 equivalent to notBothZero ? Prove or disprove it.
(c) Are unknown1 and unknown2 equivalent to each other? Prove or disprove it.

Problems 181
Problem 5.14. The following method returns true if and only if none of the en tries of the array
are 0:
boolean noZeroElements( int [] a, int n) {
for ( int i=0;i0) {
for ( int i=1;i<=n;i++) {
for ( int j=i;j<=n;j++) {
x = x + i*j;
}
}
n--;
}
return x;
}
5.18 had the conditions that n > 0 and m > 2. Also recall Problem 5.18. Recall that Example
that you gave a solution to this in Exercise 5.19 . Also recall that integer division always truncates
toward zero , so negative numbers truncate differently than positive ones .
(a) Does your solution work when m = 2? Justify your answer with a proof/counterexample.
(b) Does your solution work when n ≤ 0? Justify your answer with a proof/counterexample.
(c) Give an algorithm that will work for any integer n and any non-zero m . Give examples that
demonstrate that your algorithm is correct for the various c ases and/or a proof that it always
works. Make sure you consider all relevant cases (e.g., when it should round up and down, when
n and m are positive/negative). You may only use basic integer arit hmetic and conditional
statements. You may not use floor , ceiling , abs (absolute value), etc. You also may not use the
mod operator since how it works with negative numbers is not the s ame for every language.
Problem 5.19. Assume you have a function random(int n) that returns a random integer between
0 and n − 1, inclusive. Give code/pseudocode for an algorithm random(int a, int b) that returns
a random number between a and b , inclusive of both a and b . You may assume that a < b (although
in practice, this should be checked). You may only call random(int n) once and you may not use
conditional statements. Prove that your algorithm returns an integer in the required range.
Problem 5.20. Assume you have a function random() that returns a non-negative random integer.
Give code/pseudocode for an algorithm random(int a, int b) that returns a random integer
between a and b , inclusive of both a and b . Each possible number generated should occur with
approximately the same probability.  You may assume that a and b are both positive and that
a < b (although in practice, this should be checked). You may use o nly basic integer arithmetic
(including the mod operator) and you may only call random() once.  You may not use loops,
conditional statements, floor , ceiling , abs (absolute value), etc. Prove that your algorithm returns
an integer in the required range.
Problem 5.21. Give an algorithm that prints all of the primes that are less t han or equal to n .
Your algorithm should be as efficient as possible. One approac h is to modify the algorithm from
5.83 by using an array to make it more efficient. Example
Problem 5.22. The following method is a simplified version of a method that m ight be used to
implement a hash table or in a cryptographic system.  Assume t hat for one particular use the
number returned by this function has to have the opposite par ity (even/odd) of the parameter. For
instance, hash_it(4) returns 49 which has the opposite parity of 4, so it works for 4 . Prove or
disprove that this function always returns a value of opposi te parity of the parameter.

Problems 183
int hash_it(int x) {
return x*x+6*x+9;
}
Problem 5.23. Prove or disprove that the following method computes the abs olute value of x .
For simplicity, assume that all of the calculations are perf ormed with perfect precision. You may √
2 x = x when x ≥ 0 if it will help. use the fact that
double absoluteValue( double x) {
double square = x*x;
double answer = sqrt(square);
return answer;
}
Problem 5.24. Prove or disprove that the following method computes the abs olute value of x .
For simplicity, assume that all of the calculations are perf ormed with perfect precision. You may
√ 2
use the fact that ( x ) = x when x ≥ 0 if it will help.
double absoluteValue( double x) {
double root = sqrt(x);
double answer = root*root;
return answer;
}
Problem 5.25. Problems 5.23 and 5.24 both assumed that “all of the calculations are performed
with perfect precision”. Is that a realistic assumption? Gi ve an example of an input for which the
each algorithm will work properly. Then give an example of an input for which each algorithm will
not work properly. You can implement and run the algorithms to do some testing if you wish.
Problem 5.26. The following method is supposed to do some computations on a positive number
that result in getting the original number back. Prove or dis prove that this method always returns
the exact value that was passed in. Unlike in the previous problems, he re you should assume that
although a double stores a real number as accurately as possible, it uses only a fixed amount of
space. Thus, a double is unable to store the exact value of any irrational number–i t instead stores
an approximation.
double returnTheParameterUnmodified( double x) {
double a = sqrt(x);
double b = a*a;
return b;
}
1 5.11 actually does work Problem 5.27. Prove or disprove that the algorithm from Example
2 properly with integer data types stored using 2’s complemen t. You may restrict to 8-bit numbers
if it will help you think about it more clearly–a proof/count erexample for 8-bit number can easily
be modified to work for 32- or 64-bit numbers. (Hint: If it does n’t work, what sort of numbers
might it fail on?)
5.86 ). Problem 5.28. Let A and B be TreeSet s (See Example
(a) The method addAll(TreeSet other) adds all of the elements in other to this set if they’re
not already present. What is the result of A.addAll(B) (in terms of A and B and set operators)?
1 When we say “works,” we mean for all possible values of x and y .
2 We assume you have previously encountered the 2’s complemen t representation of integers. If not, do an Internet
search for details.

184 Chapter 5
(b) The method removeAll(TreeSet other) removes from this set all of its elements that are
contained in other . What is the result of A.removeAll(B) (in terms of A and B and set
operators)?
(c) Write A.contains(x) using set notation, where x is an element that can be stored in a TreeSet .
Problem 5.29. The class Relation is a partial implementation of a relation on a set A . It has a
list of Element objects.
• An Element stores an ordered pair from A . Element has methods getFrom() and getTo()
(using the language of the directed graph representation). So if an Element is storing ( a , b ),
getFrom() returns a and getTo() returns b . The constructor Element(Object a, Object b)
creates an element ( a , b ).
• The Relation class has methods like areRelated(Object a,Object b) , getElements( ) , and
getUniverse( ) .
• Methods in the Relation class can use for(Element e :  getElements()) to iterate over ele-
ments of the relation.
• Similarly, the loop for(Object a :  getUniverse()) iterates over the elements of A .
Given all of this, implement the following methods in the Relation class:
(a) isReflexive()
(b) isSymmetric()
(c) isAntiSymmetric()

Chapter 6: Sequences and Summations
6.1  Sequences
Definition 6.1. A sequence of real numbers is a function whose domain is the set of natura l
numbers and whose output is a subset of the real numbers. We us ually denote a sequence by
one of the notations
a , a , a , . . . 0 1 2
or
+ ∞ { a }
n n =0
or
{ a } . n
The last notation is just a shorthand for the second notation.
Note: Since sequences are functions, sometimes function notatio n is used.  That is, a ( n )
instead of a . n
We will be mostly interested in two types of sequences. The fir st type are sequences that have
an explicit formula for their n -th term. They are said to be in closed form .
+ ∞ 1 is a sequence for which we have , n = 0, 1, . . . . Then { a } Example 6.2. Let a = 1 −
n n n n =0 2
an explicit formula for the n -th term. The first five terms are
1 a =  1 − =  1 − 1   =  0,
0 0 2
1 1 1 a =  1 − = , =  1 −
1 1 2 2 2
1 1 3 =  1 − a =  1 − = ,
2 2 4 4 2
7 1 1 = , =  1 − a =  1 −
3 3 8 8 2
1 15 1 a =  1 − = . =  1 −
4 4 16 16 2
Note: Sometimes we may not start at n = 0 . In that case we may write
a , a , a , . . . , m m +1 m +2
or
+ ∞ , { a }
n n = m
where m is a non-negative integer. Most sequences we will deal with w ill start with m = 0 or
m = 1 .
185

186 Chapter 6
n ⋆ Exercise 6.3. Let { x } be the sequence defined by x = 1 + ( − 2) , n = 0, 1, 2, . . . . Find
n n
the first five terms of { x } . n
(a) x = 0
(b) x = 1
(c) x = 2
(d) x = 3
(e) x = 4
⋆ Exercise 6.4. Find the first five terms of the following sequences.
Å ã n
1
(a) x = 1 + − , n = 0, 1, 2, . . . n
2
x = x = x = 1 2 0
x = x = 3 4
(b) x = n ! + 1, n = 0, 1, 2, . . . n
x = x = x = 1 2 0
x = x = 3 4
1
, n = 2, 3, 4, . . . (c) x = n n
n ! + ( − 1)
x = x = x = 3 4 2
x = x = 5 6

Sequences 187
Å ã n
1
(d) x = 1 + , n = 1, 2, . . . n
n
x = x = x = 1 2 3
x = x = 4 5
The second type of sequence are defined using recurrence relations .
Definition 6.5. A recurrence relation is an equation that defines each term of a sequence
based on one or more previous terms of the sequence. More spec ifically, a recurrence relation
for a sequence { a } will define a based on (some of) the values of a , a , . . . , a . n n 0 1 n − 1
Å ã
1 + ∞
Example 6.6. Let x = 1, x = 1 + x , for n = 1, 2, . . . . Then { x } is a recur- 0 n n − 1 n n =0
n
sively defined sequence. The terms x , x , . . . , x are 1 2 5
) ( ) ( 1 1
x = 1 + 1  =  1 + 1  =  2. x = 1 + 0 1 1 1
( ) ( ) 1 1
x = 1 + x = 1 + 2  =  2 + 1  =  3. 2 1 2 2
) ( ) ( 1 1
x = 1 + 3  =  3 + 1  =  4. x = 1 + 2 3 3 3
( ) ( ) 1 1
x = 1 + x = 1 + 4  =  4 + 1  =  5. 4 3 4 4
) ( ) ( 1 1
x = 1 + 5  =  5 + 1  =  6. x = 1 + 4 5 5 5
Notice that in the previous example, we gave an explicit defin ition of x . This is called an 0
initial condition . In order to specify a sequence, a recurrence relation needs one or more initial
conditions. Without them, we have an abstract definition of a sequence, but cannot compute any
values since there is no “starting point.” Also note that diffe rent initial conditions can be specified
for the same recurrence relation, resulting in different sequ ences being generated.
When we find an explicit formula (or closed formula ) for a recurrence relation, we say we have
solved the recurrence relation.
Example 6.7. Given the values we computed in Example 6.6 , it seems relatively clear that
x = n + 1 is a solution for that recurrence relation. n
Note: It is important to be careful about jumping to conclusions too quickly when solving
a Although it turns out that in the previous example, x = n + 1 is the recurrence relations.
n
correct closed form (we will prove it shortly), just because it works for the first 5 terms does
not necessarily imply that the pattern continues.
a These comments also apply to other problems that involve see ing a pattern and finding an explicit formula.

188 Chapter 6
⋆ Exercise 6.8. Let { x } be the sequence defined by n
x = 1, x = 5 · x , for n = 1, 2, . . . . 0 n n − 1
Find a closed form for x . (Hint: Start by computing x , x , x , etc. until you see the pattern.) n 1 2 3
⋆ Exercise 6.9. Let { x } be the sequence defined by n
x = 1, x = n · x , for n = 1, 2, . . . . 0 n n − 1
Find a closed form for x . n
⋆ Evaluate 6.10. Define { a } by a (0) = 1, a (1) = 2, and n
ü ú √
5 1 +
+ a × a a = n − 2 n − 1 n
2
for n ≥ 2. Find a closed form for a . n
Solution:   We  can  see   that
√ √ ù ù ö ö
1+ 1+ 5 5 × a × 2 + 1 = 4 + a = a =
1 2 0 2 2
√ √ ö ù ù ö
1+ 5 5 1+ a = × a × 4 + 2 = 8 + a =
2 1 3 2 2
√ √ ù ö ù ö
1+ 5 5 1+ + a = × a × 8 + 4 = 16 a =
2 3 4 2 2

Sequences 189
(You  can  verify  these  with  a  calculator).   At  this  point  it  seems  re latively
n clear   that  a =  2 .
n
Evaluation
Did you catch what happened in the previous Evaluate exercis e? The ‘obvious’ solution wasn’t
correct. If you missed this, go back and read the solution.
Generally speaking, you need to prove that the closed form is correct. One way to do this is to
plug it back into the recursive definition. If we can plug it in to the right hand side of the recursive
definition and are able to simplify it to the left hand side, th en it must be a solution. We also have
to verify that it works for the initial condition(s).
2 As an analogy, how do you know that x = − 1 is a solution to the equation x + 2 x + 1 = 0?
2 You plug it in to get ( − 1) + 2( − 1) + 1 = 1 − 2 + 1 = 0. Since we got 0, x = − 1 is a solution.
We do something similar for recurrence relations, except th at what we are plugging in is a formula
instead of just a number.
Example 6.11. Prove that x = n + 1 is a solution to the recurrence relation given by n
ã Å
1
x , n = 1, 2, . . . . x = 1, x = 1 + n − 1 0 n
n
Proof: To prove that x = n + 1 is a solution for n ≥ 0, we need to show two n
things. First, that it works for the initial condition. Sinc e x = 1 = 0 + 1, it works 0
for the initial condition. Second, that if we plug it into the right hand side of the
recursive definition, that we can simplify it to x . Doing so, we get n
Å ã Å ã
1 1
1 + x = 1 + (( n − 1) + 1) n − 1
n n
Å ã
n + 1
= n
n
= n + 1
= x n
Since plugging the solution back in verifies the recurrence r elation, x = n + 1 is a n
solution to the recurrence relation.
If you are confused by the first step of algebra, remember that we are assuming
that x = n + 1 for n ≥ 0. Thus, x = ( n − 1) + 1 = n , since we are just plugging n n − 1
in n − 1 instead of n . 

190 Chapter 6
⋆ Exercise 6.12. Prove that your solution to Exercise 6.8 is correct.
⋆ Exercise 6.13. Prove that your solution to Exercise 6.9 is correct.

Sequences 191
⋆ Evaluate 6.14. Determine what ferzle(n) (below) returns for n = 0, 1, 2, 3, 4 and then
a re-write ferzle without using recursion, making it as efficient as possible.
ferzle( int n) { int
if (n<=0) {
return 3;
} else {
return ferzle(n-1) + 2;
}
}
Solution:   First,   we   can   see   that   ferzle(0)   returns   3   since   it   execu tes
the   code   in   the   if   statement. ferzle(1)   returns   ferzle(0)+2,   whi ch   is
3  +  2  =  5. ferzle(2)   returns   ferzle(1)+2,   which   is   5  +  2  =  7. ferzle( 3)
returns   ferzle(2)+2,   which   is   7 + 2  =  9.   ferzle(4)   returns   ferzle(3 )+2,
which   is   9 +  2  =  11.    Notice   that   11  =  2 ∗ 4 +  3,   9  =  2 ∗ 3  + 3,   7  =  2 ∗ 2 +  3,
5  =  2 ∗ 1 + 3,  and  3  =  2 ∗ 0 + 3.   From  this,  it  is  pretty  clear  that  ferzle(n)
returns  2n + 3.   Thus,   my  simplified   function  is   as   follows:
int ferzle(int n) {
return 2*n+3;
}
Evaluation
a Although we have not formally covered recursion yet, we expe ct that you have seen it before and know
enough to follow this example. If not, ask your instructor or a friend for help.
⋆ Exercise 6.15. Fix the code from the solution given in Evaluate 6.14 so that it still uses
the closed form, but works correctly for all values of n .
int ferzle( int n) {
}
8 . A more complete discussion of solving recurrences appears i n Chapter
The following is a famous example of a recursively defined seq uence that we will revisit several
times.

192 Chapter 6
Example 6.16. The Fibonacci sequence is a sequence of numbers that is of interest in various
mathematical and computing applications.  They are defined u sing the following recurrence
a relation:

0 if n =0 
f = 1 if n =1 n

f + f if n > 1 n − 1 n − 2
In words, each Fibonacci number (beyond the first two) is the s um of the previous two. The
first few are f = 0, f = 1, 0 1
f = f + f = 1 + 0 = 1, 2 1 0
f = f + f = 1 + 1 = 2, 3 2 1
f = f + f = 2 + 1 = 3, 4 3 2
f = f + f = 3 + 2 = 5, 5 4 3
f = f + f = 5 + 3 = 8, 6 5 4
f = f + f = 8 + 5 = 13. 7 6 5
Later we will see the closed form for the Fibonacci sequence. If you are really adventurous,
you might consider trying to determine it yourself. But be wa rned: It is not a simple formula
that you will come up with by just looking at some of the Fibona cci numbers.
a In the remainder of the book, when you see f , you should assume it refers to the k -th Fibonacci number k
unless otherwise specified.
+ ∞ is said to be Definition 6.17. A sequence { a }
n n =0
• increasing if a ≤ a ∀ n ∈ N n n +1
• strictly increasing if a < a ∀ n ∈ N n n +1
• decreasing if a ≥ a ∀ n ∈ N n n +1
• strictly decreasing if a > a ∀ n ∈ N n n +1
Some people call these sequences non-decreasing , increasing , non-increasing , and de-
creasing , respectively.
A sequence is called monotonic if it is any of these, and non-monotonic if it is none of
these.
Example 6.18. Recall that 0! = 1, 1! = 1, 2! = 1 · 2 = 2, 3! = 1 · 2 · 3 = 6, etc. Prove that the
sequence x = n !, n = 0, 1, 2, . . . is strictly increasing for n ≥ 1. n
Proof: For n > 1 we have
x = n ! = n ( n − 1)! = nx > x , n n − 1 n − 1
since n > 1. This proves that the sequence is strictly increasing. 

Sequences 193
⋆ Question 6.19. Notice in this first example we concluded that the sequence is strictly
increasing since we showed that x > x . But according to the definition we need to show n n − 1
that x < x . So did we do something wrong? Explain. n n +1
Answer
1
Example 6.20. Prove that the sequence x = 2 + , n = 0, 1, 2, . . . is strictly decreasing. n n
2
Proof: We have
Å ã Å ã
1 1
x − x = 2 + − 2 + n +1 n n +1 n
2 2
1 1
− = n +1 n
2 2
1
= − n +1
2
< 0.
Thus, x − x < 0, so x > x +1, i.e., the sequence is strictly decreasing.  n +1 n n n
2 n + 1
⋆ Exercise 6.21. Prove that the sequence x = , n = 1, 2, . . . is strictly increasing. n
n

194 Chapter 6
⋆ Exercise 6.22. Decide whether the following sequences are increasing, str ictly increasing,
decreasing, strictly decreasing, or non-monotonic. You do not need to prove your answer, but
give a brief justification.
(a) x = n , n = 0, 1, 2, . . . n
Answer
n (b) x = ( − 1) n , n = 0, 1, 2, . . .
n
Answer
1
(c) x = , n = 0, 1, 2, . . . n
n !
Answer
n
(d) x = , n = 0, 1, 2, . . . n
n + 1
Answer
2 (e) x = n − n , n = 1, 2, . . .
n
Answer
2 (f) x = n − n , n = 0, 1, 2, . . .
n
Answer
n (g) x = ( − 1) , n = 0, 1, 2, . . .
n
Answer

Sequences 195
1
(h) x = 1 − , n = 0, 1, 2, . . . n n
2
Answer
1
(i) x = 1 + , n = 0, 1, 2, . . . n n
2
Answer
There are two types of sequences that come up often. We will br iefly discuss each.
Definition 6.23. A geometric progression is a sequence of the form
2 3 4 a , ar , ar , ar , ar , . . . ,
where a (the initial term ) and r (the common ratio ) are real numbers. That is, a geometric
progression is a sequence in which every term is produced fro m the preceding one by multiplying
it by a fixed number.
0 Notice that the first term can be written as ar , so like an array in many programming languages,
n − 1 the terms of a geometric progression are indexed starting at 0. Thus, the n -th term is ar . If
a = 0 then every term is 0. If ar 6 = 0, we can find r by dividing any term by the previous term.
Example 6.24. Find the 11-th term of the geometric progression
3, 6, 12, 24, . . . .
Solution: Since this is a geometric progression, a = 3 since the first term is
always a . To determine r , we need to find the ratio between any two terms. For
instance, 24 / 12 = 2 or 12 / 6 = 2. So r = 2 in this case. Thus, the sequence is
k 10 { 3 · 2 } , and the 11-th term is 3 · 2 = 3 ∗ 1024 = 3072.
Example 6.25. Find the 35-th term of the geometric progression
1 8
√ √ , − 2, , . . . .
2 2
√ 1 1
√ √ , and the common ratio is r = − 2 / = − 2 2.  Thus, Solution: a =
2 2 ä ä Ä Ä
√ √ n − 1 34 51 1 2 1
√ √ √ . Hence the 35-th term is = the n -th term is 2 2 = − 2 − 2
2 2 2 √
2. 1125899906842624

196 Chapter 6
⋆ Exercise 6.26. Find the 17-th term of the geometric progression
2 2 2
, , − , ··· . − 17 16 15
3 3 3
Example 6.27. The fourth term of a geometric progression is 24 and its seven th term is 192.
Find its second term.
3 6 Solution: We are given that ar = 24 and ar = 192, for some a and r . Clearly,
ar 6 = 0, and so we find
6 ar 192
3 = r = = 8.
3 ar 24
3 Thus, r = 2. Now, a (2) = 24, giving a = 3. The second term is thus ar = 6.
⋆ Exercise 6.28. The 6-th term of a geometric progression is 20 and the 10-th is 320. Find
the absolute value of its third term.
Definition 6.29. An arithmetic progression is a sequence of the form
a , a + d , a + 2 d , a + 3 d , a + 4 d , . . . ,
where a (the initial term ) and d (the common difference ) are real numbers. That is, an
arithmetic progression is a sequence in which every term is p roduced from the preceding one by
adding a fixed number.

Sequences 197
Example 6.30. If s = 3 n − 7, then { s } is an arithmetic progression with a = − 7 and d = 3 n n
(assuming we begin with s ). 0
Note: Notice that geometric progressions are essentially a discr ete version of an exponential
function and arithmetic progressions are a discrete versio n of a linear function. One conse-
quence of this is that a sequence cannot be both of these unles s it is the sequence a , a , a , . . . for
some a .
Example 6.31. Consider the sequence
4, 7, 10, 13, 16, 19, 22, . . . .
Assuming the pattern continues, is this a geometric progres sion? Is it an arithmetic progression?
Solution: It is easy to see that each term is 3 more than the previous term .
Thus, this is an arithmetic progression with a = 4 and d = 3. Clearly it is therefore
not geometric.
⋆ Question 6.32. Tests like the SAT and ACT often have questions such as the fol lowing.
23. Given the sequence of numbers 2, 9, 16, 23, what will the 8t h term of the
sequence be? (a) 60 (b) 58 (c) 49 (d) 51 (e) 56
(a) What is the ‘correct’ answer to this question?
Answer
(b) Why did I put ‘correct’ in quotes in the previous question ?
Answer
Now let’s see if you can correctly identify geometric and/or arithmetic sequences.

198 Chapter 6
⋆ Question 6.33. Determine whether or not the following sequences are geomet ric and/or
arithmetic. Explain your answer.
(a) The sequence from Example 6.8 .
Answer
(b) The sequence from Example 6.9 .
Answer
(c) The sequence generated by ferzle(n) in Evaluate 6.14 on the non-negative inputs.
Answer

Sums and Products 199
6.2  Sums and Products
When there is a need to add or multiply terms from a sequence, summation notation (or sum
notation ) and product notation come in handy. We first introduce sum notation.
Definition 6.34. Let { a } be a sequence. Then for 1 ≤ m ≤ n , where m and n are integers, n
we define
n ∑
a = a + a + ··· + a . m m +1 n k
k = m
We call k the index of summation and m and n the limits of the summation. More specif-
ically, m is the lower limit and n is the upper limit . Each a is a term of the sum. k
Note: We often use i , j , and k as index variables for sums, although any letters can be used .
2 3 49 Example 6.35. We can express the sum 1 + 3 + 3 + 3 + ··· + 3 as
49 ∑
i 3 .
i =0
0 (Recall that 3 = 1, so the first term fits the pattern.)
2 3 100 ⋆ Exercise 6.36. Write 1 + y + y + y + ··· + y using sum notation.
Example 6.37. Write the following sum using sum notation.
2 3 4 5 99 100 1 − y + y − y + y − y + ···− y + y
Solution: This is a lot like the previous exercise, except that every ot her term is
negative. So how do we get those terms to be negative? The stan dard trick relies
i on the fact that ( − 1) is 1 if i is even and − 1 if i is odd. Thus, we can multiple
i each term by ( − 1) for an appropriate choice of i . Since the odd powers are the
negative ones, this is easy:
100 100 ∑ ∑
i i i ( − y ) ( − 1) y or
i =0 i =0

200 Chapter 6
Note: You might be tempted to give the following solution to the pre vious problem:
100 ∑
i − y .
i =0
As we will see shortly, this is the same as
100 ∑
i y , −
i =0
which is not the correct answer. The bottom line: Always use pa rentheses in the appropriate
locations, especially when negative numbers are involved!
2 4 6 100 ⋆ Exercise 6.38. Write 1 + y + y + y + ··· + y using sum notation.
Note: If you struggled understanding the two solutions to the previ ous example, it might be
time to review the basic algebra rules involving exponents. We will just give a few of them here.
You can find more extensive lists in an algebra book or various reputable online sources. We
0 have already used the fact that if x 6 = 0 , then x = 1 . In addition, if x , a , b ∈ R with x > 0 ,
then
√ ( ) √ a 1 a b a b ab a b a + b − a
b a b . x = x , and x = ( x ) = x , x x = x ,   ( x ) =
a x
As with sequences, we are often interested in obtaining closed forms for sums. We will present
several important formulas, along with a few techniques to fi nd closed forms for sums.
Example 6.39. It should not be too difficult to see that
20 ∑
1 = 20
k =1
since this sum is adding 20 terms, each of which is 1. But notic e that
19 219 ∑ ∑
1 = 1 = 20
k =0 k =200
since both of these sums are also adding 20 terms, each of whic h is 1. In other words, if the
variable of summation (the k ) does not appear in the sum, then the only thing that matters i s
how many terms the sum involves.

Sums and Products 201
⋆ Exercise 6.40. Find each of the following.
6 ∑
(a) 1 =
k =5
30 ∑
(b) 1 =
k =20
100 ∑
1 = (c)
k =1
100 ∑
(d) 1 =
k =0
Hopefully you noticed that the previous example and exercis e can be generalized as follows.
Theorem 6.41. If a , b ∈ Z , then
b ∑
1 = ( b − a + 1).
k = a
Proof: This sum has b − a + 1 terms since there are that many number between
a and b , inclusive. Since each of the terms is 1 , the sum is obviously b − a + 1 . 
Example 6.42. If we apply the previous theorem to the sums in Example 6.39 , we would
obtain 20 − 1 + 1 = 20, 19 − 0 + 1 = 20, and 219 − 200 + 1 = 20.
Next is a simple theorem based on the distributive law that yo u learned in grade school.
Theorem 6.43. If { x } is a sequence and a is a real number, then n
n n ∑ ∑
a · x = a x . k k
k = m k = m
Example 6.44. Using Theorems 6.41 and 6.43 , we can see that
17 17 ∑ ∑
1 = 4 · (17 − 5 + 1) = 4 · 13 = 52. 4 = 4
k =5 k =5

202 Chapter 6
⋆ Exercise 6.45. Find each of the following.
6 ∑
(a) 5 =
k =5
30 ∑
(b) 200 =
k =20
We can combine Theorems 6.41 and 6.43 to obtain the following.
Theorem 6.46. If a , b ∈ Z and c ∈ R , then
b ∑
c = ( b − a + 1) c .
k = a
6.43 , we have Proof: Using Theorem
b b ∑ ∑
c = c 1 = ( b − a + 1) c .
k = a k = a

Example 6.47. We can compute the sum from Example 6.44 by using Theorem 6.46 to obtain
17 ∑
4 = (17 − 5 + 1)4 = 52.
k =5
Both ways of computing this sum are valid, so feel free to use w hichever you prefer.
⋆ Exercise 6.48. Find each of the following.
30 ∑
(a) 200 =
k =20
100 ∑
(b) 9 =
k =1
100 ∑
9 = (c)
k =0

Sums and Products 203
75 ∑
10. ⋆ Evaluate 6.49. Compute
k =25
Solution:   This   is   just   10(75 − 25)  =  10 ∗ 50  =  500.
Evaluation
The following sum comes up often and should be committed to me mory. The proof involves
a nice technique that adds the terms in the sum twice, in a differ ent order, and then divides the
result by two. This is known as Gauss’ trick.
Theorem 6.50. If n is a positive integer, then
n ∑
n ( n + 1)
k = .
2
k =1
n ∑
k for shorthand. Then we can see that Proof: Let S =
k =1
S = 1 + 2 + 3 + ··· + n
and by reordering the terms,
S = n + ( n − 1) + ··· + 1.
Adding these two quantities,
S = 1 + 2 + ··· + n
S = n +  ( n − 1)  + ··· + 1
2 S =   ( n + 1)   +  ( n + 1)  + ··· +  ( n + 1)
= n ( n + 1),
n ( n + 1)
, as was to be since there are n terms.  Dividing by 2 , we obtain S =
2
proved. 
Example 6.51.
10 ∑
10 · 11 10(10 + 1)
= = 55. k =
2 2
k =1

204 Chapter 6
⋆ Exercise 6.52. Compute each of the following.
20 ∑
(a) k =
k =1
100 ∑
(b) k =
k =1
1000 ∑
k = (c)
k =1
30 ∑
⋆ Evaluate 6.53. Compute k .
k =1
30 ∑
k  =  29 ∗ 30 / 2  =  435 . Solution   1:
k=1
Evaluation
30 30 ∑ ∑
1  =  k(30 − 1 + 1)  =  30k . k  =  k Solution   2:
k=1 k=1
Evaluation
Note: A common error is to think that the sum of the first n integers is n ( n − 1) / 2 instead of
n ( n + 1) / 2 . Whenever I use the formula, I double check my memory by compu ting 1 + 2 + 3 .
In this case, n = 3 . So is the correct answer 3 · 2 / 2 = 3 or 3 · 4 / 2 = 6 ? Clearly it is the latter.
Then I know that the correct formula is n ( n + 1) / 2 . You can use any positive value of n to
check the formula. I use 3 out of habit.
n n ∑ ∑
n ( n + 1)
⋆ Question 6.54. Is it true that k = k = ? Explain.
2
k =0 k =1
Answer

Sums and Products 205
+ Theorem 6.55. If { x } and { y } are sequences, then for any n ∈ Z ,
k k
n n n ∑ ∑ ∑
y . x + x + y = i i i i
i =1 i =1 i =1
Proof: This follows from the commutative property of addition. 
Example 6.56.
20 20 20 ∑ ∑ ∑
20 · 21
5 = i + i + 5 = + 5 · 20 = 210 + 100 = 310.
2
i =1 i =1 i =1
⋆ Exercise 6.57. Compute the following sum
100 ∑
2 − i = .
i =1
2 ⋆ Exercise 6.58. Prove that the sum of the first n odd integers is n .
The following example contains something called a telescoping series .  It demonstrates that
evaluating a telescoping series is fairly simple.
n ∑
( a − a ) = a − a . Example 6.59. Let { a } be a sequence of real numbers. Show that i i − 1 n 0 k
i =1
Proof: We can see that
) ) ( (
n n n ∑ ∑ ∑
− a ( a − a )  = a i − 1 i i − 1 i
i =1 i =1 i =1
=  ( a + a + ··· + a + a ) − ( a + a + a + ··· + a ) 1 2 n − 1 n 0 1 2 n − 1
= a + a + ··· + a + a − a − a − a −···− a 1 2 n − 1 n 0 1 2 n − 1
=  ( a − a ) + ( a − a ) + ··· + ( a − a ) + a − a 1 1 2 2 n − 1 n − 1 n 0
= a − a .  n 0

206 Chapter 6
Example 6.60. Given what we know so far, how can we compute the following:
100 ∑
k =?
k =50
It turns out that this is not that hard. Notice that it is almost a sum we know. We know how
100 ∑
to compute k , but that has too many terms. Can we just subtract those terms to get the
k =1
answer? What terms don’t we want? Well, we don’t want terms 1 t hrough 49. But that is just
49 ∑
k . In other words,
k =1
49 100 100 ∑ ∑ ∑
k k − k =
k =1 k =1 k =50
49 · 50 100 · 101
− =
2 2
=  5050 − 1225 = 3825
⋆ Exercise 6.61. Compute each of the following.
20 ∑
(a) k =
k =10
40 ∑
(b) k =
k =21
⋆ Evaluate 6.62. Compute the following.
100 ∑
k .
k =30
Solution   1:
30 100 100 ∑ ∑ ∑
k  =  100 · 101 / 2 − 30 · 31 / 2  =  5050 − 465  =  4585 k − k  =
k=1 k=1 k=30
Evaluation

Sums and Products 207
Solution   2:
30 100 100 ∑ ∑ ∑
k  =  99 · 100 / 2 − 29 · 30 / 2  =  4950 − 435  =  4515 k − k  =
k=1 k=1 k=30
Evaluation
Solution   3:
29 100 100 ∑ ∑ ∑
k  =  100 · 101 / 2 − 29 · 30 / 2  =  5050 − 435  =  4615 k − k  =
k=1 k=1 k=30
Evaluation
⋆ Question 6.63. Explain why the following computation is incorrect. Then ex plain why the
answer is correct even with the error(s).
100 100 30 ∑ ∑ ∑
k = k − k = 100 · 101 / 2 − 29 · 30 / 2 = 5050 − 435 = 4615
k =30 k =1 k =1
Answer

208 Chapter 6
+ Theorem 6.64. Let n ∈ Z . Then the following hold.
n ∑
n ( n + 1)(2 n + 1) 2
k =
6
k =1
n 2 2 ∑
n ( n + 1) 3
k =
4
k =1
n ∑
1 1 1 1 1 n − 1
= + + + ··· + =
( k − 1) k 1 · 2 2 · 3 3 · 4 ( n − 1) · n n
k =2
We will prove Theorem 6.64 in the chapter on mathematical induction since that is perha ps the
easiest way to prove these results. It is probably a good idea to attempt to commit the first two of
these sums to memory since they come up on occasion.
⋆ Question 6.65. Why does the third formula from Theorem 6.64 have a lower index of 2
(instead of 1 or 0, for instance)?
Answer
⋆ Exercise 6.66. Compute the following sum, simplifying as much as possible.
n ∑
3 k + k =
k =1
Sometimes double sums are necessary to express a summation. As a general rule, these should
be evaluated from the inside out.

Sums and Products 209
n n ∑ ∑
1. Example 6.67. Evaluate the double sum
j =1 i =1
n n n ∑ ∑ ∑
2 n = n · n = n . 1 = Solution: We have
i =1 j =1 i =1
⋆ Exercise 6.68. Evaluate the following double sums
i n ∑ ∑
1 = (a)
j =1 i =1
n i ∑ ∑
j = (b)
i =1 j =1
n n ∑ ∑
ij = (c)
j =1 i =1
There is a formula for the sum of a geometric sequence, someti mes referred to as a geometric

210 Chapter 6
series . It is given in the next theorem.
Theorem 6.69. Let x 6 = 1 . Then
ã Å n n +1 n +1 ∑
1 − x x − 1 k
x = if you prefer . or
1 − x x − 1
k =0
n ∑
k x . Then Proof: First, let S =
k =0
n n n +1 ∑ ∑ ∑
k k +1 k xS = x x = x = x .
k =0 k =0 k =1
So
n n +1 ∑ ∑
k k x x − xS − S =
k =0 k =1
=  ( x + x + . . . + x + x ) − ( x + x + . . . + x ) 1 2 n n +1 0 1 n
n +1 0 n +1 = x − x = x − 1.
n +1 x − 1 n +1
So we have ( x − 1) S = x − 1 , so S = , since x 6 = 1 .  x − 1
Example 6.70.
n n +1 n +1 n +1 ∑
1 − 3 3 − 1 1 − 3 k
= = . 3 =
1 − 3 − 2 2
k =0
Example 6.71.
ã Å ã Å n n n k k n +1 n +1 ∑ ∑ ∑
1 1 1 1 − 1 / (5 ) 5 1 1 − (1 / 5) 5 1
= = − = = . = = 1 − k k n +1 n
5 5 5 1 − 1 / 5 4 / 5 4 5 4 4 · 5
k =0 k =0 k =0
⋆ Exercise 6.72. Find the sum of the following geometric series.
2 3 49 1 + 3 + 3 + 3 + ··· + 3 =

Sums and Products 211
⋆ Exercise 6.73. Find the sum of the following geometric series.
33 34 1 − 2 + 4 − 8 + ···− 2 + 2 =
⋆ Exercise 6.74. Find the sum of the following geometric series. Assume y 6 = 1.
2 3 100 (a) 1 + y + y + y + ··· + y =
2 3 4 5 99 100 (b) 1 − y + y − y + y − y + ···− y + y =
2 4 6 100 (c) 1 + y + y + y + ··· + y =
Corollary 6.75. Let N ≥ 2 be an integer. Then
N N − 1 N − 2 x − 1 = ( x − 1)( x + x + ··· + x + 1).
Proof: Plugging N = n + 1 in the formula from Theorem 6.69 and doing a little
algebra yields the formula. 

212 Chapter 6
Example 6.76. We can see that
2 x − 1  =  ( x − 1)( x + 1)
3 2 x − 1  =  ( x − 1)( x + x + 1), and
4 3 2 x − 1  =  ( x − 1)( x + x + x + 1).
5 ⋆ Exercise 6.77. Factor x − 1.
5 x − 1 =
Let’s use the technique from the proof of Theorem 6.69 in the special case where x = 2.
⋆ Fill in the details 6.78. Find the sum
0 1 2 3 4 n 2 + 2 + 2 + 2 + 2 + ··· + 2 .
Solution: We could just use the formula from Theorem 6.69 , but that would
0 1 2 3 n be boring. Instead, let’s work it out. Let S = 2 + 2 + 2 + 2 + ··· + 2 . Then
. Notice S and 2 S have most of the same terms, 2 S =
that 2 S doesn’t have and 2 S has that except S has
S doesn’t have. Therefore,
1 2 3 n n +1 S = 2 S − S = (2 +  2 +  2 + ··· +  2 +  2 )
0 1 2 3 n − (2 +  2 +  2 +  2 + ··· +  2 )
=
n +1 =  2 − 1.
n ∑
k n +1 Thus, 2 = 2 − 1.
k =0
Since powers of 2 are very prominent in computer science, you should definitely commit the
formula from the previous example to memory.
6.43 and 6.69 imply the following: Together, Theorems
n n +1 ∑
a − ar k
. Theorem 6.79. Let r 6 = 1 . Then ar =
1 − r
k =0

Sums and Products 213
⋆ Fill in the details 6.80. Use Theorems 6.43 and 6.69 to prove Theorem 6.79 .
Proof: It is easy to see that
n ∑
k ar =
k =0
=
n +1 a − ar
= .
1 − r

⋆ Exercise 6.81. Prove Theorem 6.79 without using Theorems 6.43 and 6.69 . In other words,
6.69 . mimic the proof of Theorem
n Notice that if | r | < 1 then r gets closer to 0 the larger n gets.  More formally, if | r | < 1,
n lim r = 0. This implies the following (which we will not formally pr ove beyond what we have
n →∞
already said here).

214 Chapter 6
Theorem 6.82. Let | r | < 1 . Then
∞ ∑
a k
ar = .
1 − r
k =0
Example 6.83. A fly starts at the origin and goes 1 unit up, 1 / 2 unit right, 1 / 4 unit down,
1 / 8 unit left, 1 / 16 unit up, etc., ad infinitum. In what coordinates does it end up?
Solution: Its x coordinate is
Å ã Å ã Å ã 1 0 1 2
2 1 1 1 1 1 1 1 1 1 2
= − + −··· = . + + + ··· = − − − − 1
2 8 32 2 4 2 4 2 4 5 1 − 4
Its y coordinate is
Å Å Å ã ã ã 0 1 2
1 1 1 1 1 1 4
+ − + − + ··· = + −··· = − . 1 − = − 1
4 16 4 4 4 5 1 − 4
( ) 2 4
Therefore, the fly ends up in . , 5 5
The following infinite sums are sometimes useful.
Theorem 6.84. Let x ∈ R . The following expansions hold:
∞ n 2 n +1 2 n +1 3 5 ∑
( − 1) x x x x n
sin x = = x − + −··· + ( − 1) + ···
(2 n + 1)! 3! 5! (2 n + 1)!
n =0
∞ 2 n 2 4 n 2 n ∑
x x x ( − 1) x n
=  1 − + −··· + ( − 1) + ··· cos x =
(2 n )! 2! 4! (2 n )!
n =0
∞ n 2 3 n ∑
x x x x x
e = =  1 + x + + + ··· + + ···
n ! 2! 3! n !
n =0
∞ ∑
1 n 2 3
x =  1 + x + x + x + ··· , if | x | < 1 =
1 − x
n =0
Product notation is very similar to sum notation, except we multiply the terms instead of adding
them.
Definition 6.85. Let { a } be a sequence. Then for 1 ≤ m ≤ n , where m and n are integers, n
we define
n ∏
a = a a ··· a . m m +1 n k
k = m
As with sums, we call k the index and m and n the lower limit and upper limit , respectively.

Sums and Products 215
n ∏
Example 6.86. Notice that n ! = k .
k =1
Note: An alternative way to express the variable and limits of sums and products is
n ∑ ∑
a instead of a k k
m ≤ k ≤ n k = m
and
n ∏ ∏
a instead of a k k
m ≤ k ≤ n k = m

216 Chapter 6
6.3  Reading Comprehension Questions
From Section 6.1
n n Question 6.1. If { x } is defined by x = 3 − 2 , find x , x , x , x , and x . ⋆
n n 1 2 3 4 5
⋆ Question 6.2. What does it mean to solve a recurrence relation?
⋆ Question 6.3. If { x } is defined by x = 1 and x = 2 x + 3, find x , x , x , and x . n 1 n n − 1 2 3 4 5
⋆ Question 6.4. Let { x } be defined by x = 2 and x = x + 3. n 1 n n − 1
(a) Find x , x , x , and x . 2 3 4 5
(b) Find a closed form for x . n
(c) Prove that your closed form is correct by following the te chnique from Example 6.11 .
⋆ Question 6.5. Let { a } be a sequence that gives the number of steps required to run so me n
algorithm on an input of size n (e.g. imagine the input is an array). For instance, it takes a steps 1
to run the algorithm if the input is an array of size 1, a steps if the input is an array of size 2, etc. 2
Would you expect this sequence to be increasing, decreasing , or neither? Explain.
⋆ Question 6.6. Are geometric progressions always, sometime, or never mono tonic?  Explain.
Similarly, are they always, sometimes, or never increasing ?
⋆ Question 6.7. Are arithmetic progressions always, sometime, or never mon otonic?  Explain.
Similarly, are they always, sometimes, or never increasing ?
⋆ Question 6.8. Give an example (not from the book) of each of the following.
(a) A geometric progression in closed form.
(b) An arithmetic progression in closed form.
(c) A recurrence relation that defines a geometric progressi on.
(d) A recurrence relation that defines an arithmetic progres sion.
From Section 6.2
n n ∑ ∑
i i ( − x ) the same? Explain. and − x Question 6.9. Are ⋆
i =1 i =1
⋆ Question 6.10. Write − 1 + 3 − 9 + 27 − 81 + 243 − 729 using a summation.
30 ∑
⋆ Question 6.11. Compute 5 k − 7.
k =0
n ∑
k ⋆ Question 6.12. Compute 2 . (Eventually you will hopefully have this one memorized.)
k =0
n n ∑ ∑
x ? If so, when? Give an example. x = ⋆ Question 6.13. Is it ever the case that i i
i =1 i =0

Reading Comprehension Questions 217
23 ∑
11
. Simplify your answer (although you don’t need to compute ⋆ Question 6.14. Compute k
( − 7)
k =1
the actual number). (I have thrown several subtle tricks at y ou on this one, but if you read carefully
and apply what you know, you should be able to do it!)
⋆ Question 6.15. Estimate cos(1) without using a calculator.

218 Chapter 6
6.4  Problems
Problem 6.1. Find at least three different sequences that begin with 1, 3, 7 whose terms are
generated by a simple formula or rule. By different, I mean none of the sequences can have exactly
the same terms. In other words, your answer cannot simply be t hree different ways to generate the
same sequence.
Problem 6.2. Let q = 2 q + 2 n + 5, and q = 0. Compute q , q , q and q . n n − 1 0 1 2 3 4
Problem 6.3. Let a = a + n , a = 0, and a = 1. Compute a , a , a and a . n n − 2 0 1 2 3 4 5
Problem 6.4. Let a = n × a + 5, and a = 1. Compute a , a , a , a and a . n n − 1 0 1 2 3 4 5
Problem 6.5. Define a sequence { x } by x = 1, and x = 2 x + 1 if n ≥ 1. Find a closed form n 0 n n − 1
for the n th term of this sequence. Prove that your solution is correct.
Problem 6.6. Compute each of the following:
3 40 4 log n 2 ∑ ∑ ∑ ∑
j j (d) (a) k 2 (g)
i =1 j =1 k =5 j =0
n log n 22 2 ) ( ∑ ∑ ∑
n j +1 j
(e) k ( k − 1) (2 − 2 ) (b) (h)
i 2
j =5 k =1 i =0
j i n n n ∑ ∑ ∑ ∑
∑ j
1 (i) 5 (f) (c) 5 k
j =1 i =1 j =1 k =1 k =0
Problem 6.7. Here is a standard interview question for prospective compu ter programmers: You
are given a list of 1, 000, 001 positive integers from the set { 1, 2, . . . , 1, 000, 000 } . In the list, every
member of { 1, 2, . . . , 1, 000, 000 } is listed once, except for x , which is listed twice, and the numbers
are listed in some unknown order. How do you find what x is without doing a 1, 000, 000 step
search (e.g. check if 1 is on the list twice, then check if 2 is o n the list twice, etc.)? How much
faster is your solution than the naive solution?
Problem 6.8. Find a closed formula for
2 2 2 2 n − 1 2 T = 1 − 2 + 3 − 4 + ··· + ( − 1) n .
n
Problem 6.9. Show that when n ≥ 1,
2 . 1 + 3 + 5 + ··· + (2 n − 1) = n
Problem 6.10. Assuming n ≥ 1, find and prove a closed formula for
2 + 4 + 6 + ··· + 2 n
Problem 6.11. Show that when n ≥ 1,
n 2 ∑
1 n + n k
= · . 4 2 2
k + k + 1 2 n + n + 1
k =1

Problems 219
Problem 6.12. Legend says that the inventor of the game of chess, Sissa ben D ahir, asked the
King Shirham of India to place a grain of wheat on the first squa re of the chessboard, 2 on the
second square, 4 on the third square, 8 on the fourth square, e tc..
(a) How many grains of wheat are to be put on the last (64-th) sq uare?
(b) How many grains, total, are needed in order to satisfy the greedy inventor?
(c) Given that 15 grains of wheat weigh approximately one gra m, what is the approximate weight,
in kg, of the wheat needed?
(d) Given that the annual production of wheat is 350 million t onnes, how many years, approx-
imately, are needed in order to satisfy the inventor (assume that production of wheat stays
constant)?
Problem 6.13. It is easy to see that we can define n ! recursively by defining 0! = 1, and if n > 0,
n ! = n · ( n − 1)!. Does the following method correctly compute n !? If not, state what is wrong with
it and fix it.
int factorial( int n) {
return n * factorial(n-1);
}
n ∑
2 Problem 6.14. Find a closed formula for k ( k − 1). Simplify the formula as much as possible.
k =1
n ∑
k · k !. (Hint: What is ( k + 1)! − k !, and why does it Problem 6.15. Find a closed formula for
k =1
matter?) Simplify the formula as much as possible.
( ) 2
n n ∑ ∑
3 Problem 6.16. Prove that for n ≥ 1, k = . k
k =1 k =1
Problem 6.17. A student turned in the code below (which does as its name sugg ests). I gave
them a ‘C’ on the assignment because although it works, it is v ery inefficient.
int sumFromOneToN( int n) {
int sum = 0;
for ( int i=1;i<=n;i++) {
sum = sum + i;
}
return sum;
}
(a) Write the ‘A’ version of the algorithm (in other words, a m ore efficient version).  You can
assume that n ≥ 1.
(b) Compute sumFromOneToN(30) based on your algorithm.

220 Chapter 6
Problem 6.18. A student turned in the code below (which does as its name sugg ests). I gave
them a ‘C’ on the assignment because although it works, it is v ery inefficient.
int sumFromMToN( int m, int n) {
int sum = 0;
for ( int i=1;i<=n;i++) {
sum = sum + i;
}
for ( int i=1;i 0. Prove that a n + a n + ··· + a n +
0 1 k k k k − 1
k a = O ( n ).
0
Solution   1: We   can   first   eliminate   all   of   the   constants   since   they   become
k k − 1 irrelevant   as   n   grows   large   enough.    This   leaves   us   with   n + n + ··· + n  =
k k O(n ). Next   we   can   eliminate   all   terms   growing   slower   than   n ,   since   they
k k also  become  irrelevant  as  n  grows.   This   leaves   us   with  n =  O(n ),  and  since
they  are  the  same,  they  are  effectively  theta  of  each  other,  and  b y  definition,
anything  that  is  theta  of  something  is  also  omega  and  O,  so  we  can  correc tly
k k k k − 1 k say  that   n =  O(n ),  thus   proving  that   a n + a n + ··· + a n + a =  O(n ).
k k − 1 1 0
Evaluation

230 Chapter 7
k ∑
Solution   2: Let  c  = | a | .   Then   if   n ≥ 1, i
i=0
k k − 1 k k − 1 a n + a n + ··· + a n + a ≤ | a | n + | a | n + ··· + | a | n + | a |
k k k − 1 1 k − 1 1 0 0
k k k k ≤ | a | n + | a | n + ··· + | a | n + | a | n
k k − 1 1 0
k ∑
k k ≤ | a | n =  cn .
i
i=0
k k − 1 k Therefore,  a n + a n + ··· + a n + a =  O(n ).
k k − 1 1 0
Evaluation
2 3 ⋆ Exercise 7.26. Assume that f ( n ) = O ( n ) and g ( n ) = O ( n ). What can you say about
the relative growth rates of f ( n ) and g ( n )? In particular, does g ( n ) grow faster than f ( n )?
Answer
Keep in mind that asymptotic notation only allows you to comp are the asymptotic behavior
of functions. Except for Θ-notation, it only provides a boun d on the growth rate. For instance,
knowing that f ( n ) = O ( g ( n )) only tells you that f ( n ) grows no faster than g ( n ). It is possible that
f ( n ) grows a lot slower than g ( n ).
⋆ Exercise 7.27. Let’s test your understanding of the material so far. Answer each of the
following true/false questions, giving a very brief justifi cation/counterexample. Justifications
can appeal to a definition and/or theorem. For counterexampl es, use simple functions. For
2 instance, f ( n ) = n and g ( n ) = n .
If f ( n ) = O ( g ( n )), then f ( n ) grows faster than g ( n ) (a)
(b) If f ( n ) = Θ( g ( n )), then f ( n ) grows faster than g ( n )
If f ( n ) = O ( g ( n )), then f ( n ) grows at the same rate as g ( n ) (c)

Asymptotic Notation 231
(d) If f ( n ) = Ω( g ( n )), then f ( n ) grows faster than g ( n )
(e) If f ( n ) = O ( g ( n )), then f ( n ) = Ω( g ( n ))
(f) If f ( n ) = Θ( g ( n )), then f ( n ) = O ( g ( n ))
(g) If f ( n ) = O ( g ( n )), then f ( n ) = Θ( g ( n ))
If f ( n ) = O ( g ( n )), then g ( n ) = O ( f ( n )) (h)
7.1.2  Properties of the Notations
There are a lot of properties that hold for Big-O, Θ and Ω notat ion (and o and ω as well, but we
won’t focus on those ones in this section). We will only prese nt a few of the most important ones.
We provide proofs for some of the results. The rest can be prov en without too much difficulty using
the definitions of the notations.
Before we present the properties, it might be useful to think about the properties of things you
are already familiar with. For instance, given real numbers x , y and z , you know that if x ≤ y and
y ≤ z , then x ≤ z . This is just the transitive property of ≤ . Similarly, you know that if x ≤ y ,
then a x ≤ a y for any positive constant a . You can think of Big-O notation as being like ≤ , Θ
notation as being like =, and Ω notation as being like ≥ . Many of the properties of ≤ , = and ≥
that you are already familiar with have an analog with Big-O, Θ, and Ω notation. But you need
to be careful because the analogies are not exact. For instan ce, constants cannot be ignored with
inequalities but can be ignored when using asymptotic notat ion.
Theorem 7.28. The transitive property holds for Big-O, Θ , and Ω . That is,
• If f ( n ) = O ( g ( n )) and g ( n ) = O ( h ( n )), then f ( n ) = O ( h ( n ))
• If f ( n ) = Θ( g ( n )) and g ( n ) = Θ( h ( n )) , then f ( n ) = Θ( h ( n ))
• If f ( n ) = Ω( g ( n )) and g ( n ) = Ω( h ( n )) , then f ( n ) = Ω( h ( n ))
Proof: You will prove the transitive property of Big-O in Exercise 7.49 . The
proofs of the other two are very similar. 
7.28 is pretty intuitive. For instance, when applied to Big-O not ation, Theorem 7.28 Theorem
is essentially stating that if g ( n ) is an upper bound on f ( n ) and h ( n ) is an upper bound on g ( n ),
then h ( n ) is an upper bound for f ( n ). Put another way, if f ( n ) grows no faster than g ( n ) and g ( n )

232 Chapter 7
grows no faster than h ( n ), then f ( n ) grows no faster than h ( n ). This makes perfect sense if you
think about it for a few minutes.
2 3 3 4 Example 7.29. Let’s take it for granted that 4 n + 3 n + 17 = O ( n ) and n = O ( n ) (both
of which you should be able to easily prove at this point). Acc ording to Theorem 7.28 , we can
2 4 conclude that 4 n + 3 n + 17 = O ( n ).
Theorem 7.30. Scaling by a constant factor
If f ( n ) = O ( g ( n )) , then for any k > 0 , kf ( n ) = O ( g ( n )) . Similarly for Θ and Ω .
Proof: We will give the proof for Big-O notation.  The other two proofs are
similar.  Assume f ( n ) = O ( g ( n )) .  Then by the definition of Big-O, there are
positive constants c and n such that f ( n ) ≤ c g ( n ) for all n ≥ n . Thus, if n ≥ n , 0 0 0
′ k f ( n ) ≤ k c g ( n ) = c g ( n ),
′ where c = k c is a positive constant. By the definition of Big-O, kf ( n ) = O ( g ( n )) .

1 2 2 Example 7.31. Example 7.19 showed that 7.30 to n + 3 n = Θ( n ). We can use Theorem
2 ) (
1 2 2 2 2 n + 3 n . conclude that n + 6 n = Θ( n ) since n + 6 n = 2
2
Perhaps now is a good time to point out a related issue. Typica lly, we do not include constants
3 inside asymptotic notations. For instance, although it is t echnically correct to say that 34 n +
2 3 3 2 n − 45 n + 5 = O (5 n ) (or O (50 n ), or any other constant you care to place there), it is best to
3 just say it is O ( n ). In particular, Θ(1) may be preferable to Θ( k ).
Theorem 7.32. Sums
If f ( n ) = O ( g ( n )) and f ( n ) = O ( g ( n )) , then 1 1 2 2
f ( n ) + f ( n ) = O ( g ( n ) + g ( n )) = O ( max { g ( n ), g ( n ) } ). 1 2 1 2 1 2
Similarly for Θ and Ω .
Proof: We will prove the assertion for Big-O. Assume f ( n ) = O ( g ( n )) and 1 1
f ( n ) = O ( g ( n )) . Then there exists positive constants c and n such that for all 2 2 1 1
n ≥ n , 1
f ( n ) ≤ c g ( n ), 1 1 1
and there exists positive constants c and n such that for all n ≥ n , 2 2 2
f ( n ) ≤ c g ( n ). 2 2 2
Let c = max { c , c } and n = max { n , n } . Since n is at least as large as n 0 1 2 0 1 2 0 1
and n , then for all n ≥ n , f ( n ) ≤ c g ( n ) and f ( n ) ≤ c g ( n ) . (If you don’t 2 0 1 1 1 2 2 2
see why this is, think about it. This is a subtle but important s tep.) Similarly, if
f ( n ) ≤ c g ( n ) , then clearly f ( n ) ≤ c g ( n ) since c is at least as big as c (and 1 1 1 1 0 1 0 1

Asymptotic Notation 233
similarly for f ). Then for all n ≥ n , we have 2 0
f ( n ) + f ( n ) ≤ c g ( n ) + c g ( n ) 1 2 1 1 2 2
≤ c g ( n ) + c g ( n ) 0 1 0 2
≤ c [ g ( n ) + g ( n )] 0 1 2
≤ c [max { g ( n ), g ( n ) } + max { g ( n ), g ( n ) } ] 0 1 2 1 2
≤ 2 c max { g ( n ), g ( n ) } 0 1 2
≤ c max { g ( n ), g ( n ) } , 1 2
where c = 2 c . By the definition of Big-O, we have shown that f ( n ) + f ( n ) = 0 1 2
O ( max { g ( n ), g ( n ) } ) .  1 2
Notice that in this proof we used c = 2 max { c , c } and n = max { n , n } . 1 2 0 1 2
Without getting too technical, the previous theorem implie s that you can upper bound the
sum of two or more functions by finding the upper bound of the fa stest growing of the functions.
Another way of thinking about it is if you ever have two or more functions inside Big-O notation,
you can simplify the notation by omitting the slower growing function(s). It should be pointed
out that there is a subtle point in this result about how to pre cisely define the maximum of two
functions. Most of the time the intuitive definition is suffici ent so we won’t belabor the point.
2 2 3 2 Example 7.33. Since we have previously shown that 5 n − 3 n +20 = O ( n ) and that 3 n − 2 n +
3 2 3 2 2 3 3 13 n − 15 = O ( n ), we know that (5 n − 3 n +20)+(3 n − 2 n +13 n − 15) = O ( n + n ) = O ( n ).
Theorem 7.34. Products
If f ( n ) = O ( g ( n )) and f ( n ) = O ( g ( n )) , then 1 1 2 2
f ( n ) f ( n ) = O ( g ( n ) g ( n )). 1 2 1 2
Similarly for Θ and Ω .
2 2 3 Example 7.35. Since we have previously shown that 5 n − 3 n + 20 = O ( n ) and that 3 n −
2 3 2 3 2 2 3 5 2 n +13 n − 15 = O ( n ), we know that (5 n − 3 n +20)(3 n − 2 n +13 n − 15) = O ( n n ) = O ( n ).
Notice that we could arrive at this same conclusion by multip lying the two polynomials and
taking the highest term. However, this would require a lot mo re work than is necessary.
The next theorem essentially says that if g ( n ) is an upper bound on f ( n ), then f ( n ) is a lower
bound on g ( n ). This makes perfect sense if you think about it.
Theorem 7.36. Symmetry (sort of)
f ( n ) = O ( g ( n )) iff g ( n ) = Ω( f ( n )) .
+ + It turns out that Θ defines an equivalence relation on the set o f functions from Z to Z . That
is, it defines a partition on these functions, with two functi ons being in the same partition (or the
same equivalence class) if and only if they have the same grow th rate. But don’t take our word for
it. You will help to prove this fact next.

234 Chapter 7
+ + ⋆ Fill in the details 7.37. Let R be the relation on the set of functions from Z to Z such
that ( f , g ) ∈ R if and only if f = Θ( g ). Show that R is an equivalence relation.
Proof: We need to show that R is reflexive, symmetric, and transitive.
Reflexive: Since 1 · f ( n ) ≤ f ( n ) ≤ 1 · f ( n ) for all n ≥ 1, f ( n ) = Θ( f ( n )), so R is
reflexive.
Symmetric: If f ( n ) = Θ( g ( n )), then there exist positive constants c , c , and n 1 2 0
such that
This implies that
1 1
g ( n ) ≤ f ( n ) and g ( n ) ≥ f ( n ) for all n ≥ n 0
c c 1 2
which is equivalent to
≤ g ( n ) ≤ for all n ≥ n . 0
Thus g ( n ) = Θ( f ( n )), and R is symmetric.
Transitive: If f ( n ) = Θ( g ( n )), then there exist positive constants c , c , and n 1 2 0
such that
c g ( n ) ≤ f ( n ) ≤ c g ( n ) for all n ≥ n . 1 2 0
Similarly if g ( n ) = Θ( h ( n )), then there exist positive constants c , c , and n such 3 4 1
that
Then
f ( n ) ≥ c g ( n ) ≥ c c h ( n ) for all n ≥ max { n , n } , 1 1 3 0 1
and
f ( n ) ≤ g ( n ) ≤ h ( n ) for all n ≥
Thus, ≤ f ( n ) ≤ for all n ≥ max { n , n } . 0 1
Since c c and c c are both positive constants, f ( n ) = by the 1 3 2 4
definition of , so R is . 
2 2 2 2 2 Example 7.38. The functions n , 3 n − 4 n + 4, n + log n , and 3 n + n + 1 are all Θ( n ).
That is, they all have the same rate of growth and all belong to the same equivalence class.

Asymptotic Notation 235
⋆ Exercise 7.39. Let’s test your understanding of the material so far. Answer each of the
following true/false questions, giving a very brief justifi cation/counterexample. Justifications
can appeal to a definition and/or theorem. For counterexampl es, use simple functions. For
2 instance, f ( n ) = n and g ( n ) = n .
If f ( n ) = O ( g ( n )), then g ( n ) = Ω( f ( n )) (a)
(b) If f ( n ) = Θ( g ( n )), then f ( n ) = Ω( g ( n )) and f ( n ) = O ( g ( n ))
(c) If f ( n ) = O ( g ( n )) and f ( n ) = O ( g ( n )), then f ( n ) + f ( n ) = O ( max ( g ( n ), g ( n ))) 1 1 2 2 1 2 1 2
(d) f ( n ) = O ( g ( n )) iff f ( n ) = Θ( g ( n ))
(e) f ( n ) = O ( g ( n )) iff g ( n ) = O ( f ( n ))
f ( n ) = O ( g ( n )) iff g ( n ) = Ω( f ( n )) (f)
f ( n ) = Θ( g ( n )) iff f ( n ) = Ω( g ( n )) and f ( n ) = O ( g ( n )) (g)
(h) If f ( n ) = O ( g ( n )) and g ( n ) = O ( h ( n )), then f ( n ) = O ( h ( n ))
7.1.3  Proofs using the definitions
In this section we provide more examples and exercises that u se the definitions to prove bounds.
The first example is annotated with comments (given in footno tes) about the techniques that
are used in many of these proofs. We use the following termino logy in our explanation. By lower
order term we mean a term that grows slower, and higher order means a term that grows faster.
3 2 2 The dominating term is the term that grows the fastest. For instance, in x + 7 x − 4, the x term
3 3 is a lower order term than x , and x is the dominating term. We will discuss common growth
7.2 . But for now we assume you know rates, including how they relate to each other, in Section
5 3 that x grows faster than x , for instance.

236 Chapter 7
8 7 5 4 2 Example 7.40. Find a tight bound on f ( n ) = n + 7 n − 10 n − 2 n + 3 n − 17.
8 Solution: We will prove that f ( n ) = Θ( n ). First, we will prove an upper bound
for f ( n ). It is clear that when n ≥ 1,
8 7 5 4 2 8 7 2 a n + 7 n − 10 n − 2 n + 3 n − 17 ≤ n + 7 n + 3 n
8 8 8 b ≤ n + 7 n + 3 n
8 =  11 n
Thus, we have
8 7 5 4 2 8 f ( n ) = n + 7 n − 10 n − 2 n + 3 n − 17 ≤ 11 n for all n ≥ 1,
8 and we have proved that f ( n ) = O ( n ).
Now, we will prove the lower bound for f ( n ). When n ≥ 1,
8 7 5 4 2 8 5 4 c n + 7 n − 10 n − 2 n + 3 n − 17 ≥ n − 10 n − 2 n − 17
8 7 7 7 d ≥ n − 10 n − 2 n − 17 n
8 7 = n − 29 n
8 7 8 Next, we need to find a value c > 0 such that n − 29 n ≥ cn . Doing a little
8 7 algebra, we see that this is equivalent to (1 − c ) n ≥ 29 n . When n ≥ 1, we can
7 divide by n and obtain (1 − c ) n ≥ 29. Solving for c we obtain
29
. c ≤ 1 −
n
If n ≥ 58, then c = 1 / 2 suffices. We have just shown that if n ≥ 58, then
1 8 7 5 4 2 8
f ( n ) = n + 7 n − 10 n − 2 n + 3 n − 17 ≥ n .
2
8 8 Thus, f ( n ) = Ω( n ). Since we have shown that f ( n ) = Ω( n ) and that f ( n ) =
8 8 O ( n ), we have shown that f ( n ) = Θ( n ).
a We can upper bound any function by removing the lower order te rms with negative coefficients, as long as
n ≥ 0.
b We can upper bound any function by replacing lower order term s that have positive coefficients by the
dominating term with the same coefficients. Here, we must make sure that the dominating term is larger than
the given term for all values of n larger than some threshold n , and we must make note of the threshold value 0
n . 0
c We can lower bound any function by removing the lower order te rms with positive coefficients, as long as
n ≥ 0.
d We can lower bound any function by replacing lower order term s with negative coefficients by a sub-
dominating term with the same coefficients.  (By sub-dominati ng, I mean one which dominates all but the
dominating term.) Here, we must make sure that the sub-domin ating term is larger than the given term for all
values of n larger than some threshold n , and we must make note of the threshold value n . Making a wise 0 0
choice for which sub-dominating term to use is crucial in fini shing the proof.
Let’s see another example of a Ω proof. You should note the sim ilarities between this and the
second half of the proof in the previous example.

Asymptotic Notation 237
Example 7.41. Show that ( n log n − 2 n + 13) = Ω( n log n )
Proof: We need to show that there exist positive constants c and n such that 0
c n log n ≤ n log n − 2 n + 13 for all n ≥ n . 0
Since n log n − 2 n ≤ n log n − 2 n + 13, we will instead show that
c n log n ≤ n log n − 2 n ,
which is equivalent to
2
c ≤ 1 − , when n > 1.
log n
If n ≥ 8, then 2 / (log n ) ≤ 2 / 3, and picking c = 1 / 3 suffices. In other words, we
have just shown that if n ≥ 8,
1
n log n ≤ n log n − 2 n .
3
Thus if c = 1 / 3 and n = 8, then for all n ≥ n , we have 0 0
c n log n ≤ n log n − 2 n ≤ n log n − 2 n + 13.
Thus ( n log n − 2 n + 13) = Ω( n log n ). 
1 2 2 n − 3 n = Θ( n ) ⋆ Fill in the details 7.42. Show that
2
Proof: We need to find positive constants c , c , and n such that 1 2 0
1 2
n − 3 n ≤ ≤ for all n ≥ n 0
2
2 ≤ c . Dividing by n , we get c ≤
2 1
3 1 3 1 − ≥ − = Notice that if n ≥ 10, , so we can choose
2 n 2 10
3 1 1 − ≤ , so we can choose c = 1 / 2. Thus, c = 1 / 5. If n ≥ 10, we also have that
2 1 2 n 2
we have shown that
1 2
n − 3 n ≤ ≤ for all n ≥ .
2
1 2 2 n − 3 n = Θ( n ).  Therefore,
2

238 Chapter 7
⋆ Question 7.43. In the previous proof, we claimed that if n ≥ 10,
3 1 3 1
− ≥ − .
2 n 2 10
Why is this true?
Answer
√ √
log n Example 7.44. Show that ( 2) = O ( n ), where the base of the log is 2.
Proof: It is not too hard to see that
√ √ √ 1 1 1 / 2
log n log 2 log 2 log 2 2 2 2) = n n . = n = n = = n (
√ √
log n Thus it is clear that ( 2) = O ( n ). 
Note: You may be confused by the previous proof.  It seems that we neve r showed that √ √
√ √ log n log n
( 2) ≤ c n for some constant c . But we essentially did by showing that ( 2) = n √
√ log n
2) ≤ 1 n . since this implies that (
We actually proved something stronger than was required. Tha t is, since we proved the two √
√ log n
functions are equal, it is in fact true that ( 2) = Θ( n ) . But we were only asked to prove √
√ log n
2) = O ( n ) . that (
In general, if you need to prove a Big-O bound, you may instead p rove a Θ bound, and the
Big-O bound essentially comes along for the ride.
⋆ Question 7.45. In our previous note we mentioned that if you prove a Θ bound, y ou get
the Big-O bound for free.
(a) What theorem implies this?
Answer
(b) If we prove f ( n ) = O ( g ( n )), does that imply that f ( n ) = Θ( g ( n ))? In other words, does
it work the other way around? Explain, giving an appropriate example.
Answer

Asymptotic Notation 239
n ⋆ Exercise 7.46. Show that n ! = O ( n ). (Don’t give up too easily on this one—the proof is
very short and only uses elementary algebra.)
Example 7.47. Show that log( n !) = O ( n log n )
n Proof: It should be clear that if n ≥ 1, n ! ≤ n (especially after completing the
previous exercise). Taking logs of both sides of that inequa lity, we obtain
n log n ! ≤ log( n ) = n log n .
Therefore log n ! = O ( n log n ). 
a The last step used the fact that log( f ( n ) ) = a log( f ( n )), a fact that we assume you have seen
previously (but may have forgotten).
Proving properties of the asymptotic notations is actually no more difficult than the rest of the
proofs we have seen. You have already seen a few and helped wri te one. Here we provide one more
example and then ask you to prove another result on your own.
Example 7.48. Prove that if f ( n ) = O ( g ( n )) and g ( n ) = O ( f ( n )), then f ( n ) = Θ( g ( n )).
′ such that Proof: If f ( n ) = O ( g ( n )), then there are positive constants c and n
2 0
′ f ( n ) ≤ c g ( n ) for all n ≥ n
2 0
′ ′′ Similarly, if g ( x ) = O ( f ( x )), then there are positive constants c and n such that
1 0
′ ′′ f ( n ) for all n ≥ n . g ( n ) ≤ c
1 0
′ to obtain We can divide this by c
1
1 ′′
g ( n ) ≤ f ( n ) for all n ≥ n . 0 ′
c 1

240 Chapter 7
′′ ′ ′ } , we have , n and n = max { n Setting c = 1 /c
0 1 0 0 1
c g ( n ) ≤ f ( n ) ≤ c g ( n ) for all n ≥ n . 1 2 0
Thus, f ( x ) = Θ( g ( x )). 
⋆ Exercise 7.49. Let f ( x ) = O ( g ( x )) and g ( x ) = O ( h ( x )). Show that f ( x ) = O ( h ( x )). That
7.28 for Big-O notation. is, prove Theorem
7.1.4  Proofs using limits
So far we have used the definitions of the various notations in all of our proofs. The following
theorem provides another technique that is often much easie r, assuming you understand and are
comfortable with limits.
Theorem 7.50. Let f ( n ) and g ( n ) be functions such that
f ( n )
= A . lim
n →∞ g ( n )
Then
1. If A = 0 , then f ( n ) = O ( g ( n )) , and f ( n ) 6 = Θ( g ( n )) . That is, f ( n ) = o ( g ( n )) .
2. If A = ∞ , then f ( n ) = Ω( g ( n )) , and f ( n ) 6 = Θ( g ( n )) . That is, f ( n ) = ω ( g ( n )) .
3. If A 6 = 0 is finite, then f ( n ) = Θ( g ( n )) .
If the above limit does not exist, then you need to resort to us ing the definitions or using some
other technique. Luckily, in the analysis of algorithms the above approach works most of the time.
Before we see some examples, let’s review a few limits you sho uld know.

Asymptotic Notation 241
Theorem 7.51. Let a and c be real numbers. Then
(a) lim a = a
n →∞
a (b) If a > 0 , lim n = ∞
n →∞
a (c) If a < 0 , lim n = 0
n →∞
n (d) If a > 1 , lim a = ∞
n →∞
n (e) If 0 < a < 1 , lim a = 0
n →∞
(f) If c > 0 , lim log n = ∞ . c
n →∞
Example 7.52. The following are examples based on Theorem 7.51 .
(a)  lim 13 = 13
n →∞
(b)  lim n = ∞
n →∞
4 (c)  lim n = ∞
n →∞
1 / 2 (d)  lim n = ∞
n →∞
− 2 (e)  lim n = 0
n →∞
Å ã n
1
= 0 (f)  lim
n →∞ 2
n (g)  lim 2 = ∞
n →∞
(h)  lim log n = ∞ 2
n →∞
Now it’s your turn to try a few.
⋆ Exercise 7.53. Evaluate the following limits
(a)  lim log n = 10
n →∞
3 (b)  lim n =
n →∞
n (c)  lim 3 =
n →∞
ã Å n
3
= (d)  lim
n →∞ 2

242 Chapter 7
Å ã n
2
(e)  lim =
n →∞ 3
− 1 (f)  lim n =
n →∞
(g)  lim 8675309 =
n →∞
8 8 Example 7.54. Prove that 5 n = Θ( n ) using Theorem 7.50 .
Solution: Notice that
8 5 n
lim = lim 5 = 5, 8
n →∞ n →∞ n
8 so f ( n ) = Θ( n ) by Theorem 7.50 (case 3).
The following theorem often comes in handy when using Theore m 7.50 .
1
= 0 . Theorem 7.55. If lim f ( n ) = ∞ , then lim
n →∞ n →∞ f ( n )
2 4 Example 7.56. Prove that n = o ( n ) using Theorem 7.50 .
Solution: Notice that
2 n 1
lim = lim = 0, 4 2
n →∞ n →∞ n n
4 7.50 (case 1). so f ( n ) = o ( n ) by Theorem
⋆ Question 7.57. The proof in the previous example used Theorems 7.51 and 7.55 . How and
where?
Answer

Asymptotic Notation 243
3 2 ⋆ Exercise 7.58. Prove that 3 x = Ω( x ) using Theorem 7.50 . Which case did you use?
Here are a few more useful properties of limits.  Read careful ly.  These do not apply in all
situations.
Theorem 7.59. Let a be a finite real number and let lim f ( n ) = A and lim g ( n ) = B , where
n →∞ n →∞
A and B are finite real numbers. Then
(a) lim a f ( n ) = a A
n →∞
(b) lim f ( n ) ± g ( n ) = A ± B
n →∞
(c) lim f ( n ) g ( n ) = AB
n →∞
f ( n ) A
(d) If B 6 = 0 , lim =
n →∞ g ( n ) B
We usually use the results from the previous theorem without explicitly mentioning them.
8 7 5 4 2 Example 7.60. Find a tight bound on f ( x ) = x + 7 x − 10 x − 2 x + 3 x − 17 using
Theorem 7.50 .
8 7.40 ) that f ( x ) = Θ( x ). Solution: We guess (or know, if we remember the solution to Example
To prove this, notice that
7 5 4 2 8 7 x 10 x 2 x 3 x 17 x 17
8 7 5 4 2 =  lim + − − + − lim x +7 x − 10 x − 2 x +3 x −
8 8 8 8 8 8 8 x →∞ x →∞ x x x x x x x
7 10 2 3 17
=  lim 1 + − − + − 3 4 6 8
x →∞ x x x x x
=  1 + 0 − 0 − 0 + 0 − 0 = 1
8 7.50 . Thus, f ( x ) = Θ( x ) by the Theorem
Compare the proof above with the proof given in Example 7.40 . It should be pretty obvious that
using Theorem 7.50 makes the proof a lot easier. Let’s see another example that l ets us compare
the two proof methods.

244 Chapter 7
4 3 2 4 Example 7.61. Prove that f ( x ) = x − 23 x + 12 x + 15 x − 21 = Θ( x ).
Proof #1
We will use the definition of Θ. It is clear that when x ≥ 1,
4 3 2 4 2 4 4 4 4 x − 23 x + 12 x + 15 x − 21 ≤ x + 12 x + 15 x ≤ x + 12 x + 15 x = 28 x .
1 1 4 3 3 4 x ≥ 44 x or − 44 x ≥− x , so we have that Also, if x ≥ 88, then
2 2
1 4 3 2 4 3 4 3 3 4 3 4
x − 23 x +12 x +15 x − 21 ≥ x − 23 x − 21 ≥ x − 23 x − 21 x = x − 44 x ≥ x .
2
Thus
1 4 4 3 2 4
x ≤ x − 23 x + 12 x + 15 x − 21 ≤ 28 x , for all x ≥ 88.
2
4 3 2 4 We have shown that f ( x ) = x − 23 x + 12 x + 15 x − 21 = Θ( x ). 
If you did not follow the steps in this first proof, you should r eally review your
algebra rules.
Proof #2
Since
3 2 4 4 3 2 23 x 12 x 15 x 21 x x − 23 x + 12 x + 15 x − 21
=  lim − + + − lim 4 4 4 4 4 4
x →∞ x →∞ x x x x x x
23 12 15 21
=  lim 1 − + + − 2 3 4
x →∞ x x x x
=  lim 1 − 0 + 0 + 0 − 0 = 1,
x →∞
4 3 2 4 f ( x ) = x − 23 x + 12 x + 15 x − 21 = Θ( x ) 
3 Example 7.62. Prove that n ( n + 1) / 2 = O ( n ) using Theorem 7.50 .
2 1 n + n 1 n ( n + 1) / 2
= lim = lim + = 0 + 0 = 0, Proof: Because  lim 3 3 2
n →∞ n →∞ n →∞ n 2 n 2 n 2 n
3 3 n ( n + 1) / 2 = o ( n ), which implies that n ( n + 1) / 2 = O ( n ). 
2 ⋆ Exercise 7.63. Prove that n ( n + 1) / 2 = Θ( n ) using Theorem 7.50 .

Asymptotic Notation 245
x x ⋆ Exercise 7.64. Prove that 2 = O (3 )
7.50 . (a) Using Theorem
(b) Using the definition of Big-O.
Now is probably a good time to recall a very useful theorem for computing limits, called
l’Hopital’s Rule . The version presented here is restricted to limits where th e variable approaches
infinity since those are the only limits of interest in our con text.
Theorem 7.65 (l’Hopital’s Rule) . Let f ( x ) and g ( x ) be differentiable functions. If
lim f ( x ) = lim g ( x ) = 0 or
x →∞ x →∞
lim f ( x ) = lim g ( x ) = ∞ ,
x →∞ x →∞
then
′ f ( x ) f ( x )
lim = lim ′
x →∞ x →∞ g ( x ) g ( x )
2 Example 7.66. Since lim 3 x = ∞ and lim x = ∞ ,
x →∞ x →∞
3 3 x
=  lim (l’Hopital) lim 2
x →∞ x →∞ x 2 x
3 1
= lim
x →∞ 2 x
3
0 =
2
=  0.

246 Chapter 7
2 Example 7.67. Since lim 3 x + 4 x − 9 = ∞ and lim 12 x = ∞ ,
x →∞ x →∞
2 6 x + 4 3 x + 4 x − 9
=  lim (l’Hopital) lim
x →∞ x →∞ 12 x 12
1 1
=  lim x +
x →∞ 2 3
= ∞
Now let’s apply it to proving asymptotic bounds.
Example 7.68. Show that log x = O ( x ).
Proof: Notice that
1 log x
x =  lim (l’Hopital) lim
x →∞ x →∞ x 1
1
= 0. =  lim
x →∞ x
Therefore, log x = O ( x ). 
We should mention that applying l’Hopital’s Rule in the first step is legal since
lim log x = lim x = ∞ .
x →∞ x →∞
3 x Example 7.69. Prove that x = O (2 ).
Proof: Notice that
3 2 x 3 x
lim =  lim (l’Hopital) x x
x →∞ x →∞ 2 2 ln(2)
6 x
=  lim (l’Hopital) 2
x x →∞ 2 ln (2)
6
=  lim (l’Hopital) 3
x x →∞ 2 ln (2)
=  0.
3 x Therefore, x = O (2 ).
As in the previous example, at each step we checked that the fu nctions on both the
top and bottom go to infinity as n goes to infinity before applying l’Hopital’s Rule.
Notice that we did not apply it in the final step since 6 does not go to infinity. 

Asymptotic Notation 247
x x ⋆ Evaluate 7.70. Prove that 7 is an upper bound for 5 , but that it is not a tight bound.
x x Proof   1: This    is    true    if    and    only    if    7 always    grows    faster    than    5 which
x x x x means  7 − 5 > 0  for  all  x 6 =  0.   If  it  is  a  tight  bound,  then  7 − 5 =  0,  which
x x is  only  true  for  x  =  0.   So  7 is  an  upper  bound  on  5 ,  but  not  a  tight  bound.
Evaluation
x x log 5 5
. Both   go   to   infinity,    but   x log 7   gets   there =    lim Proof   2: lim x
x →∞ x →∞ 7 x log 7
x x faster,  showing   that   5 =  O(7 ).
Evaluation
Å ã x x
7 7 x x
Proof   3: lim =    lim = ∞ since   7 / 5 > 1. Thus   5 =  O(7 )   by   the   limit x
x →∞ x →∞ 5 5
theorem.
Evaluation
We should mention that it is important to remember to verify t hat l’Hopital’s Rule applies before
just blindly taking derivatives. You can actually get the in correct answer if you apply it when it
should not be applied.
√
2 Example 7.71. Find and prove a simple tight bound for 5 n − 4 n + 12.
√
2 Solution: We will show that 5 n − 4 n + 12 = Θ( n ). Since we are letting n go
√
2 n . Using this, we can to infinity, we can assume that n > 0. In this case, n =
see that
  ... √
2 2 √ 12 5 n 5 n − 4 n + 12 4 − 4 n + 12
= lim + = lim = lim 5 − 5. 2 2
n →∞ n →∞ n →∞ n n n n
√
2 5 n − 4 n + 12 = Θ( n ). Therefore,

248 Chapter 7
2 2 ⋆ Exercise 7.72. Find and prove a good simple upper bound on n ln( n + 1) + n ln n .
(a) Using the definition of Big-O.
7.50 . You will probably need to use l’Hopital’s Rule a few times. (b) Using Theorem

Asymptotic Notation 249
2 2 Example 7.73. Find and prove a simple tight bound for n log( n ) + ( n − 1) log( n/ 2).
Solution: First notice that
2 2 2 n log( n ) + ( n − 1) log( n/ 2) = 2 n log n + ( n − 1) (log n − log 2).
2 We can see that this is Θ( n log n ) since
2 2 2 2 n log n + ( n − 1) (log n − log 2) n log( n ) + ( n − 1) log( n/ 2)
=  lim lim 2 2
n →∞ n →∞ n log n n log n
2 (log n − log 2) 2 ( n − 1)
=  lim + 2
n →∞ n n log n
Å ã Å ã 2
2 1 log 2
=  lim + 1 − 1 −
n →∞ n n log n
2 =  0 + (1 − 0) (1 − 0) = 1.
2 5 ⋆ Exercise 7.74. Find and prove a simple tight bound for ( n − 1) . You may use either the
7.50 . (The solution uses Theorem 7.50 .) formal definition of Θ or Theorem

250 Chapter 7
n +1 n − 1 ⋆ Exercise 7.75. Find and prove a simple tight bound for 2 + 5 . You may use either
7.50 . (The solution uses Theorem 7.50 .) the formal definition of Θ or Theorem

Common Growth Rates 251
7.2  Common Growth Rates
In this section we will take a look at the relative growth rate s of various functions.
2 3 n log n n n ln n n n 2
2 Figure 7.1 shows the value of several functions for
0. 000 1 0 1 1 2
various values of n to give you an idea of their 1. 000 2 1. 39 4 8 4
1. 585 3 3. 30 9 27 8 relative rates of growth. The bottom of the table
2. 000 4 5. 55 16 64 16 is labeled relative to the last column so you can
2. 321 5 8. 05 25 125 32
get a sense of how slow log m and log (log m ) 2 2 2 2. 585 6 10. 75 36 216 64
grow.  For instance, the final row is showing 2. 807 7 13. 62 49 343 128
3. 000 8 16. 64 64 512 256 that log (262144) = 18 and log (log (262144)) = 2 2 2
3. 170 9 19. 78 81 729 512 4. 170.
3. 321 10 23. 03 100 1000 1024
7.2 and 7.3 demonstrate that as n in- Figures
3. 460 11 26. 38 121 1331 2048
creases, the constants and lower-order terms do 3. 585 12 29. 82 144 1728 4096
not matter.  For instance, notice that although 3. 700 13 33. 34 169 2197 8192
n 3. 807 14 36. 95 196 2744 16384 100 n is much larger than 2 for small values of n ,
3. 907 15 40. 62 225 3375 32768 n as n increases, 2 quickly gets much larger than
4. 000 16 44. 36 256 4096 65536
7.3 , notice that when 100 n . Similarly, in Figure 4. 087 17 48. 16 289 4913 131072
3 3 n = 74, n and n + 234 are virtually the same. 4. 170 18 52. 03 324 5832 262144
log log m log m m 2 2 2
Figure 7.1: A comparison of growth rates
2 2 3 n 2 2 2 3 3 n 100 n n 11 n n 2 n n n − n n + 99 n n + 234
1 100 1 11 1 2 2 4 2 103 8 242
2 200 4 44 8 4 6 36 30 135 216 450
3 300 9 99 27 8 10 100 90 199 1000 1234
4 400 16 176 64 16 14 196 182 295 2744 2978
5 500 25 275 125 32 18 324 306 423 5832 6066
6 600 36 396 216 64 22 484 462 583 10648 10882
7 700 49 539 343 128 26 676 650 775 17576 17810
8 800 64 704 512 256 30 900 870 999 27000 27234
9 900 81 891 729 512 34 1156 1122 1255 39304 39538
10 1000 100 1100 1000 1024 38 1444 1406 1543 54872 55106
11 1100 121 1331 1331 2048 42 1764 1722 1863 74088 74322
12 1200 144 1584 1728 4096 46 2116 2070 2215 97336 97570
13 1300 169 1859 2197 8192 50 2500 2450 2599 125000 125234
14 1400 196 2156 2744 16384 54 2916 2862 3015 157464 157698
15 1500 225 2475 3375 32768 58 3364 3306 3463 195112 195346
16 1600 256 2816 4096 65536 62 3844 3782 3943 238328 238562
17 1700 289 3179 4913 131072 66 4356 4290 4455 287496 287730
18 1800 324 3564 5832 262144 70 4900 4830 4999 343000 343234
19 1900 361 3971 6859 524288 74 5476 5402 5575 405224 405458
Figure 7.2: Constants don’t matter Figure 7.3: Lower-order terms don’t matter
Figures 7.4 through 7.8 give a graphical representation of relative growth rates of functions. In
2 these diagrams, ** means exponentiation. For instance, x**2 means x .
It is important to point out that you should never rely on the graphs of functions to determine
7.6 and 7.7 . Although graphs sometimes give relative growth rates. That is the point of Figures

252 Chapter 7
Slow Growing Functions Polynomial Functions
250 40000
log(x) x
x x**2 35000
x*log(x) x**3 200
30000 x**2 x**4
25000 150
20000
100 15000
10000
50
5000
0 0
0 5 10 15 20 25 30 35 40 0 5 10 15 20 25 30 35 40
Figure 7.4: Slow growing functions. Figure 7.5: Polynomials.
Fast Growing Functions Part 1 Fast Growing Functions Part 2
5000 500000
x x 4500 450000
x**3 x**3
x**4 x**4 4000 400000
2**x 2**x 3500 350000
3000 300000
2500 250000
2000 200000
1500 150000
1000 100000
500 50000
0 0
0 2 4 6 8 10 0 5 10 15 20
Figure 7.6: Polynomials and an exponential.  It Figure 7.7: Polynomials and an exponential with
4 x n 4 looks like x grows faster than 2 , but see Fig larger n . Clearly 2 grows faster than n . 7.7 .
Why Constants and Non-Leading Terms Don’t Matter
4e+08
1000000*x
300000*x**2 + 300*x 3.5e+08
2**x
3e+08
2.5e+08
2e+08
1.5e+08
1e+08
5e+07
0
0 5 10 15 20 25 30
Figure 7.8: Notice that as n gets larger, the
constants eventually matter less.
you an accurate picture of the relative growth rates of the fu nctions, they might just as well present
a distorted view of the data depending on the values that are u sed on the axes. Instead, you should
use the techniques we develop in this section.
Next we present some of the most important results about the r elative growth rate of some
common functions.  We will ask you to prove each of them.  Theor ems 7.50 and 7.65 will help

Common Growth Rates 253
you do so. You will notice that most of the theorems are using l ittle-o, not Big-O. Hopefully you
understand the difference. If not, review those definitions be fore continuing.
We begin with something that is pretty intuitive: higher pow ers grow faster than lower powers.
a b Theorem 7.76. Let a < b be real numbers. Then n = o ( n ) .
2 3 5 5.1 Example 7.77. According to Theorem 7.76 , n = o ( n ) and n = o ( n ).
⋆ Exercise 7.78. Prove Theorem 7.76 . (Hint: Use Theorem 7.50 and do a little algebra before
you try to compute the limit.)
The next theorem tells us that exponentials with different bas es do not grow at the same rate.
More specifically, the higher the base, the faster the growth rate.
n n Theorem 7.79. Let 0 < a < b be real numbers. Then a = o ( b ) .
n n n n Example 7.80. According to Theorem 7.79 , 2 = o (5 ) and 4 = o (4. 5 ).
⋆ Exercise 7.81. Prove Theorem 7.79 . (See the hint for Exercise 7.78 .)

254 Chapter 7
x Recall that a logarithmic function is the inverse of an expon ential function. That is, b = n is
equivalent to x = log n . The following identity is very useful. b
Theorem 7.82. Let a , b , and x be positive real numbers with a 6 = 1 and b 6 = 1 . Then
log x b
. log x = a
log a b
Example 7.83. Most calculators can compute ln n or log n , but are unable to compute 10
logarithms with any given base. But Theorem 7.82 allows you to do so. For instance, you can
compute log 39 as log 39 / log 2. 2 10 10
7.82 can be rearranged as (log a )(log x ) = log x . This Notice that the formula in Theorem b a b
form should make it evident that changing the base of a logari thm just changes the value by a
constant amount. This leads to the following result.
Corollary 7.84. Let a and b be positive real numbers with a 6 = 1 and b 6 = 1 .
Then log n = Θ(log n ) . a b
Proof: Follows from the definition of Θ and Theorem 7.82 . 
Example 7.85. According to Corollary 7.84 , log n = Θ(log n ) and ln n = Θ(log n ). 2 10 2
7.84 is stating that all logarithms have the same rate of growth re gardless of their Corollary
bases. That is, the base of a logarithm does not matter when it is used in asymptotic notation.
Because of this, the base is often omitted in asymptotic nota tion. In computer science, it is usually
safe to assume that the base of logarithms is 2 if it is not spec ified.
⋆ Exercise 7.86. Indicate whether each of the following is true (T) or false (F).
n n (a) 2 = Θ(3 )
n n (b) 2 = o (3 )
n n (c) 3 = O (2 )
(d) log n = Θ(log n ) 3 2
(e) log n = O (log n ) 2 3
log n = o (log n ) (f) 10 3
Next we see that logarithms grow slower than positive powers of n .

Common Growth Rates 255
b Theorem 7.87. Let b > 0 and c > 0 be real numbers. Then log ( n ) = o ( n ) .
c
2 1.01 Example 7.88. According to Theorem 7.87 , log n = o ( n ), log n = o ( n ), and ln n =
2 10 √
n ). o (
⋆ Exercise 7.89. Prove Theorem 7.87 . (Hint: This is easy if you use Theorems 7.50 and 7.65 )
More generally, the next theorem states that any positive po wer of a logarithm grows slower
than any positive power of n . Since this one is a little tricky, we will provide the proof. In case
a a you have not seen this notation before, you should know that l og n means (log n ) , which is not
a the same thing as log( n ).
a b Theorem 7.90. Let a > 0 , b > 0 , and c > 0 be real numbers. Then log ( n ) = o ( n ) . In other
c
words, any power of a log grows slower than any polynomial.
Proof: First, we need to know that if a > 0 is a constant, and lim f ( n ) = C ,
n →∞
then ( ) a
a a lim ( f ( n )) = lim f ( n ) = C .
n →∞ n →∞
7.87 , we have that Using this and the limit computed in the proof of Theorem
Å ã ã Å a a a
log ( n ) ( n ) log log ( n ) c c c a
= lim = 0 = 0. lim = lim b b/a b/a
n →∞ n →∞ n →∞ n n n
a b Thus, Theorem 7.50 tells us that log ( n ) = o ( n ) . 
c
√ 4 10 2
Example 7.91. According to Theorem 7.90 , log n ), and n = o ( n = o ( n ), ln 2
1,000,000 .00000001
n = o ( n ). log 10
Finally, any exponential function with base larger than 1 gr ows faster than any polynomial.

256 Chapter 7
a n Theorem 7.92. Let a > 0 and b > 1 be real numbers. Then n = o ( b ) .
2 n 15 n Example 7.93. According to Theorem 7.92 , it is easy to see that n = o (2 ), n = o (1. 5 ),
1,000,000 n and n = o (1. 0000001 ).
7.92 , including using repeated applications of l’Hopital’s There are several ways to prove Theorem
rule, using induction, or doing a little algebraic manipula tion and using one of several clever tricks.
But the techniques are beyond what we generally need in the co urse, so we will omit a proof (and,
perhaps more importantly, we will not ask you to provide a pro of!).
⋆ Fill in the details 7.94. Fill in the following blanks with Θ, Ω, O , or o . You should give
the most precise answer possible. (e.g. If you put O , but the correct answer is o , your answer
is correct but not precise enough.)
2 ). (500 n (a) n ( n − 1) =
2 4 (b) 50 n = (. 001 n ).
(ln n ). (c) log n = 2
( ) 2 2
(d) log n = (log ( n )). 2 2
n n − 1 (2 ). (e) 2 =
n n (f) 5 = (3 ).
(g) ( n − 1)! = ( n !).
3 n (h) n = (2 ).
100 n (i) log n = (1. 01 ).
100 1.01 ( n ). (j) log n =
An alternative notation for little-o is ≪ . In other words, f ( n ) = o ( g ( n )) iff f ( n ) ≪ g ( n ). This
notation is useful in certain contexts, including the follo wing comparison of the growth rate of com-
mon functions. The previous theorems in this section provid e proofs of some of these relationships.
The others are given without proof.

Common Growth Rates 257
Theorem 7.95. Here are some relationships between the growth rates of comm on functions:
√ 1.1 2 3 4 n n n 2
n ≪ n ≪ n log n ≪ n ≪ n ≪ n ≪ n ≪ 2 ≪ 3 ≪ n ! ≪ n c ≪ log n ≪ log n ≪
You should convince yourself that each of the relationships given in the previous theorem is
correct. You should also memorize them or (preferably) unde rstand why each one is correct so you
can ‘recreate’ the theorem.
⋆ Exercise 7.96. Give a Θ bound for each of the following functions. You do not n eed to
prove them.
5 3 7 2 (a) f ( n ) = n + n + 1900 + n + 21 n + n
2 2 3 3 (b) f ( n ) = ( n + 23 n + 19)( n + 23 n + n + 19) n (Don’t make this one harder than it is)
2 (c) f ( n ) = n + 10, 000 n + 100, 000, 000, 000
n n (d) f ( n ) = 49 ∗ 2 + 34 ∗ 3
n 5 3 (e) f ( n ) = 2 + n + n
2 (f) f ( n ) = n log n + n
300 .000001 (g) f ( n ) = log n + n
n n (h) f ( n ) = n ! log n + n + 3

258 Chapter 7
⋆ Exercise 7.97. Rank the following functions in increasing rate of growth. C learly indicate
if two or more functions have the same growth rate. Assume the logs are base 2.
300 2 x 5 log 3 .000001 x 300 x , x ,  2 ,  10000,  log x , x ,  log x , x , x ,  3 , x log( x ),  log( x ),
x log(2 )

Algorithm Analysis 259
7.3  Algorithm Analysis
The overall goal of this chapter is to deal with a seemingly si mple question: Given an algorithm,
how good is it? I say “seemingly” simple because unless we define what we mean by “good”, we
cannot answer the question. Do we mean how elegant it is? How e asy it is to understand? How
easy it is to update if/when necessary? Whether or not it can b e generalized?
Although all of these may be important questions, in algorit hm analysis we are usually more
interested in the following two questions: How long does the algorithm take to run, and how much
space (memory) does the algorithm require. In fact, we follow the tradition of most books and focus
our discussion on the first question. This is usually reasona ble since the amount of memory used
by most algorithms is not large enough to matter. There are ti mes, however, when analyzing the
space required by an algorithm is important. For instance, w hen the data is really large (e.g. the
graph that represents friendships on Facebook) or when you a re implementing a space-time-tradeoff
algorithm.
Although we have simplified the question, we still need to be m ore specific. What do we mean
by “time”? Do we mean how long it takes in real time (often call ed wall-clock time )? Or the actual
amount of time our processor used (called CPU time )? Or the exact number of instructions (or
number of operations ) executed?
⋆ Question 7.98. Why aren’t wall-clock time and CPU time the same?
Answer
Because the running time of an algorithm is greatly affected by the characteristics of the com-
puter system (e.g. processor speed, number of processors, a mount of memory, file-system type,
etc.), the running time does not necessarily provide a compa rable measure, regardless of whether
you use CPU time or wall-clock time. The next question asks yo u to think about why.
⋆ Question 7.99. Sue and Stu were competing to write the fastest algorithm to s olve a
problem. After a week, Sue informs Stu that her program took 1 hour to run. Stu declared
himself victorious since his program took only 3 minutes. Bu t the real question is this: Whose
algorithm was more efficient?  Can we be certain Stu’s algorith m was better than Sue’s?
Explain. (Hint: Make sure you don’t jump to any conclusion to o quickly. Think about all of
the possibilities.)
Answer
The answer to the previous question should make it clear that you cannot compare the running
times of algorithms if they were run on different machines. Eve n if two algorithms are run on the
same computer, the wall-clock times may not be comparable.

260 Chapter 7
⋆ Question 7.100. Why isn’t the wall-clock time of two algorithms that are run on the same
computer always a reliable indicator of their relative perf ormances?
Answer
In fact, if you run the same algorithm on the same machine mult iple times, it will not always
take the same amount of time. Sometimes the differences betwee n trial runs can be significant.
⋆ Question 7.101. If two algorithms are run on the same machine, can we reliably compare
the CPU-times ?
Answer
So the CPU-time turns out to be a pretty good measure of algori thm performance. Unfortu-
nately, it does not really allow one to compare two algorithms . It only allows us to compare specific
implementations of the algorithms .  It also requires us to implement the algorithm in an actual
programming language before we even know how good the algori thm is (that is, before we know if
we should even spend the time to implement it).
But we can analyze and compare algorithms before they are imp lemented if we use the number
of instructions as our measure of performance. There is still a problem with t his measure. What is
meant by an “instruction”? When you write a program in a langu age such as Java or C++, it is not
executed exactly as you wrote it. It is compiled into some sor t of machine language. The process
of compiling does not generally involve a one-to-one mappin g of instructions, so counting Java
instructions versus C++ instructions wouldn’t necessaril y be fair. On the other hand, we certainly
do not want to look at the machine code in order to count instru ctions—machine code is ugly.
Further, when analyzing an algorithm, should we even take in to account the exact implementation
in a particular language, or should we analyze the algorithm apart from implementation?
O.K., that’s enough of the complications.  Let’s get to the bo ttom line.  When analyzing
algorithms, we generally want to ignore what sort of machine it will run on and what language
it will be implemented in. We also generally do not want to kno w exactly how many instructions
it will take. Instead, we want to know the rate of growth of the number of instructions. This is
sometimes called the asymptotic running time of an algorithm. In other words, as the size of the
input increases, how does that affect the number of instructio ns executed? We will typically use
7.1 to specify the running time of an algorithm. We will call this the the notation from Section
time complexity (or often just complexity ) of the algorithm.
7.3.1  Analyzing Algorithms
Given an algorithm, the size of the input is exactly what it sounds like—the amount of space
required to specify the input.  For instance, if an algorithm operates on an array of size n , we

Algorithm Analysis 261
generally say the input is of size n . For a graph, it is usually the number of vertices or the numbe r
of vertices and edges. When the input is a single number, thin gs get more complicated for reasons
I do not want to get into right now. We usually don’t need to wor ry about this, though.
Algorithm analysis involves determining the size of the inp ut, n , and then finding a function
based on n that tells us how long the algorithm will take if the input is o f size n . By “how long”
we of course mean how many operations.
Example 7.102 (Sequential Search) . Given an array of n elements, often one needs to deter-
mine if a given number val is in the array. One way to do this is with the sequential search
algorithm that simply looks through all of the elements in th e array until it finds it or reaches
the end. The most common version of this algorithm returns th e index of the element, or − 1
if the element is not in the array. Here is one implementation .
int sequentialSearch( int a[], int n, int val) {
for ( int i=0;i= y) {
return x;
} else {
return y;
}
}
Solution: No matter what, the algorithm does a single comparison follo wed
by a return statement. Therefore, in the best, average, and w orst case, max takes
about 2 operations. Therefore, the complexity is always Θ(1 ) (otherwise known as
constant ).
⋆ Exercise 7.109. Analyze the following algorithm that finds the maximum value in an array.
Start by deciding which operation(s) should be counted. Don ’t forget to give the best, worst,
and average-case complexities.
int maximum( int a[], int n) {
int max = int .MIN_VAL;
for ( int i=0; i0;i--) {
for ( int j=0;j a[j+1]) {
swap(a,j,j+1);
}
}
}
}
If you have seen bubblesort previously, hopefully you know by now that you should never
use it. It is one of the worst sorting algorithms. Because of t his, we won’t even describe the
algorithm here and just focus on analyzing it.
Find the complexity of bubblesort , where n is the size of the array a .
Solution: First, notice that the input size is n since we are sorting an array with
n elements.

Algorithm Analysis 273
Example 5.57 gives an implementation of swap that takes constant time (verify
this!). The conditional statement, including the swap, tak es constant time (we’ll
call it c , as usual), regardless of whether or not the condition is tru e. It takes longer
if the condition is true, but it is constant either way—about 3 operations (array
indexing ( × 2) and comparison) versus about 6 (the swap adds about 3).
The inner loop goes from j = 0 to j = i − 1, so it executes i times and takes ci
time. But what is i ? This is where things get a little more complicated than in th e
previous examples. Notice that the outer loop is changing th e value of i . We need
to look at this a little more carefully.
1. The first time through the outer loop i = n − 1. So the inner loop takes c ( n − 1)
time.
2. The second time through the outer loop i = n − 2. So the inner loop takes
c ( n − 2) time.
3. The k th time through the outer loop i = n − k . So the inner loop takes c ( n − k )
time.
4. This goes all the way to the n th time through the outer loop when i = 1 and
the inner loop takes c · 1 time.
The outer loop is simply causing the inner loop to be executed over and over again,
but with different parameters (specifically, it is changing th e limit on the inner
loop). Thus, we need to add up the time taken for all of these ca lls to the inner
loop. Doing so, we see that the total time required for bubblesort is
c ( n − 1) + c ( n − 2) + c ( n − 3) + ··· + c 1  = c (( n − 1) + ( n − 2) + ( n − 3) + ··· + 1)
= c (1 + 2 + 3 + ··· + ( n − 1))
n − 1 ∑
= c k
k =1
( n − 1) n
= c
2
2 =  Θ( n )
2 Thus, the complexity (worst, best, and average) of bubblesort is Θ( n ).
Note: Part way through our analysis of bubblesort we had k as part of our complexity. But
notice that the k did not show up as part of the final complexity. This is because i n the context
of the entire algorithm, k has no meaning. It is a local variable from the algorithm that w e
needed to use to determine the overall complexity of the algo rithm. The only variables that
should appear in the complexity of an algorithm are those that are related to the
size of the input.

274 Chapter 7
⋆ Question 7.133. In the best case, the code in the conditional statement in bubblesort
2 never executes. Why does this still result in a complexity of Θ( n )?
Answer
In reality, the best and worst case performance of bubblesort are different—the worst case
is about twice as many operations. But when we are discussing the complexity of algorithms, we
care about the asymptotic behavior—that is, what happens as n gets larger.  In that case, the
difference is still just a factor of 2. The best and worst-case c omplexities have the same growth
rate (quadratic).
Consider how this is different if the best-case complexity of a n algorithm is Θ( n ) and the worst-
2 case complexity is Θ( n ). As n gets larger, the gap between the performance in the best and w orst
cases also gets larger. In this case, the best and worst-case complexities are not the same since one
is linear and the other is quadratic.
Note: If an algorithm contains nested loops and the limit on one or mo re of the inner loops
depends on a variable from an outer loop, analyzing the algor ithm will generally involve one
or more summations, as it did with the previous example. As me ntioned previously, variables
related to those loops that are used in your analysis (e.g. i , j , k , etc.) should never show up
in your final answer! They have no meaning in that context.
Example 7.134. One of the best simple sorting algorithms is insertionSort . It works much
like one might sort a hand of playing cards. The first card is in order since there is one one.
Compare the second card to the first card and swap if they are ou t of order. Now the first two
are in order. Now pick up the third card and go down the list and place it where it belongs.
Just keep repeating this process until the whole list is sort er. Here is an implementation of
that idea:
void insertionSort( int a[], int n) {
for ( int i=1;i= 0 && a[j] > v) {
a[j+1] = a[j];
j--;
}
a[j+1]=v;
}
}
Find the complexity of insertionSort , where n is the size of the array a .
Solution: The code inside the while loop takes constant time. The loop c an end
for one of two reasons—if j gets to 0, or if a[j]>v . In the worst case, it goes until
j = 0. Since j starts out being i at the beginning, and it is decremented in the

Algorithm Analysis 275
loop, that means the loop executes i times in the worst case.
The for loop (the outer loop) changes the value of i from 1 to n − 1, executing a
constant amount of code plus the while loop each time. So the i th time through the
outer loop takes c + c i operations. We will simplify this to just i operations—you 1 2
can think of it as counting the number of assignments in the wh ile loop if you wish.
So the worst-case complexity is
n − 1 ∑
( n − 1) n 2
i = = Θ( n ).
2
i =1
This happens, by the way, if the elements in the array start ou t in reverse order.
In the best case, the loop only executes once each time becaus e a[j]>v is always
true (which happens if the array is already sorted). In this c ase, the complexity is
Θ( n ) since the outer loop executes n − 1 times, each time doing a constant amount
of work.
We should point out that if we had done our computations using c + c i instead of i we 1 2
would have arrived at the same answer, but it would have been m ore work:
n − 1 n − 1 n − 1 n − 1 ∑ ∑ ∑ ∑
( n − 1) n 2
i = c · ( n − 1) + c c i = c · ( n − 1) + c c + c + c i = = Θ( n ). 1 2 2 1 2 1 1 2
2
i =1 i =1 i =1 i =1
The advantage of including the constants is that we can stop s hort of the final step and get a
better estimate of the actual number of operations used by th e algorithm. In other words, if
we want an exact answer, we need to include the constants and l ower order terms. If we just
want a bound, the constants and lower order terms can often be ignored.
Note: There are rare cases when ignoring constants and lower order t erms can cause trouble
(meaning that it can lead to an incorrect answer) for subtle r easons that are beyond the scope
of this book. Unless you take more advanced courses dealing w ith these topics, you most likely
won’t run into those problems.
Let’s complicate things a bit by bringing in some basic data s tructures.
Example 7.135. Consider the following implementation of insertion sort th at works on lists
of integers (written using Java syntax).
void insertionSort(List  A, int n) {
for ( int i = 1; i < n; i++) {
Integer T = A.get(i);
int j = i-1;
while (j  >= 0 && A.get(j).compareTo(T) > 0) {
A.set(j + 1, A.get(j));
j--;
}
A.set(j+1, T);
}
}

276 Chapter 7
Note: In some languages the size of the list, n , does not need to be passed in since it can be
obtained with a method call (e.g. A.size() ). We will pass it in just to be clear that the size of
the list is n .
In this implementation A.get(i) retrieves that i th element from the list and A.set(i,x)
sets the i th element of the list to x . Also, A.get(j).compareTo(T) returns a positive number
if A.get(j) is greater than T , 0 of they are the same, and a negative number otherwise. It is
essentially equivalent to A.get(j) > T .
Give the complexity of this version of insertionSort assuming that the list is an array-
based implementation (e.g. an ArrayList in Java). In case yo u are not aware from a previous
course, this means that both get and set take constant time. In addition, we will assume that
compareTo always takes constant time (which should be true for any reas onable implementa-
tion).
Solution: Notice that this algorithm is almost identical to the earlie r version that
is implemented on an array. Array indexing and assignment ar e simply replaced
with calls to get and set . Since the time of these calls remains constant, the earlier
2 analysis still holds. Thus, the algorithm has a complexity o f Θ( n ).
The following should be review from a previous course. If you have not had a data structures
course, read the solution and just take it as a given.
⋆ Question 7.136. What are the complexities of the methods set(i,x) (set the i th element
of the the list to x ) and get(i) (return the i th element of the list) for a linked list , assuming
a reasonable implementation?
Answer
Example 7.137. Analyze the previous insertionSort algorithm assuming that the list is
now a linked list .
Solution: The analysis here is a bit more complicated than we have previ ously
seen, but we can still do it. We start by analyzing the code ins ide the while loop.
In the worst case, each iteration of the loop makes two calls t o A.get(j) and one
call to A.set(j+1) and a constant amount of other work. The total time for each
′ ′ iteration is therefore about 2 j + ( j + 1) + c = 3 j + c + 1 = 3 j + c , where c = c + 1
is still just some constant. The index of the while loop start s at j = i and can go
until j = 1 (with j decrementing each iteration). Thus, the complexity of the w hile
loop is about
i i i ∑ ∑ ∑
( i + 1) i ′ ′ 2 ′
c = 3 j + + ic = Θ( i ) (3 j + c ) = 3
2
j =1 j =1 j =1
The rest of the code inside the for loop takes constant time, e xcept the one call to
a Thus, the code inside the for loop get and one call to set which take time Θ( i ).
2 2 has complexity Θ( i + i ) = Θ( i ). The outer for loop makes i go from 1 to n − 1.

Algorithm Analysis 277
Thus, the overall complexity is
) ( Å ã
n − 1 n − 1 ∑ ∑
( n − 1) n (2( n − 1) + 1) 2 2 3
= Θ i Θ( i ) = Θ = Θ( n ).
6
i =1 i =1
Clearly using a linked list in this implementation of insert ion sort is a bad idea.
a Note that there is a tricky part here. It is subtle, but import ant. The call to set actually takes j as a
parameter. However we cannot use Θ( j ) as the complexity of this because the j has no meaning in this context.
Therefore we use the fact that 1 ≤ j ≤ i to instead call it Θ( i ).
You will get a chance to analyze the third popular basic sorti ng algorithm, Selection Sort , in
the exercises.
7.3.4  Basic Data Structures
If you have had a previous data structures course, this secti on should be review. If you have not,
you should probably skip this section since you will be unabl e to complete the exercises without
understanding the data structures involved.
⋆ Exercise 7.138. For each of the following implementations of a stack , give a tight bound
(using Θ-notation, of course) on the expected running time o f the given operations, assuming
that the data structure has n items in it before the operation is performed.
Stack array linked list
push
pop
peek
size
⋆ Exercise 7.139. For each of the following implementations of a queue , give a tight bound
on the expected running time of the given operations, assumi ng that the data structure has n
items in it before the operation is performed.
Queue array linked list circular array
enqueue
dequeue
first
size

278 Chapter 7
⋆ Exercise 7.140. For each of the following implementations of a list , give a tight bound on
the expected running time of the given operations, assuming that the data structure has n
items in it before the operation is performed.
List array linked list
addToFront
addToEnd
removeFirst
contains
size
isEmpty
⋆ Exercise 7.141. For each of the following implementations of a binary search tree (BST) ,
give a tight bound on the expected running time of the given op erations, assuming that the data
structure has n items in it before the operation is performed. Assume a linke d implementations
(rather than arrays). For balanced, assume an implementati on like red-black tree or AVL tree.
BST unbalanced balanced
insert/add
delete/remove
search/contains
maximum
successor
⋆ Exercise 7.142. Give the average- and worst-case complexity of the followin g operations
on a hash table (implemented with open-addressing or chaining–it doesn’t matter), assuming
that the data structure has n items in it before the operation is performed.
Hash Table average worst
insert/add
delete/remove
search/contains

Algorithm Analysis 279
7.3.5  More Examples
Before presenting several more examples of algorithm analy sis, let’s summarize a few principles
from the examples we have seen so far.
1. We can usually replace constants with 1. For instance, if s omething performs 30 operations,
we can say it is constant and call it 1. This is only valid if it r eally is always 30, of course.
2. We can usually ignore lower-order terms. So if an algorith m takes c n + c operations, we 1 2
can usually say that it takes n .
3. Nested loops must be treated with caution. If the limits in an inner loop change based on
the outer loop, we generally need to write this as a summation .
4. We should generally work from the inside-out. Until you kn ow how much time it takes to
execute the code inside a loop, you cannot determine how much time the loop takes.
5. Function calls must be examined carefully. Do not assume t hat a function takes constant
time unless you know that to be true. We already saw a few examp les where function calls
did not take constant time, and the next example will demonstrate it again.
6. Only the size of the input should appear as a variable in the complexity of an algorithm. If
you have variables like i , j , or k in your complexity (because they were indexes of a loop, for
instance), you should probably rethink your analysis of the algorithm. Loop variables should
never appear in the complexity of an algorithm.
Now it’s time to see if you can spot where someone didn’t follo w some of these principles.

280 Chapter 7
0 1 2 n − 1 ⋆ Evaluate 7.143. Consider the following code that computes a + a + a + ··· + a .
double addPowers( double a, int n) {
if (a==1) {
return n;
} else {
double sum = 0;
for ( int i=0;i c) {
boolean modified = false;
int w = 0;
for ( int r = 0; r < size; r++) {
if (c.contains(elementData[r])) {
elementData[w++] = elementData[r];
}
}
if (w !=  size) {
for ( int i = w; i < size; i++)
elementData[i] = null;
size = w;
modified = true;
}
return modified;
}
Let al1 be an ArrayList of size n .
(a) What is the complexity of al1.retainAll(al2) , where al2 is an ArrayList with m ele-
ments?
Solution: The method call c.contains(elementData[r]) takes Θ( m ) time
since c is an ArrayList.  The rest of the code in that for loop takes con stant
time. Since this is done inside a for loop that executes n times, the first half
of the code takes Θ( nm ) time. In the worst case ( w = 0), the second half of
the code takes Θ( n ) time.  Thus, the worst-case complexity of the method is
Θ( nm + n ) = Θ( nm ).
(b) What is the complexity of al1.retainAll(ts2) , where ts2 is a TreeSet with m elements?
Solution: The method call c.contains(elementData[r]) takes Θ(log m )
time since c is a TreeSet. The rest of the code in that for loop takes consta nt
time. Since this is done inside a for loop that executes n times, the first half

286 Chapter 7
of the code takes Θ( n log m ) time. In the worst case ( w = 0), the second half
of the code takes Θ( n ) time. Thus, the worst-case complexity of the method is
Θ( n log m + n ) = Θ( n log m ).
⋆ Exercise 7.152. Answer the following two questions based on the code from Exa mple 7.151 .
(a) What is the complexity of al1.retainAll(ll2) , where ll2 is a LinkedList with m ele-
ments? Answer
(b) What is the complexity of al1.retainAll(hs2) , where hs2 is a HashSet with m elements?
Answer
Example 7.153. In Java, the retainAll method is implemented as follows for LinkedList ,
TreeSet , and HashSet .
public  boolean retainAll(Collection  c) {
boolean modified = false;
Iterator  iter = iterator();
while (iter.hasNext()) {
if (!c.contains(iter.next())) {
iter.remove ();
modified = true;
}
}
return modified;
}
Assume that the calls iter.hasNext() and iter.next() take constant time. Let ts1 be a
TreeSet of size n . Find the worst-case complexity of each of the following met hod calls.
(a) ts1.retainAll(al2) , where al2 is an ArrayList of size m .
Solution: The call to iter.remove() takes Θ(log n ) time since the iterator
is over a TreeSet. The call to contains takes Θ( m ) time since in this case c is
the ArrayList al2 . The other operations in the loop take constant time. Thus,
each iteration of the while loop takes Θ(log n + m ) time in the worst case (which
occurs if the conditional statement is always true and remove is called every
time). Since the loop executes n times, and the rest of the code takes constant
time, the overall complexity is Θ( n (log n + m )).
(b) ts1.retainAll(hs2) , where hs2 is an HashSet of size m .
Solution: The call to iter.remove() takes Θ(log n ) time.  The call to
contains takes Θ(1) time since c is the HashSet hs2 .  Thus, each iteration

Algorithm Analysis 287
of the while loop takes Θ(log n + 1) time and the overall complexity is therefore
Θ( n (log n + 1)) = Θ( n log n ).
⋆ Exercise 7.154. Using the setup and code from Example 7.153 , determine the complexity
of the following method calls.
(a) ts1.retainAll(ll2) , where ll2 is a LinkedList of size m . Answer
(b) ts1.retainAll(ts2) , where ts2 is an TreeSet of size m . Answer
It is important to note that the number of examples related to the retainAll method is not
reflective of the importance of this method. It just turns out to be an interesting method to analyze
the complexity of given different data structures.
We end this section with a comment that perhaps too few people think about. Theory and
practice don’t always agree. Since asymptotic notation ignores the constants , two algorithms that
2 have the same complexity are not always equally good in pract ice. For instance, if one takes 4 · n
2 operations and the other 10, 000 · n operations, clearly the first will be preferred even though t hey
2 are both Θ( n ) algorithms.
As another example, consider matrix multiplication, which is used extensively in many scientific
3 applications. As we saw, the standard algorithm has complex ity Θ( n ). Strassen’s algorithm for
matrix multiplication (the details of which are beyond the s cope of this book) has complexity
2.8 of about Θ( n ). Clearly, Strassen’s algorithm is better asymptotically . In other words, if your
matrices are large enough, Strassen’s algorithm is certain ly the better choice. However, it turns
out that if n = 50, the standard algorithm performs better. There is debat e about the “crossover
point.” This is the point at which the more efficient algorithm is worth using. For smaller inputs,
the overhead associated with the cleverness of the algorith m isn’t worth the extra time it takes. For
larger inputs, the extra overhead is far outweighed by the be nefits of the algorithm. For Strassen’s
algorithm, this point may be somewhere between 75 and 100, bu t don’t quote me on that. The
point is that for small enough matrices, the standard algori thm should be used. For matrices that
are large enough, Strassen’s algorithm should be used. Neit her one is always better to use.
Analyzing recursive algorithms can be a little more complex . We will consider such algorithms
8 , where we develop the necessary tools. in Chapter
7.3.6  Binary Search
Next we analyze the binary search algorithm. If you haven’t seen it before, the concept is simp le:
If you want to find something in a sorted list, start by compari ng with the middle element. If the
array is empty, the element is not in it. If they are the middle and the element you are searching

288 Chapter 7
for are the same, you have found what you are looking for. If wh at you are looking for is smaller
than the middle element, then it is in the first half of the arra y. If what you are looking for is
bigger than the middle element, then it is in the second half o f the array. Now we simply repeat
the process on the appropriate half of the array until we have our answer.
Example 7.155. Here is an implementation of binary search .
int binarySearch( int a[], int n, int val) {
int left=0, right=n-1;
while (right -left >=0) {
int middle = (left+right)/2;
if (val==a[middle ])
return middle;
else if (val =0) {
int middle = (left+right)/2;
if (val==a[middle ])
return middle;
else if (val  0. That is, explain
why cn = o ( n log n ). Note that I am not asking for a proof of this, but an explanat ion of why it
makes sense.
⋆ Question 7.10. We think of log n as a slow growing function. Does that mean that given another
function f ( n ), f ( n ) log n grows slower than f ( n )? (In general, if we multiply a function by a slow
growing function, does it make the function grow slower?) Ex plain.
⋆ Question 7.11. Rank the following functions in increasing order of rate of growth.  Clearly
indicate if two of the functions have the same growth rate:
n 2 n 2 n 3 3 2 n , 7 log n , n + n + 1, 7 , 3 n , 2 , n !, log n , 7 n log n , n , 27 n , 8675309, n + n log n
10 3 2 e
7.3 From Section
⋆ Question 7.12. Explain why “My algorithm only took 5 minutes to run and yours took 15
minutes, so mine is better” is not a complete and valid argume nt.  (What other information is
needed to make the conclusion?)
⋆ Question 7.13. If one algorithm always takes 3 times as long to run as another algorithm,
regardless of the size of the input, do the two algorithms hav e different computational complexities?
Explain.

Reading Comprehension Questions 293
⋆ Question 7.14. If algorithm A has computational complexity f ( n ), algorithm B has computa-
tional complexity g ( n ), and f ( n ) = o ( g ( n )) (that is, g ( n ) grows faster than f ( n )), which algorithm
is faster, A or B ? Explain.
⋆ Question 7.15. Someone claims to have an algorithm that can sort an array of n elements in
Θ(log n ) time. Why can you be certain that they are incorrect about th eir algorithm?
⋆ Question 7.16. Someone has an algorithm that can search an array in time Θ( n log n ). Is that
a good or bad algorithm to solve the search problem (or is it im possible to tell)? Explain.
1.5 ⋆ Question 7.17. Is an algorithm that can sort an array in time Θ( n ) better or worse than
insertionSort ? Explain.
⋆ Question 7.18. Give at least two reasons why a double-nested for loop does no t always have
2 complexity Θ( n ).
2 ⋆ Question 7.19. Algorithm A has complexity Θ( n ) and algorithm B has complexity Θ( n log n ).
(a) Generally speaking, which algorithm is faster? When is i t faster? Explain.
(b) Are there potentially cases in which the “worse” algorit hm is actually faster? If so, when might
it be faster and why? If not, how do you know that it is never fas ter?
2 ⋆ Question 7.20. Algorithm A has complexity Θ( n log n ) and algorithm B has complexity O ( n ).
Which algorithm is faster? Explain.
⋆ Question 7.21. If two algorithms have the same complexity, what other facto rs should be taken
into account when choosing which one to use? List as many as yo u can think of.

294 Chapter 7
7.5  Problems
Problem 7.1. Prove Theorem 7.18 .
Problem 7.2. Θ can be thought of as a relation on the set of positive functio ns, where ( f , g ) ∈ Θ
iff f ( n ) = Θ( g ( n )). Prove that Θ is an equivalence relation.
Problem 7.3. Rank the following functions in increasing rate of growth. I ndicate if two or more
functions have the same growth rate.
Å ã x
√ 3 x 2 x 3 / 2 log 7 2 3 2 log 3
3 2 x , 3 , x log x , x , x , x , x , x log( x ), x log(log( x )), x !, x , x log x , x , x ,
2
3 2 3 Problem 7.4. Prove that 3 n − 4 n + 13 n = O ( n )
(a) Using the definition of O .
(b) Using limits.
2 2 Problem 7.5. Prove that 5 n − 7 n = Θ( n )
7.18 . (a) Using the definition of Θ and/or Theorem
(b) Using limits.
2 Problem 7.6. Prove that n log n = o ( n ).
2 Problem 7.7. Prove that log( x + x ) = Θ(log x ).
√
2 5 x + 11 x = Θ( x ). Problem 7.8. Prove that
2 n Problem 7.9. Prove that n = o (1. 01 ).
Problem 7.10. Consider the problem of computing the product of two matrice s, A and B , where
A is l × m and B is m × n .
(a) Give an efficient algorithm to compute the product A × B . Assume you have a Matrix type
with fields rows and columns that specify the number of rows/columns the matrix has. Thus ,
you can call A.rows to get the number of rows A has, for instance. Also assume you can index
a Matrix like an array. Thus, A[i][j] accesses the element in row i and column j .
(b) Give the best and worst-case complexity of your algorith m.
Problem 7.11. Give tight bounds for the best and worst case running times of each of the
following algorithms in terms of the size of the input. Assum e A . length = n . (Note: some of these
are useless algorithms that do not do anything useful. Do not worry about what they do, just how
long it takes to do whatever it is they do.)
void foo1( int n) { (a)
int foo = 0;
for ( int i = 0 ; i < n ; i++)
foo += i;
}

Problems 295
(b) void blah( int n) {
int blah = 0;
for ( int i = 0 ; i < sqrt(n) ; i++)
blah += i;
}
(c) void ferzle1( int a[], int n) {
int ferzle = 0;
for ( int i = 0 ; i < n ; i++) {
for ( int j = 0 ; j < n ; j++) {
ferzle  += a[i]*a[j];
if (ferzle ==10000) {
j=n;
}
}
}
}
(d) void ferzle2( int n) {
int ferzle = 0;
for ( int i = 0 ; i < n ; i++) {
for ( int j = i ; j < n ; j++) {
ferzle  += i*j;
}
}
}
void ferzle3( int a[], int n) { (e)
int ferzle = 0;
for ( int i = 0 ; i < n ; i++) {
for ( int j = 0 ; j < n ; j++) {
ferzle  += a[i]*a[j];
if (ferzle ==10000) {
i=n;
}
}
}
}
void ferzle4( int a[], int n) { (f)
int ferzle = 0;
for ( int i = 0 ; i < n ; i++) {
for ( int j = 0 ; j < n ; j++) {
ferzle  += a[i]*a[j];
}
if (ferzle ==10000) {
i=n;
}
}
}

296 Chapter 7
(g) void gruhop1( int n) {
int gruhop = 0;
for ( int i = 0 ; i < n/2 ; i++) {
for ( int j = 0 ; j < n/2 ; j++) {
gruhop  += i*j;
}
}
}
(h) int sumSomeStuff( int []A) {
int sum=0;
int i=0;
while (i < A.length) {
sum = sum + A[i];
i++;
if (sum > 100000) {
i=A.length;
}
}
return sum;
}
(i) void gruhop2( int n) {
int gruhop = 0;
for ( int i = 0 ; i < sqrt(n) ; i++) {
for ( int j = 0 ; j < n ; j++) {
gruhop  += i*j;
}
}
}
(j) int doMoreStuff( int []A) {
int sum=0;
for ( int i=0 ; i < A.length ; i++) {
for ( int j=0 ; j < A.length ; j++) {
sum = sum + A[i]*A[j];
if (sum==123) {
j = A.length;
}
}
for ( int j=0 ; j < A.length ; j++) {
sum = sum - A[j]*A[j];
}
}
return sum;
}

Problems 297
(k) int sumTimesM( int []A) {
int M = 100;
int sum=0;
for ( int i=0 ; i < A.length ; i++) {
for ( int j=0 ; j < M ; j++) {
sum = sum + A[j] + A[i];
if (sum==123) {
j = M;
}
}
}
return sum;
}
(l) void foo2( int n, int m) {
int foo = 0;
for ( int i = 0 ; i < n ; i++)
foo++;
for ( int j = 0 ; j < m ; j++)
foo++;
}
(m) void foo3( int n) { // Tricky  one
int foo = 0;
for ( int i = 1 ; sqrt(i)   <=   n ; i++)
for ( int j = 1 ; j  <= i; j++)
// takes j steps; doIt(j)
}
void HalfIt( int n) { (n)
while (n > 0) {
n = n/2;
}
}
7.153 , determine the complexity of the following Problem 7.12. Using the code from Example
method calls.
(a) hs1.retainAll(al2) , where hs1 is a HashSet of size n and al2 is an ArrayList of size m .
(b) hs1.retainAll(ll2) , where hs1 is a HashSet of size n and ll2 is a LinkedList of size m .
(c) hs1.retainAll(ts2) , where hs1 is a HashSet of size n and ts2 is a TreeSet of size m .
(d) hs1.retainAll(hs2) , where hs1 is a HashSet of size n and hs2 is a HashSet of size m .
(e) ll1.retainAll(al2) , where ll1 is a LinkedList of size n and al2 is an ArrayList of size m .
(f) ll1.retainAll(ll2) , where ll1 is a LinkedList of size n and ll2 is a LinkedList of size m .
(g) ll1.retainAll(ts2) , where ll1 is a LinkedListof size n and ts2 is a TreeSet of size m .
(h) ll1.retainAll(hs2) , where ll1 is a LinkedList of size n and hs2 is a HashSet of size m .

298 Chapter 7
Problem 7.13. Consider the following two implementations of selection so rt.
void selectionSort( int a[], int n) {
for ( int i=0 ; i a, int n) {
for ( int i=0 ; i=0) {
int middle = (left+right)/2;
if (val==A.get(middle))
return middle;
else if (val  6 as well, so
P ( k ) is true for all k ≥ 1.
⋆ Question 8.4. Example 8.3 had several statements like the following:
“Since P (4) is true and 4 ≥ 1, P (4) → P (5) is true, therefore P (5) is true.”
What is the justification for the conclusion that P (5) is true?
Answer
Example 8.3 did not give a formal proof of the conclusion. The idea is to get you thinking about
how mathematical induction works, not to provide a formal pr oof that it does (yet). Hopefully
this example will help prime your brain for the proof that mat hematical induction is a valid proof
technique that we will give shortly.
Before moving on, we should make sure you understand what has already been said.
⋆ Question 8.5. If you know that P (5) is true, and you also know that P ( k ) → P ( k + 1)
whenever k ≥ 1, what can you conclude?
Answer
⋆ Question 8.6. If you know that P (17) is true and you also know that P ( k ) → P ( k + 1)
whenever k ≥ 1, what can you conclude about P (10)?
Answer
Now it is time to get more formal with our discussion. Mathema tical induction is based on the
fact that if P ( a ) is true for some a ≥ 0 (the base case ), and for any k ≥ a , if P ( k ) is true, then
P ( k + 1) is true (the inductive case ), then P ( n ) is true for all n ≥ a . In other words, the principle
of mathematical induction is based on the fact that
[ P ( a ) ∧∀ k ( P ( k ) → P ( k + 1))] → ( ∀ nP ( n )),
where the universe is { a , a + 1, a + 2, . . . } , is true.

304 Chapter 8
⋆ Exercise 8.7. Restate [ P ( a ) ∧∀ k ( P ( k ) → P ( k + 1))] → ( ∀ nP ( n )) (where the universe is
{ a , a + 1, a + 2, . . . } ) in English.
Answer
The proof that [ P ( a ) ∧∀ k ( P ( k ) → P ( k + 1))] → ( ∀ nP ( n )) is true is based on something called
the well-ordering principle which states that every nonempty subset of the natural numbe rs has a
least element. Read the following proof very carefully, mak ing sure you understand the justification
of every step. If you are not sure about any of the steps, it is i mportant that you get them clarified!
Theorem 8.8. Assume we are working over the universe { a , a + 1, a + 2, . . . } . The statement
[ P ( a ) ∧∀ k ( P ( k ) → P ( k + 1))] → ( ∀ nP ( n )) is true.
Proof: If the statement is false, then it must be that P ( a ) ∧∀ k ( P ( k ) → P ( k +1))
is true but that ∀ nP ( n ) is false. Let S = { s ∈{ a , a +1, a +2, . . . }|¬ P ( s ) } . That is, S
is the set of integers for which P ( n ) is false. Since ∀ nP ( n ) is false, S is nonempty.
Clearly S is a subset of the natural numbers, so the well-ordering prin ciple applies.
Therefore there is some least element b ∈ S . Since b ∈ S , P ( b ) is false, and since
it is the least such element, b − 1 6∈ S , so P ( b − 1) is true.  But we know that
∀ k ( P ( k ) → P ( k + 1)) is true, so P ( b − 1) → P ( b ) . By modus ponens, P ( b ) is true,
a contradiction. Therefore the statement is true. 
It is definitely worth your time to convince yourself that mat hematical induction is a valid
technique. If you aren’t convinced, reread the proof, think about it some more, and/or ask someone
to help you understand it.
⋆ Question 8.9. Are you convinced that [ P ( a ) ∧∀ k ( P ( k ) → P ( k + 1))] → ( ∀ nP ( n )) is true?
Answer
We call P ( a ) the base case . Sometimes we actually need to prove several base cases (we w ill see
why later). For instance, we might need to prove P ( a ), P ( a + 1), and P ( a + 2) are all true.
The inductive step involves proving that ∀ k ( P ( k ) → P ( k + 1)) is true. To prove it, we show
that if P ( k ) is true for any k which is at least as large as the base case(s) , then P ( k + 1) is true.
The assumption that P ( k ) is true is called the inductive hypothesis .
Based on our discussion so far, here is the procedure for writ ing induction proofs.

Mathematical Induction 305
Procedure 8.10. To use induction to prove that ∀ nP ( n ) is true on domain { a , a + 1, . . . } :
1. Base Case: Show that P ( a ) is true (and possible one or more additional base cases).
2. Show that ∀ k ( P ( k ) → P ( k + 1)) is true. To show this:
(a) Inductive Hypothesis: Let k ≥ a be an integer and assume that P ( k ) is true.
(b) Inductive Step: Prove that P ( k + 1) is true, typically using the fact that P ( k ) is
true.
Assuming we used no special facts about k other than k ≥ a , this means we have shown
that ∀ k ( P ( k ) → P ( k +1)) (again, where it is understood that the domain is { a , a +1, . . . } ) .
3. Summary: Conclude that ∀ nP ( n ) is true, usually by saying something like “Since P ( a )
and P ( k ) → P ( k + 1) for all k ≥ a , ∀ nP ( n ) is true by induction.”
As you will quickly learn, the base case is generally pretty easy, as is writing down the inductive
hypothesis . The summary is even easier, since it almost always says the same thing. Th e inductive
step is the longest and most complicated step. In fact, in mathema tics and theoretical computer
science journals, induction proofs often only include the i nductive step since anyone reading papers
in such journals can generally fill in the details of the other three parts. But keep in mind that you
are not (yet) writing papers for such journals, so you cannot omit these steps!
Let’s see another example.
2 Example 8.11. Prove that the sum of the first n odd integers is n .  That is, show that
n ∑
2 (2 i − 1) = n for all n ≥ 1.
i =1
n ∑
2 (2 i − 1) = n ”. We need to show that Proof: Let P ( n ) be the statement “
i =1
P ( n ) is true for all n ≥ 1.
1 ∑
2 (2 i − 1) = 2 · 1 − 1 = 1 = 1 , P (1) is true. Base Case: Since
i =1
Inductive Hypothesis: Let k ≥ 1 and assume that P ( k ) is true. That is, assume
k ∑
2 when k ≥ 1. (2 i − 1) = k that
i =1
Inductive Step: Then
k k +1 ∑ ∑
(2 i − 1) + (2( k + 1) − 1)  (take k + 1 term from sum) (2 i − 1)  =
i =1 i =1
2 = k + (2 k + 2 − 1)  (by the inductive hypothesis )
2 = k + 2 k + 1
2 =  ( k + 1)
Thus P ( k + 1) is true.

306 Chapter 8
Summary: Since we proved that P (1) is true, and that P ( k ) → P ( k +1) whenever
k ≥ 1, P ( n ) is true for all n ≥ 1 by the principle of mathematical induction. 
The previous proof had the four components we discussed. We p roved the base case . We then
assumed it was true for k . That is, we made the inductive hypothesis . Next we proved that it was
true for k + 1 based on the assumption that it is true for k . That is, we did the inductive step .
Finally, we appealed to the principle of mathematical induc tion in the summary .
Note: Recall the following statement from Example 8.11 :
n ∑
2 (2 i − 1) = n ”. Let P ( n ) be the statement “
i =1
Did you notice the quotes? It is important that you include the se. This is particularly important
n ∑
2 (2 i − 1) = n ”.  Without the quotes, this becomes if you use notation such as P ( n ) = “
i =1
n n ∑ ∑
2 (2 i − 1) and saying that it is also (2 i − 1) = n , which is defining P ( n ) to be P ( n ) =
i =1 i =1
2 equal to n . These are not saying the same thing. With the quotes, P ( n ) is a propositional
function. Without them, it is a function from Z to Z .
In fact, to avoid this confusion, I recommend that you never us e the equals sign with propo-
sitional functions, especially when writing induction pro ofs.
Now it’s your turn to try to fill in the details of an induction p roof.

Mathematical Induction 307
⋆ Fill in the details 8.12. Reprove Theorem 6.50 using induction. That is, prove that for
n ∑
n ( n + 1)
i = . n ≥ 1,
2
i =1
k ∑
k ( k + 1)
i = Proof: Let P ( k ) be the statement “ ”. We need to show that
2
i =1
P ( n ) is true for all n ≥ 1.
1 ∑
i = 1 = Base Case: When k = 1, we have .  Therefore,
i =1
.
. Inductive Hypothesis: Let k ≥ 1, and assume that
. That is, assume that
[This is not part of the proof, but it will help us see what’s ne xt. Our
goal in the next step is to prove that is true. That is, we
.] need to show that
Inductive Step: Notice that
k +1 ∑
+ ( k + 1) i =
i =1
= + ( k + 1)(by the inductive hypothesis)
Ö è
=  ( k + 1)
=
Thus, .
and that whenever , Summary: We showed that
P ( k ) → P ( k + 1), therefore P ( n ) is true for by


308 Chapter 8
8.1.2  Equalities/Inequalities
The last few example induction proofs have dealt with statem ents of the form
LHS ( k ) = RHS ( k ),
where LHS stands for left hand side and RHS stands for right hand side . For instance, in Exam-
8.11 , the statement was ple
n ∑
2 (2 i − 1) = n ,
i =1
k ∑
2 (2 i − 1) and RHS ( k ) = k . so LHS ( k ) =
i =1
n ∑
i · i ! = ( n + 1)! − 1.” Determine each of ⋆ Question 8.13. Let P ( n ) be the statement “
i =1
the following:
(a) P ( k ) is the statement .
(b) P ( k + 1) is the statement .
(c) LHS ( k ) =
(d) RHS ( k ) =
(e) LHS ( k + 1) =
(f) RHS ( k + 1) =
For statements of this form, the goal of the inductive step is to show that LHS ( k + 1) =
RHS ( k +1) given the fact that LHS ( k )= RHS ( k ) (the inductive hypothesis). The way this should
generally be done is as follows:
Procedure 8.14. Given a proposition of the form “ LHS ( n ) = RHS ( n ) ,” the algebra in the
inductive step of an induction proof should be done as follow s:
LHS ( k + 1) = LHS ( k ) + stuf f (apply algebra to separate LHS ( k ) from the rest)
= RHS ( k ) + stuf f (use the inductive hypothesis to replace LHS ( k )
with RHS ( k ) )
= ··· (1 or more steps, usually involving algebra, that
= RHS ( k + 1) result in the goal of getting to RHS ( k + 1) )

Mathematical Induction 309
The last few examples followed this procedure, and your proo fs should also follow it. Notice that
these examples do not begin the inductive step by writing out LHS ( k + 1) = RHS ( k + 1). One
of them wrote it out, but it was before the inductive step for the purpose of making the goal in
the inductive step clear. The inductive step should always b egin by writing just LHS ( k + 1), and
should then use algebra, the inductive hypothesis, etc., un til RHS ( k + 1) is obtained.
This technique also works (with the appropriate slight modi fications) with inequalities, e.g.
LHS ( k ) ≤ RHS ( k ) and
LHS ( k ) ≥ RHS ( k ).
k k For instance, if P ( k ) is the statement “ k > 2 ”, LHS ( k ) = k , and RHS ( k ) = 2 . In addition, the
‘+ stuf f ’ is not always literally addition. For instance, it might be LHS ( k ) × stuf f .
Here is another example of this type of induction proof–this time using an inequality.
n Example 8.15. Prove that n < 2 for all integers n ≥ 1.
n Proof: Let P ( n ) be the statement “ n < 2 ”. We want to prove that P ( n ) is true
for all n ≥ 1.
1 Base Case: Since 1 < 2 , P (1) is clearly true.
k Hypothesis: We assume P ( k ) is true if k ≥ 1. That is, k < 2 .
Next we need to show that P ( k +1) is true. That is, we need to show that
k +1 ( k + 1) < 2 . (Notice that I did not state that this was true, and I do
not start with this statement in the next step. I am merely poi nting out
what I need to prove .) This paragraph is not really part of the proof–think
of it as a side-comment or scratch work.
k Inductive: Given that k < 2 , we can see that
k k k + 1 < 2 + 1   (since k < 2 )
k k k < 2 + 2 (since 1 < 2 when k ≥ 1)
k =  2(2 )
k +1 =  2
k +1 Since we have shown that k + 1 < 2 , P ( k + 1) is true.
Summary: Since we proved that P (1) is true, and that P ( k ) → P ( k +1), by PMI ,
P ( n ) is true for all n ≥ 1. 
In the previous example, LHS ( k ) = k , so LHS ( k + 1) is already in the form LHS ( k ) + stuf f
since LHS ( k + 1) = k + 1 = LHS ( k ) + 1. So the first step of algebra is unnecessary and we were
able to apply the inductive hypothesis immediately. Don’t l et this confuse you. This is essentially
the same as the other examples minus the need for algebra in th e first step.
Note: By the time you are done with this section, you will likely be t ired of hearing this,
but since it is the most common mistake made in induction proo fs, it is worth repeating ad
nauseam . Never begin the inductive step of an induction proof by writing down
P ( k + 1 ) . You do not know it is true yet, so it is not valid to write it down as if it were true
so that you can use a technique such as working both sides to ve rify that it is true (which, as
we have also previously stated, is not a valid proof techniqu e).

310 Chapter 8
You can (and sometimes should ) write down P ( k + 1) on another piece of paper or with
a comment such as “We need to prove that” preceding it so that y ou have a clear direction for
the inductive step.
If you can complete the next exercise without too much difficul ty, you are well on your way to
understanding how to write induction proofs.
n ∑
n ( n + 1)(2 n + 1) 2
i = ⋆ Exercise 8.16. Use induction to prove that for all n ≥ 1, .
6
i =1
(Hint: Follow the techniques and format of the previous exam ples and be smart about your
algebra and it will go a lot easier. Also, you will need to fact or a polynomial in the inductive
step, but if you determine what the goal is ahead of time, it sh ouldn’t be too difficult.)

Mathematical Induction 311
8.1.3  Variations
In this section we will discuss a few slight variations of the details we have presented so far. First
we discuss the fact that we do not need to use a propositional f unction. Then we will discuss a
variation regarding the inductive hypothesis.
It is not always necessary to explicitly define P ( k ) for use in an induction proof. P ( k ) is used
mostly for convenience and clarity. For instance, in the sol ution to the previous exercise, it allowed
us to just say
“ P ( k ) is true”
instead of saying
n ∑
n ( n + 1)(2 n + 1) 2
i = “ ”  (which is long)
6
i =1
or
“the statement is true for k ”  (which is a little vague/awkward).
Here is an example that does not use P ( k ). It also does not label the four parts of the proof.
That is perfectly fine. The main reason we have done so in previ ous examples is to help you identify
them more clearly.
Example 8.17. Let f be the n -th Fibonacci number. Prove that for all integers n ≥ 1, n
2 n f f = f + ( − 1) .
n − 1 n +1 n
Proof: For k = 1, we have
2 1 2 1 f f = 0 · 1 = 0 = 1 − 1 = 1 + ( − 1) = f + ( − 1) ,
0 2 1
and so the assertion is true for k = 1. Suppose k ≥ 1, and that the assertion is true
for k . That is,
k 2 + ( − 1) . f f = f
k − 1 k +1 k
This can be rewritten as
k 2 = f f − ( − 1) f
k − 1 k +1 k
(a fact that we will find useful below). Then
f f = f ( f + f ) (by definition of f applied to f ) n k k +2 k k +1 k k +2
2 = f f + f
k k +1 k
k = f f + f f − ( − 1) (by rewritten inductive hypothesis)
k k +1 k − 1 k +1
k +1 = f ( f + f ) + ( − 1)
k +1 k k − 1
k +1 = f f + ( − 1) (by the definition of f )
k +1 k +1 k
2 k +1 = f + ( − 1) ,
k +1
and so the assertion is true for k + 1. The result follows by induction. 

312 Chapter 8
⋆ Exercise 8.18. Use induction to prove that for all n ≥ 1,
2 3 n n +1 1 · 2 + 2 · 2 + 3 · 2 + ··· + n · 2 = 2 + ( n − 1)2
or if you prefer,
n ∑
i n +1 i · 2 = 2 + ( n − 1)2 .
i =1
Do so without using a propositional function. You may label t he four parts of your proof, but
it is not required.

Mathematical Induction 313
Example 8.19. Prove the generalized form of DeMorgan’s law. That is, show t hat for any
n ≥ 2, if p , p , . . . , p are propositions, then 1 2 n
¬ ( p ∨ p ∨···∨ p ) = ( ¬ p ∧¬ p ∧···∧¬ p ). 1 2 n 1 2 n
We provide several appropriate proofs of this one (and one in appropriate one).
Proof 1: (A typical proof)
Let P ( n ) be the statement “ ¬ ( p ∨ p ∨···∨ p ) = ( ¬ p ∧¬ p ∧···∧¬ p ).” We 1 2 n 1 2 n
want to show that for all n ≥ 2, P ( n ) is true. P (2) is DeMorgan’s law, so the base
case is true. Assume P ( k ) is true. Then
¬ ( p ∨ p ∨···∨ p )  = ¬ (( p ∨ p ∨···∨ p ) ∨ p ) associative law 1 2 1 2 k +1 k k +1
= ¬ ( p ∨ p ∨···∨ p ) ∧¬ p DeMorgan’s law 1 2 k k +1
=  ( ¬ p ∧¬ p ∧···∧¬ p ) ∧¬ p hypothesis 1 2 k k +1
=  ( ¬ p ∧¬ p ∧···∧¬ p ∧¬ p )  associative law 1 2 k k +1
Thus P ( k +1) is true. Since we proved that P (2) is true, and that P ( k ) → P ( k +1)
if k ≥ 2, by PMI , P ( n ) is true for all n ≥ 2. 
Proof 2: (Not explicitly defining/using P ( n ))
We know that ¬ ( p ∨ p ) = ( ¬ p ∧¬ p ) since this is simply DeMorgan’s law. Assume 1 2 1 2
the statement is true for k . That is, ¬ ( p ∨ p ∨···∨ p ) = ( ¬ p ∧¬ p ∧···∧¬ p ). 1 2 1 2 k k
Then we can see that
¬ ( p ∨ p ∨···∨ p )  = ¬ (( p ∨ p ∨···∨ p ) ∨ p ) associative law 1 2 1 2 k +1 k k +1
= ¬ ( p ∨ p ∨···∨ p ) ∧¬ p DeMorgan’s law 1 2 k k +1
=  ( ¬ p ∧¬ p ∧···∧¬ p ) ∧¬ p hypothesis 1 2 k k +1
=  ( ¬ p ∧¬ p ∧···∧¬ p ∧¬ p )  associative law 1 2 k k +1
Thus the statement is true for k + 1. Since we have shown that the statement is
true for n = 2, and that whenever it is true for k it is true for k + 1, by PMI , the
statement is true for all n ≥ 2. 
Sometimes it is acceptable to omit the justification in the su mmary. That is, there
isn’t necessarily a need to restate what you have proven and y ou can just jump to
the conclusion. So the previous proof could end as follows:
Thus the statement is true for k + 1. By PMI , the statement is true for
all n ≥ 2.
Proof 3: (common in journal articles, unacceptable for this class)
The result follows easily by induction. 

314 Chapter 8
n ∑
i · i ! = ( n + 1)! − 1. ⋆ Evaluate 8.20. Prove that for all positive integers n ,
i =1
Solution:   Base:   n  =  1
1 · 1! = (1 + 1)! − 1
1 = 2! − 1
1 = 1
n ∑
i · i!  =  (n + 1)! − 1  for  n ≥ 1. Assume
i=1
Induction:
n n+1 ∑ ∑
i · i! + (n + 1)(n + 1)! i · i! =
i=1 i=1
= (n + 1)! − 1 + (n + 1)(n + 1)!
= (n + 1 + 1)(n + 1)! − 1
= (n + 2)(n + 1)! − 1
= (n + 2)! − 1
Therefore  it  is   true  for  n.   Thus   by  PMI   it   is   true  for   n ≥ 1.
Evaluation
The second variation we wish to discuss has to do with the indu ctive hypothesis/step. In the
inductive step, we can replace P ( k ) → P ( k + 1) with P ( k − 1) → P ( k ) as long as we prove the
statement for all k larger than any of the base cases . In general, we can use whatever index we
want for the inductive hypothesis as long as we use it to prove that the statement is true for the
next index, and as long as we are sure to cover all of the indice s down to the base case.  For
instance, if we prove P ( k + 3) → P ( k + 4), then we need to show it for all k + 3 ≥ a (that is, all
k ≥ a − 3), assuming a is the base case. Put simply, the assumption we make about the value of k
must guarantee that the inductive hypothesis includes the b ase case(s).
⋆ Question 8.21. Consider a ‘proof’ of ∀ nP ( n ) that shows that P (1) is true and that P ( k ) →
P ( k + 1) for k > 1. What is wrong with such a proof?
Answer

Mathematical Induction 315
Note: Whether you assume P ( k ) or P ( k − 1) is true, you must specify the values of k precisely
based on your choice.  For instance, if you assume P ( k ) is true for all k > a , you have a
problem. Although you known P ( a ) is true (because it is a base case), when you assume P ( k )
is true for k > a , the smallest k can be is a +1 . In other words, when you prove P ( k ) → P ( k +1) ,
you leave out P ( a ) → P ( a + 1) . But that means you can’t get anywhere from the base case, so
the whole proof is invalid.
If you are wondering why we would use P ( k − 1) as the inductive hypothesis instead of P ( k ),
it is because sometimes it makes the proof easier–for instan ce, the algebra steps involved might be
simpler.
Example 8.22. Prove that the expression
3 n +3 3 − 26 n − 27
is a multiple of 169 for all natural numbers n .
3 k +3 Proof: Let P ( k ) be the statement “3 − 26 k − 27 = 169 N for some N ∈ N .”
We will prove that P (0) is true and that P ( k − 1) → P ( k ).
3 · 0+3 When k = 0, 3 − 26 · 0 − 27 = 27 − 27 = 0 = 169 · 0, so P (0) is true.
Let k > 0 and assume P ( k − 1) is true. That is, there is some N ∈ N such that
3( k − 1)+3 3 − 26( k − 1) − 27 = 169 N .  After a little algebra, this is the same as
3 k 3 − 26 k − 1 = 169 N . Then
3 k +3 3 k 3 − 26 k − 27  =  27 · 3 − 26 k − 27
3 k =  27 · 3 + (26 − 27)26 k − 27
3 k =  27 · 3 − 27 · 26 k − 27 + 26 · 26 k
3 k =  27(3 − 26 k − 1) + 676 k
=  27 · 169 N + 169 · 4 k (By the inductive hypothesis)
=  169(27 · N + · 4 k )
which is divisible by 169. The assertion is thus established by induction. 
⋆ Question 8.23. Did you notice that in the previous example we assumed k > 0 instead of
k ≥ 0? Why did we do that?
Answer
8.1.4  Strong Induction
The form of induction we have discussed up to this point only a ssumes the statement is true for
one value of k . This is sometimes called weak induction . In strong induction , we assume that the
statement is true for all values up to and including k . In other words, with strong induction, the
inductive hypothesis involves proving that
[ P ( a ) ∧ P ( a + 1) ∧···∧ P ( k )] → P ( k + 1) if k ≥ a .

316 Chapter 8
This may look more complicated, but practically speaking, t here is really very little difference.
Essentially, strong induction just allows us to assume more than weak induction.  Let’s see an
example of why we might need strong induction.
Example 8.24. Show that every integer n ≥ 2 can be written as the product of primes.
Proof: Let P ( n ) be the statement “ n can be written as the product of primes.”
We need to show that for all n ≥ 2, P ( n ) is true.
Since 2 is clearly prime, it can be written as the product of on e prime. Thus P (2)
is true.
Assume [ P (2) ∧ P (3) ∧···∧ P ( k − 1)] is true for k > 2. In other words, assume all
of the numbers from 2 to k − 1 can be written as the product of primes.
We need to show that P ( k ) is true. If k is prime, clearly P ( k ) is true. If k is not
prime, then we can write k = a · b , where 2 ≤ a ≤ b < k . By hypothesis, P ( a ) and
P ( b ) are true, so a and b can be written as the product of primes. Therefore, k can
be written as the product of primes, namely the primes from th e factorizations of
a and b . Thus P ( k ) is true.
Since we proved that P (2) is true, and that [ P (2) ∧ P (3) ∧···∧ P ( k − 1)] → P ( k ) if
k > 2, by the principle of mathematical induction, P ( n ) is true for all n ≥ 2. That
is, every integers n ≥ 2 can be written as the product of primes. 
Example 8.25. In the country of SmallPesia coins only come in values of 3 and 5 pesos. Show
that any quantity of pesos greater than or equal to 8 can be pai d using the available coins.
Proof:   Base Case: Observe that 8 = 3 + 5, 9 = 3 + 3 + 3, and 10 = 5 + 5, so
we can pay 8, 9, or 10 pesos with the available coinage.
Inductive Hypothesis: Assume we can pay any value from 8 to k − 1 pesos,
where k ≥ 11.
Inductive step: The inductive hypothesis implies that we can pay with k − 3
pesos. We can add to the coins used for k − 3 pesos a single coin of value 3 in order
to pay for k pesos.
Summary: Since we can pay for 8, 9, and 10 pesos, and whenever we can pay
for anything between 8 and k − 1 pesos we can pay for k pesos, the strong form of
induction implies that we can pay for any quantity of pesos n ≥ 8.
Notice that the reason we needed three base cases for this pro of was the fact that we
looked back at k − 3 , three value previous to the value of interest. If we had only
proven it for 8 , we would have needed to prove 9 and (more importantly) 10 in the
inductive step. But the inductive step doesn’t work for 10 since there is no solution
for 10 − 3 = 7 pesos. 
Notice that there is no way we could have used weak induction i n either of the previous examples.

Mathematical Induction 317
8.1.5  Induction Errors
The following examples should help you appreciate why we nee d to be very precise/careful when
writing induction proofs.
n Example 8.26. What is wrong with the following (supposed) proof that a = 1 for n ≥ 0:
0 Proof: Base case: Since a = 1, the statement is true for n = 0.
j Inductive step: Let k > 0 and assume a = 1 for 0 ≤ j ≤ k . Then
k k 1 · 1 a · a
k +1 = 1. = a =
k − 1 a 1
n Summary: Therefore by PMI, a = 1 for all n ≥ 0. 
Solution: The base case is correct, and there is nothing wrong with the s ummary,
k k − 1 assuming the inductive step is correct. a = 1 and a = 1 are correct by the
inductive hypothesis since we are assuming k > 0. The algebra is also correct. So
− 1 what is wrong? The problem is that when k = 0, a would be in the denominator.
− 1 But we don’t know whether or not a = 1. Thus we needed to assume k > 0. As
it turns out, that is precisely where the problem lies. We pro ved that P (0) is true
and that P ( k ) → P ( k + 1) is true when k > 0. Thus, we know that P (1) → P (2),
and P (2) → P (3), etc., but we never showed that P (0) → P (1) because, of course,
it isn’t true. The induction doesn’t work without P (0) → P (1).
⋆ Evaluate 8.27. Prove or disprove that all goats are the same color.
Solution:    If   there   is   one   goat,   it   is   obviously   the   same   color   as   itself.
Let   n ≥ 1   and   assume   that   any   collection   of   n   goats   are   all   the   same
color.   Consider  a  collection  of  n + 1  goats.   Number  the  goats  1  through
n +  1.   Then   goats   1   through   n   are   the   same   color   (since   there   are   n   of
them)  and  goats  2  through  n + 1  are  the  same  color  (again,  since  there
are  n   of   them).   Since   goat   2   is   in   both   collections,   the   goats   in   both
collections   are  the  same   color.   Thus,   all   n + 1   goats  are  the   same  color.
Evaluation
The next example deals with binary palindromes . Binary palindromes can be defined recursively
by λ , 0, 1 ∈ P , and whenever p ∈ P , then 1 p 1 ∈ P and 0 p 0 ∈ P . (Note: λ is the notation sometimes
used to denote the empty string —that is, the string of length 0. Also, 1 p 1 means the binary string
obtained by appending 1 to the begin and end of string p . Similarly for 0 p 0.) Notice that there is
1 palindrome of length 0 ( λ ), 2 of length 1 (0, 1), 2 of length 2 (00, 11), 4 of length 3 (000, 010,
101, 111), etc.

318 Chapter 8
⋆ Evaluate 8.28. Use induction to prove that the number of binary palindromes of length 2 n
n (even length) is 2 for all n ≥ 0.
Proof   1: Base   case:    k  =  1.    The   total   number   of   palindromes   of   length   2  =  2
1 is   2 =  2.   It   is   true.
k Assume   the   total   number   of   binary   palindromes   with   length   2k   is   2 . To
form  a  binary  palindrome  with  length  2(k + 1)  =  2k + 2,  with  every  element  i n
the   set   of   binary   palindromes   with   length   2k   we   either   put   (00)   or   (11) to
the   end   or   beginning   of   it. Therefore,   the   number   of   binary   palindromes
with   length   2(k  +  1)   is   twice   as   many   as   the   number   of   binary   palindromes
k k+1 with  length  2k,  which  is  2 × 2 =  2 .   Thus  it  is  true  for  k + 1.   By  the  principle
of  mathematical  induction,  the  total  number  of  binary  palindromes  of  leng th
n 2n  for  n ≥ 1   is   2 .
Evaluation
0 Proof   2: For    the    base    case, notice    that    there    is    1   =   2 palindromes    of
length    0   (the   empty   string). Now   assume   it   is    true   for   all    n. For   each
consecutive   binary   number   with   n   bits,   you   are   adding   a   bit   to   either end,
2 which   multiplies   the   total   number   by   2 permutations,    but   for   it   to   be   a
palindrome,  they  both  have  to  be  either  0  or  1,  so  it  would  just  be  2  ins tead,
k so  for   binary  numbers  of   length   2k,  there   are  2 palindromes.
Evaluation
Proof   3: The   empty   string   is   the   only   string   of   length   0,   and   it   is   a   palin-
0 drome.   Thus   there   is   1  =  2 palindromes   of   length   0.   Let   2n   be   the   length,
n assume   2n → 2 palindromes.    Now   we   look   at   n +  1   so   we   know   the   length
is   2n  +  2   and   it   starts   and   ends   with   either    0   or   1   and   has   2n   values   in
n n n n+1 between.   Both  possibilities   imply   2 palindromes,   so   2 + 2 =  2 .
Evaluation

Mathematical Induction 319
⋆ Exercise 8.29. Based on the feedback from the previous Evaluate exercise, c onstruct a
n proper proof that the number of binary palindromes of length 2 n is 2 for all n ≥ 0.
8.1.6  Summary/Tips
Induction proofs are both intuitive and non-intuitive. On t he one hand, when you talk through
the idea, it seems to make sense. On the other hand, it almost s eems like you are using circular
reasoning . It is important to understand that induction proofs do not rely on circular reasoning.
Circular reasoning is when you assume p in order to prove p . But here we are not doing that. We
are assuming P ( k ) and using that fact to prove P ( k + 1), a different statement. However, we are
not assuming that P ( k ) is true for all k ≥ a . We are proving that if we assume that P ( k ) is
true , then P ( k + 1) is true. The difference between these statements may seem s ubtle, but it is
important.
8.10 Let’s summarize our approach to writing an induction proof. This is similar to Procedure
except we include several of the unofficial steps we have been u sing that often come in handy. You
are not required to use this procedure, but if you are having a difficult time with induction proofs,
try this out. Here is the brief version. After this we provide some further comments about each
step.

320 Chapter 8
Procedure 8.30. A slightly longer approach to writing an induction proof is a s follows:
1. Define: (optional) Define P ( n ) based on the statement you need to prove.
2. Rephrase: (optional) Rephrase the statement you are trying to prove us ing P ( n ) . This
step is mostly to help you be clear on what you need to prove.
3. Base Case: Prove the base case or cases.
4. Inductive Hypothesis: Write down the inductive hypothesis. Usually it is as simple
as “Assume that P ( k ) is true”.
5. Goal: (optional) Write out the goal of the inductive step (coming next). It is usually
“I need to show that P ( k + 1) is true” It can be helpful to explicitly write out P ( k + 1) ,
although see important comments about this step below. This i s another step that is mostly
for your own clarity.
6. Inductive: Prove the goal statement, usually using the inductive hypothesis .
7. Summary: The typical induction summary.
8.30 . Here are some comments about the steps in Procedure
1. Define: P ( n ) should be a statement about a single instance, not about a se ries of instances.
n For example, it should be statements like “2 n is even” or “A set with n elements has 2
2 subsets.” It should NOT be of the form “2 n is even if n > 1,” “ n > 0 if n 6 = 0,” or “For all
n n > 1, a set with n elements has 2 subsets.”
2. Rephrase: In almost all cases, the rephrased statement should be “For a ll n ≥ a , P ( n ) is
true,” where a is some constant, often 0 or 1. If the statement cannot be phra sed in this way,
induction may not be appropriate.
3. Base Case: For most statements, this means showing that P ( a ) is true, where a is the value
from the rephrased statement. Although usually one base cas e suffices, sometimes one must
prove multiple base cases, usually P ( a ), P ( a + 1), . . . , P ( a + i ) for some i > 0. This depends
on the details of the inductive step.
4. Inductive Hypothesis: This is almost always one of the following:
• Assume that P ( k ) is true.
• Assume that P ( k − 1) is true.
• Assume that [ P ( a ) ∧ P ( a + 1) ∧···∧ P ( k )] is true (strong induction)
Sometimes it is helpful to write out the hypothesis explicit ly (that is, write down the whole
statement with k or k − 1 plugged in).
5. Goal: As previously stated, this is almost always “I need to show th at P ( k + 1) is true” (or
“I need to show that P ( k ) is true”). But it can be very helpful to explicitly write out what
P ( k + 1) is so you have a clear direction for the next step. However , it is very important
that you do not just write out P ( k + 1) without prefacing it with a statement like “I need to
show that...”. Since you are about to prove that P ( k + 1) is true, you don’t know that it is

Mathematical Induction 321
true yet, so writing it down as if it is a fact is incorrect and c onfusing. In fact, it is probably
better write the goal separate from the rest if the proof (e.g . on another piece of paper).
The goal does not need to be written down and is not really part of the proof. The only
purpose of doing so it to help you see what you need to do in the n ext step. For instance,
knowing the goal often helps you to figure out the required alg ebra steps to get there.
6. Inductive: This is the longest, and most varied, part of the proof. Once y ou get the hang
of induction, you will typically only think about two parts o f the proof—the base case and
this step. The rest will become second nature.
The inductive step should not start with writing down P ( k +1). Some students want to write
out P ( k +1) and work both sides until they get them to be the same. As we have emphasized
on several occasions, this is not a proper proof technique. You cannot start with something
you do not know and then work it until you get to something you d o know and then declare
it is true.
7. Summary: This is easy. It is almost always either:
“Since we proved that P ( a ) is true, and that P ( k ) → P ( k + 1), for k ≥ a , then we
know that P ( n ) is true for all n ≥ a by PMI , ” or
“Since we proved that P ( a ) is true, and that [ P ( a ) ∧ P ( a +1) ∧···∧ P ( k )] → P ( k +1),
for k ≥ a , P ( n ) is true for all n ≥ a by PMI .”
The details change a bit depending on what your inductive hyp othesis was (e.g. if it was
P ( k − 1) instead of P ( k )).  Technically speaking, you can just summarize your proof by
saying
“Thus, P ( n ) is true for all n ≥ a by PMI .”
As long as someone can look back and see that you included the t wo necessary parts of the
proof, you do not necessarily need to point them out again.

322 Chapter 8
8.2  Recursion
You have seen examples of recursion if you have seen Russian M atryoshka dolls (Google it), two
almost parallel mirrors, a video camera pointed at the monit or, or a picture of a painter painting
a picture of a painter painting a picture of a painter... More importantly for us, recursion is a very
useful tool to implement algorithms. You probably already l earned about recursion in a previous
programming course, but we present the concept in this brief section for the sake of review, and
because it ties in nicely with the other two topics in this cha pter.
Definition 8.31. An algorithm is recursive if it calls itself.
Examples of recursion that you may have already seen include binary search , Quicksort , and
Mergesort .
⋆ Question 8.32. Is following algorithm recursive? Briefly explain.
int ferzle( int n) {
if (n<=0) {
return 3;
} else {
return ferzle(n-1) + 2;
}
}
Answer
If a subroutine/function simply called itself as a part of it s execution, it would result in infinite
recursion. This is a bad thing. Therefore, when using recurs ion, one must ensure that at some
point, the subroutine/function terminates without callin g itself. We will return to this point after
we see what is perhaps the quintessential example of recursi on.
Example 8.33. Notice that
0!  =  1
1!  =  1 =  1 × 0!
2!  =  2 × 1 =  2 × 1!
3!  =  3 × 2 × 1 =  3 × 2!
4!  =  4 × 3 × 2 × 1 =  4 × 3!
5!  =  5 × 4 × 3 × 2 × 1 =  5 × 4!
and in general, when n > 1,
n !  = n × ( n − 1) ×···× 2 × 1  = n × ( n − 1)!
In other words, we can define n ! recursively as follows:
ß
1 when n = 0
n ! =
n ∗ ( n − 1)!  otherwise.
This leads to the following recursive algorithm to compute n ! when n ≥ 0.

Recursion 323
int factorial( int n) {
if (n <=0) {
return 1;
} else {
return n*factorial(n-1);
}
}
To guarantee that they will terminate, every recursive algo rithm needs all of the following.
1. Base case(s) : One or more cases which are solved non-recursively. In othe r words, when an
algorithm gets to the base case, it does not call itself again . This is also called a stopping
case or terminating condition .
2. Inductive case(s) : One or more recursive rule for all cases except the base case .
3. Progress: The inductive case(s) should always progress toward the bas e case.  Often this
means the arguments will get smaller until they approach the base case, but sometimes it is
more complicated than this.
Example 8.34. Let’s take a closer look at the factorial algorithm from Example 8.33 . If
n ≤ 0, factorial does not make a recursive call. Thus, it has a base case . When n > 0, it
is clearly making a recursive call, so it has inductive cases . When a recursive call is made to
factorial , the argument is smaller, so it is approaching a base case (i. e. making progress ).
⋆ Question 8.35. Consider the ferzle algorithm from Question 8.32 above.
(a) What is/are the base case/cases?
Answer
(b) What are the inductive cases?
Answer
(c) Do the inductive cases make progress?
Answer
Example 8.36. Prove that the recursive factorial(n) algorithm from Example 8.33 returns
n ! for all n ≥ 0.
Proof: Notice that if n = 0, factorial(0) returns 1 = 0!, so it works in that
case.  For k ≥ 0, assume factorial(k) works correctly.  That is, it returns k !.
factorial(k+1) return k + 1 times the value returned by factorial(k) . By the
inductive hypothesis, factorial(k) returns k !, so factorial(k+1) returns ( k + 1) ×
k ! = ( k + 1)!, as it should. By PMI, factorial(n) returns n ! for all n ≥ 0. 

324 Chapter 8
Example 8.37. Implement an algorithm countdown(int n) that outputs the integers from n
down to 1, where n > 0. So, for example, countdown(5) would output “5 4 3 2 1”.
Solution: One way to do this is with a simple loop:
void countdown( int n) {
for (i=n;i>0;i--)
print(i);
}
We wouldn’t learn anything about recursion if we used this so lution. So let’s con-
sider how to do it with recursion. Notice that countdown(n) outputs n followed by
the numbers from n − 1 down to 1. But the numbers n − 1 down to 1 are the output
from countdown(n-1) . This leads to the following recursive algorithm:
void countdown( int n) {
print(n);
countdown(n-1):
}
To see if this is correct, we can trace through the execution o f countdown(3) . The
following table give the result.
Execution of    outputs  then executes
countdown(3) 3 countdown(2)
countdown(2) 2 countdown(1)
countdown(1) 1 countdown(0)
countdown(0) 0 countdown(-1)
countdown(-1) -1 countdown(-2)
. . . . . .
. . .
Unfortunately, countdown will never terminate. We are supposed to stop printing
when n = 1, but we didn’t take that into account.  In other words, we do n’t
have a base case in our algorithm. To fix this, we can modify it s o that a call to
countdown(0) produces no output and does not call countdown again.
Calls to countdown(n) should also produce no output when n < 0. The following
algorithm takes care of both problems and is our final solutio n.
void countdown( int n) {
if (n>0) {
print(n);
countdown(n-1);
}
}
Notice that when n ≤ 0, countdown(n) does nothing, making n ≤ 0 the base cases .
When n > 0, countdown(n) calls countdown(n-1) , making n > 0 the inductive cases .
Finally, when countdown(n) makes a recursive call it is to countdown(n-1) , so the
inductive cases progress to the base case.

Recursion 325
⋆ Exercise 8.38. Prove that the recursive countdown(n) algorithm from Example 8.37 works
correctly. (Hint: Use induction.)
In general, we can solve a problem with recursion if we can:
1. Find one or more simple cases of the problem that can be solv ed directly.
2. Find a way to break up the problem into smaller instances of the same problem.
3. Find a way to combine the smaller solutions.
Let’s see a few classic examples of the use of recursion.
Example 8.39. Consider the binary search algorithm to find an item v on a sorted list of size
n . The algorithm works as follows.
• We compare the middle value m of the array to v .
• If the m = v , we are done.
• Else if m < v , we binary search the left half of the array.
• Else ( m > v ), we binary search the right half of the array.
• Now, we have the same problem, but only half the size.
In Example 7.162 we saw the following iterative implementation of binary sea rch:
int binarySearch( int a[], int n, int val) {
int left=0, right=n-1;
while (right >=left) {
int middle = (left+right)/2;
if (val==a[middle ])
return middle;
else if (val =left) {
int middle = (left+right)/2;
if (val==a[middle ])
return middle;
else if (val  a [ middle ] is symmetric to the previous case and the details
are left to the reader.
In all cases, it works correctly on an array of size k .
Summary: Since it works for an array of size 0 and whenever it works for a rrays
of size at most k − 1 it works for arrays of size k , by the principle of mathematical
induction, it works for arrays of any nonnegative size. 

Recursion 327
Note: You might think the base case in the previous proof should be n = 1 , but that is not
actually correct. A failed search will always make a final cal l to binarySearch with n = 0 . If
we don’t prove it works for an empty array then we cannot be cer tain that it works for failed
searches.
Example 8.41. Recall the Fibonacci sequence , defined by the recurrence relation

0 if n =0 
f = 1 if n =1 n

f + f if n > 1. n − 1 n − 2
Let’s see an iterative and a recursive algorithm to compute f . The iterative algorithm (on n
the left) starts with f and f and computes each f based on f and f for i from 2 to n . 0 1 i i − 1 i − 2
As it goes, it needs to keep track of the previous two values. T he recursive algorithm (on the
right) just uses the definition and is pretty straightforwar d.
int Fib( int n) { int FibR( int n) {
int fib; if (n  <= 1) {
if (n <= 1) { return (n);
return (n); else { }
} else { return (FibR(n-1)+FibR(n-2));
int fibm2=0; }
int fibm1=1; }
int index=1;
while (index  < n) {
fib=fibm1+fibm2;
fibm2=fibm1;
fibm1=fib;
index ++;
}
return (fib);
}
}
⋆ Question 8.42. Which algorithm is better, Fib or FibR ? Give several reasons to justify
your answer.
Answer
Although recursion is a great technique to solve many proble ms, care must be taken when using
it. It easy to make simple mistakes like we did in Example 8.37 . They can also be very inefficient
on occasion, as we alluded to in the previous example (and wil l prove later). In addition, recursive
algorithms often take more memory than iterative ones, as we will see next.

328 Chapter 8
Example 8.43. Consider our algorithms for n !. The iterative one from Example 5.49 uses
a The recursive one from Example 8.33 memory to store four numbers: n , f , i , and return value.
uses memory to store two numbers: n and the return value. Although the recursive algorithm
uses less memory, it is called multiple times, and every call needs its own memory. For instance,
a call to factorial(3) will call factorial(2) which will call factorial(1) . Thus, computing 3!
requires enough memory to store 6 numbers, which is more than the 4 required by the iterative
algorithm. In general, the recursive algorithm to compute n ! will need to store 2 n numbers,
whereas the iterative one will still just need 4, no matter ho w large n gets.
a I won’t get technical here, but memory needs to be allocated f or the value returned by a function.
Since computers have a finite amount of memory, and since ever y call to a function requires its
own memory, there is a limit to how many recursive calls can be made in practice. In fact some
languages, including Java, have a defined limit of how deep th e recursion can be. Even for those
that don’t have a limit, if you run out of memory, you can certa inly expect bad things to happen.
This is one of the reasons recursion is avoided when possible .
Good compilers attempt to remove recursion, but it is not alw ays possible. Good programmers
do the same. Since recursive algorithms are often more intui tive, it often makes sense to think in
terms of them. But many recursive algorithms can be turned in to iterative algorithms that are as
efficient and use less memory. There is no single technique to d o so, and it is not always necessary,
but it is a good thing to keep in mind.
Let’s see a few more examples of the subtle problems that we ca n run into when using recursion.
Example 8.44. The following algorithm is supposed to sum the numbers from 1 to n :
void Sum1toN( int n) {
if (n == 0) return (0);
else           return (n + Sum1toN(n-1));
}
Although this algorithm works fine for non-negative values o f n , it will go into infinite
recursion if n < 0. Like our original solution to the countdown problem, the mistake here is an
improper base case .
It is easy to get things backwards when recursion is involved . Consider the following example.
⋆ Question 8.45. One of these routines prints from 1 up to n , the other from n down to 1.
Which does which?
void PrintN( int n) { void NPrint( int n) {
if (n > 0) { if (n > 0) {
PrintN(n-1); print(n);
print(n); NPrint(n-1);
} }
} }
Answer
We conclude this section by summarizing some of the advantag es and disadvantages of recursion.
The advantages include:

Recursion 329
1. Recursion often mimics the way we think about a problem, th us the recursive solutions can
be very intuitive to program.
2. Often recursive algorithms to solve problems are much sho rter than iterative ones. This can
make the code easier to understand, modify, and/or debug.
3. The best known algorithms for many problems are based on a d ivide-and-conquer approach:
• Divide the problem into a set of smaller problems
• Solve each small problem separately
• Put the results back together for the overall solution
These divide-and-conquer techniques are often best though t of in terms of recursive algo-
rithms.
Perhaps the main disadvantage of recursion is the extra time and space required.  We have
already discussed the extra space. The extra time comes from the fact that when a recursive call is
made, the operating system has to record how to restart the ca lling subroutine later on, pass the
parameters from the calling subroutine to the called subrou tine (often by pushing the parameters
onto a stack controlled by the system), set up space for the ca lled subroutine’s local variables, etc.
The bottom line is that calling a function is not “free”.
Another disadvantage is the fact that sometimes a slick-loo king recursive algorithm turns out
8.42 . On the other hand, if such inefficiencies to be very inefficient. We alluded to this in Example
are found, there are techniques that can often easily remove them (e.g. a technique called memo-
2 ization ). But you first have to remember to analyze your algorithm to d etermine whether or not
there might be an efficiency problem.
2 No, that’s not a typo. Google it.

330 Chapter 8
8.3  Solving Recurrence Relations
Recall that a recurrence relation is simply a sequence that is recursively defined. More formal ly, a
3 recurrence relation is a formula that defines a in terms of a , for one or more values of i < n .
n i
Example 8.46. We previously saw that we can define n ! by 0! = 1, and if n > 0, n ! = n · ( n − 1)!.
This is a recurrence relation for the sequence n !.
Similarly, we have seen the Fibonacci sequence several time s. Recall that n -th Fibonacci
number is given by f = f = 1 and for n > 1, f = f + f . This is recurrence relation 0 1 n n − 1 n − 2
for the sequence of Fibonacci numbers.
Example 8.47. Each of the following are recurrence relations.
t = n · t + 4 · t n n − 1 n − 3
r = r + 1 n n/ 2
a = a + 2 · a + 3 · a + 4 · a n n − 1 n − 2 n − 3 n − 4
p = p · p n n − 1 n − 2
2 s = s + n − 4 n + 32
n n − 3
We have not given any initial conditions for these recurrenc e relations. Without initial con-
ditions, we cannot compute particular values. We also canno t solve the recurrence relation
uniquely.
Recurrence relations have 2 types of terms: recursive term(s) and the non-recursive terms.  In
2 the previous example, the recursive term of s is s and the non-recursive term is n − 4 n + 32.
n n − 3
⋆ Question 8.48. Consider the recurrence relations r and a from Example 8.47 . n n
? (a) What are the recursive terms of r n
Answer
(b) What are the non-recursive terms of r ? n
Answer
(c) What are the recursive terms of a ? n
Answer
(d) What are the non-recursive terms of a ? n
Answer
3 You might also see recurrence relations written using funct ion notation, like a ( n ). Although there are technical
differences between these notations, you can think of them as being essentially equivalent in this context.

Solving Recurrence Relations 331
In computer science, the most common place we use recurrence relations is to analyze recursive
algorithms. We won’t get too technical yet, but let’s see a si mple example.
Example 8.49. How many multiplications are required to compute n ! using the factorial
8.33 (repeated below)? algorithm given in Example
int factorial( int n) {
if (n <=0) {
return 1;
} else {
return n*factorial(n-1);
}
}
Solution: Let M be the number of multiplications needed to compute n ! using n
8.33 . From the code, it is obvious that the factorial algorithm from Example
M = 0. If n > 0, the algorithm uses one multiplication and then makes a rec ursive 0
call to factorial(n-1) . By the way we defined M , factorial(n-1) does M n n − 1
multiplications. Therefore, M = M + 1. n n − 1
So the recurrence relation for the number of multiplication s is
ß
0 if n =0
M = n
M + 1  if n > 0. n − 1
Given a recurrence relation for a , you can’t just plug in n and get an answer. For instance, n
if a = n · a , and a = 1, what is a ? The only obvious way to compute it is to compute n n − 1 1 100
a , a , . . . , a , and then finally a .  That is the reason why solving recurrence relations is so 2 3 99 100
important. As mentioned previously, solving a recurrence r elation simply means finding a closed
form expression for it.
Example 8.50. It is not too difficult to see that the recurrence from Example 8.49 has the
solution M = n . To prove it, notice that with this assumption, M + 1 = ( n − 1) + 1 = n = n n − 1
M , so the solution is consistent with the recurrence relation . n
We can also prove it with induction: We know that M = 0, so the base case of k = 0 is 0
true. Assume M = k for k ≥ 0. Then we have k
M = M + 1 = k + 1, k +1 k
so the formula is correct for k + 1. Thus, by PMI, the formula is correct for all k ≥ 0.
The last example demonstrates an important fact about recur rence relations used to analyze
algorithms. The recursive terms come from when a recursive f unction calls itself. The non-recursive
terms come from the other work that is done by the function, in cluding any splitting or combining
of data that must be done.

332 Chapter 8
Example 8.51. Consider the recursive binary search algorithm we saw in Example 8.39 :
int binarySearch( int [] a, int left , int right , int val) {
if (right >=left) {
int middle = (left+right)/2;
if (val==a[middle ])
return middle;
else if (val  1 , and c > 0 . If f ( n ) = Θ( n ) , where d ≥ 0 , then
 d d
Θ( n ) if a < b 
d d Θ( n log n ) if a = b T ( n ) =
 log a d b
Θ( n ) if a > b
Example 8.66. Use the Master Theorem to solve the recurrence
T ( n ) = 4 T ( n/ 2) + n , T (1) = 1.
1 log 4 2 Solution: We have a = 4, b = 2, and d = 1. Since 4 > 2 , T ( n ) = Θ( n ) =
2 Θ( n ) by the third case of the Master Theorem.
Example 8.67. Use the Master Theorem to solve the recurrence
2 T ( n ) = 4 T ( n/ 2) + n , T (1) = 1.
2 Solution: We have a = 4, b = 2, and d = 2. Since 4 = 2 , we have T ( n ) =
2 Θ( n log n ) by the second case of the Master Theorem.
Example 8.68. Use the Master Theorem to solve the recurrence
3 T ( n ) = 4 T ( n/ 2) + n , T (1) = 1.
3 3 Solution: Here, a = 4, b = 2, and d = 3. Since 4 < 2 , we have T ( n ) = Θ( n ) by
the first case of the Master Theorem.
4 Wow. That was easy. But the ease of use of the Master Method comes with a cost. Well ,
two actually. First, notice that we do not get an exact solution, but only an asymptotic bound on
the solution. Depending on the context, this may be good enou gh. If you need an exact numerical
solution, the Master Method will do you no good. But when anal yzing algorithms, typically we
are more interested in the asymptotic behavior. In that case , it works great. Second, it only works
for recurrences that have the exact form T ( n ) = aT ( n/b ) + f ( n ). It won’t even work on similar
recurrences, such as T ( n ) = T ( n/b ) + T ( n/c ) + f ( n ).
4 Almost too easy.

Solving Recurrence Relations 345
⋆ Exercise 8.69. Use the Master Theorem to solve the recurrence
T ( n ) = 2 T ( n/ 2) + 1, T (1) = 1.
Example 8.70. Let’s redo one from a previous section. Use the Master Theore m to solve the
recurrence ß
1 when n = 1
R ( n ) =
2 R ( n/ 2) + n/ 2  otherwise
1 Solution: Here, we have a = 2, b = 2, and d = 1.  Since 2 = 2 , R ( n ) =
1 8.58 we showed that R ( n ) = Θ( n log n ) = Θ( n log n ).  Recall that in Example
n + (log n ) n/ 2. Since n + (log n ) n/ 2 = Θ( n log n ), our solution is consistent. 2 2
⋆ Exercise 8.71. Use the Master Theorem to solve the recurrence
2 T ( n ) = 7 T ( n/ 2) + 15 n / 4, T (1) = 1.
⋆ Question 8.72. In the solution to the previous exercise, we stated that
log 7 2.8 2 ‘ T ( n ) = Θ( n ), which is about Θ( n ).’
log 7 2.8 2 Why didn’t we just say ‘ T ( n ) = Θ( n ) = Θ( n )’?
Answer

346 Chapter 8
⋆ Exercise 8.73. We saw in Example 8.51 that the complexity of binary search is given by
the recurrence relation T ( n ) = T ( n/ 2) + 1, T (0) = 1 (and you may assume that T (1) = 1).
Use the Master Theorem to solve this recurrence.
8.3.4  Linear Recurrence Relations
Although in my mind linear recurrence relations are of the le ast importance of these four methods
for computer scientists, we will discuss them very briefly, b oth for completeness sake, and because
we can talk about the Fibonacci numbers again.
Definition 8.74. Let c , c , . . . , c be real constants and f : N → R a function. A recurrence 1 2 k
relation of the form
a = c a + c a + ··· + c a + f ( n ) (8.1) n 1 n − 1 2 n − 2 k n − k
is called a linear recurrence relation (or linear difference equation ). If f ( n ) = 0 (that
is, there is no non-recursive term), we say that the equation is homogeneous , and otherwise
we say the equation is nonhomogeneous .
The order of the recurrence is the difference between the highest and the lowest subscripts.
5 Example 8.75. u = u +2 is of the first order, and u = 9 u + n is of the fourth order.
n n − 1 n n − 4
There is a general technique that can be used to solve linear h omogeneous recurrence relations.
However, we will restrict our discussion to certain first and second order recurrences.
First Order Recurrences
In this section we will learn a technique to solve some first-o rder recurrences. We won’t go into
detail about why the technique works.
Procedure 8.76. Let f ( n ) be a polynomial and a 6 = 1 . Then the following technique can be
used to solve a first order linear recurrence relations of the form
x = ax + f ( n ). n n − 1
1. First, ignore f ( n ) . That is, solve the homogeneous recurrence x = ax . This is done n n − 1
as follows:
n n − 1 (a) ‘Raise the subscripts’, so x = ax becomes x = ax . This is called the char-
n n − 1
acteristic equation .
(b) Canceling this gives x = a .

Solving Recurrence Relations 347
n (c) The solution to the homogeneous equation x = ax will be of the form x = Aa ,
n n − 1 n
where A is a constant to be determined.
2. Assume that the solution to the original recurrence relat ion, x = ax + f ( n ) , is of the n n − 1
n form x = Aa + g ( n ), where g is a polynomial of the same degree as f ( n ) .
n
3. Plug in enough values to determine the correct constants f or the coefficients of g ( n ) .
This procedure is a bit abstract, so let’s just jump into seei ng it in action.
Example 8.77. Let x = 7 and x = 2 x , n ≥ 1. Find a closed form for x . 0 n n − 1 n
n n − 1 Solution: Raising subscripts we have the characteristic equation x = 2 x .
n Canceling, x = 2.  Thus we try a solution of the form x = A 2 , were A is a
n
0 n constant. But 7 = x = A 2 = A and so A = 7. The solution is thus x = 7(2) .
0 n
Example 8.78. Let x = 7 and x = 2 x + 1, n ≥ 1. Find a closed form for x . 0 n n − 1 n
Solution: By raising the subscripts in the homogeneous equation we obt ain
n n − 1 x = 2 x or x = 2. A solution to the homogeneous equation will be of the form
n x = A (2) . Now f ( n ) = 1 is a polynomial of degree 0 (a constant) and so the
n
n 0 general solution should have the form x = A 2 + B . Now, 7 = x = A 2 + B =
n 0
A + B . Also, x = 2 x +1 = 15 and so 15 = x = 2 A + B . Solving the simultaneous 1 0 1
equations
A + B = 7,
2 A + B = 15,
Using these equations, we can see that A = 7 − B and B = 15 − 2 A . Plugging
the latter into the former, we have A = 7 − (15 − 2 A ) = − 8 + 2 A , or A = 8.
Plugging this back into either equation, we can see that B = − 1. So the solution
n n +3 is x = 8(2 ) − 1 = 2 − 1.
n

348 Chapter 8
⋆ Exercise 8.79. Let x = 2, x = 9 x − 56 n + 63. Find a closed form for this recurrence. 0 n n − 1
Second Order Recurrences
Let us now briefly examine how to solve some second order recur sions.
Procedure 8.80. Here is how to solve a second-order homogeneous linear recur rence relations
of the form
x = ax + bx . n n − 1 n − 2
n n − 1 1. Find the characteristic equation by “raising the subscri pts.” We obtain x = ax +
n − 2 bx .
2 2. Canceling this gives x − ax − b = 0. This equation has two roots r and r .
1 2
n n 3. If the roots are different, the solution will be of the form x = A ( r ) + B ( r ) , where
n 1 2
A , B are constants.
n n 4. If the roots are identical, the solution will be of the form x = A ( r ) + Bn ( r ) .
n 1 1
Example 8.81. Let x = 1, x = − 1, x + 5 x + 6 x = 0. 0 1 n +2 n +1 n
2 Solution: The characteristic equation is x + 5 x + 6 = ( x + 3)( x + 2) = 0. Thus
n n we test a solution of the form x = A ( − 2) + B ( − 3) . Since 1 = x = A + B ,
n 0
and − 1 = − 2 A − 3 B , we quickly find A = 2, and B = − 1. Thus the solution is
n n x = 2( − 2) − ( − 3) .
n

Solving Recurrence Relations 349
Example 8.82. Find a closed form for the Fibonacci recurrence f = 0, f = 1, f = f + 0 1 n n − 1
f . n − 2
√
5 1 ± 2 . Solution: The characteristic equation is f − f − 1 = 0. This has roots
2
Therefore, a solution will have the form
Ç å å Ç √ √ n n
1 + 5 5 1 −
f = A + B . n
2 2
The initial conditions give
0 = A + B , and
Ç å Ç å √ √ √ √
5 5 5 5 1 + 1 1 −
1 = A + B = ( A + B ) + ( A − B ) = ( A − B ) .
2 2 2 2 2
1 1
√ √ , B = − . We thus have From these two equations, we obtain A =
5 5
å å Ç Ç √ √ n n
1 1 + 1 − 1 5 5
√ √ f = − . n
2 2 5 5
⋆ Exercise 8.83. Find a closed form for the recurrence x = 1, x = 4, x = 4 x − 4 x . 0 1 n n − 1 n − 2

350 Chapter 8
8.4  Analyzing Recursive Algorithms
In Section 8.3 we already saw a few examples of analyzing recursive algorit hms. We will provide
a few more examples in this section. In case it isn’t clear, th e most common method to analyze
a recursive algorithm is to develop and solve a recurrence re lation for its running time. Let’s see
some examples.
Example 8.84. What is the worst-case running time of Mergesort?
Solution: The algorithm for Mergesort is below. Let T ( n ) be the worst-case
running time of Mergesort on an array of size n = right − lef t .  Recall that
Merge takes two sorted arrays and merges them into one sorted array in time Θ( n ),
a where n is the number of elements in both arrays. Since the two recursive calls to
Mergesort are on arrays of half the size, they each require time T ( n/ 2) in the worst-
case. The other operations take constant time. Below we anno tate the Mergesort
algorithm with these running times.
Algorithm Time required
Mergesort(int[] A,int left,int right) { T ( n )
if (left < right) { C 1
int mid = (left + right)/2; C 2
Mergesort(A, left, mid); T ( n/ 2)
Mergesort(A, mid + 1, right); T ( n/ 2)
Merge(A, left, mid, right); Θ( n ) ≤ C n 3
}
}
Given this, we can see that
T ( n )  = C + C + T ( n/ 2) + T ( n/ 2) + Θ( n ) 1 2
=  2 T ( n/ 2) + Θ( n ).
Notice that we absorbed the constants C and C into the Θ( n ) term. For simplicity, 1 2
we will also replace the Θ( n ) term with cn (where c is a constant) and rewrite this
as
T ( n ) = 2 T ( n/ 2) + cn .
We could use the Master Theorem to prove that T ( n ) = Θ( n log n ), but that would
be too easy. Instead, we will use induction to prove that T ( n ) = O ( n log n ), and
leave the Ω-bound to the reader.
By definition, T ( n ) = O ( n log n ) if and only if there exists constants k and n such 0
that T ( n ) ≤ kn log n for all n ≥ n . 0
For the base case, notice that T (2) = a for some constant a , and a ≤ k 2 log 2 = 2 k
as long as we pick k ≥ a/ 2. Now, assume that T ( n/ 2) ≤ k ( n/ 2) log( n/ 2). Then

Analyzing Recursive Algorithms 351
T ( n )  =  2 T ( n/ 2) + cn
≤ 2( k ( n/ 2) log( n/ 2) + cn
= kn log( n/ 2) + cn
= kn log n − kn log 2 + cn
= kn log n + ( c − k ) n
≤ kn log n if k ≥ c
As long as we pick k = max { a/ 2, c } , we have T ( n ) ≤ kn log n , so T ( n ) = O ( n log n )
as desired.
a Since our goal here is to analyze the algorithm, we won’t prov ide a detailed implementation of Merge . All
we need to know is its complexity.
⋆ Exercise 8.85. We stated in the previous example that we could use the Master Theorem
to prove that if T ( n ) = 2 T ( n/ 2) + cn , then T ( n ) = Θ( n log n ). Verify this.
⋆ Question 8.86. Answer the following questions about points that were made i n Exam-
ple 8.84 .
(a) Why were we allowed to absorb the constants C and C into the Θ( n ) term? 1 2
Answer
(b) Why were we able to replace the Θ( n ) term with cn ?
Answer

352 Chapter 8
Example 8.87 (Towers of Hanoi) . The following legend is attributed to French mathematician
Edouard Lucas in 1883. In an Indian temple there are 64 gold di sks resting on three pegs. At
the beginning of time, God placed these disks on the first peg a nd ordained that a group of
priests should transfer them to the third peg according to th e following rules:
1. The disks are initially stacked on peg A, in decreasing ord er (from bottom to top).
2. The disks must be moved to another peg in such a way that only one disk is moved at a
time and without stacking a larger disk onto a smaller disk.
When they finish, the Tower will crumble and the world will end . How many moves does it
take to solve the Towers of Hanoi problem with n disks?
Solution: The usual (and best) algorithm to solve the Towers of Hanoi is:
• Move the top n − 1 disk to from peg 1 to peg 2.
• Move the last disk from peg 1 to peg 3.
• Move the top n − 1 disks from peg 2 to peg 3.
The only question is how to move the top n − 1 disks. The answer is simple: use
recursion but switch the peg numbers. Here is an implementat ion of this idea:
void solveHanoi( int N, int source , int dest , int spare) {
if (N==1) {
moveDisk(source,dest);
else { }
solveHanoi(N-1,source ,spare ,dest);
moveDisk(source,dest);
solveHanoi(N-1,spare ,dest ,source);
}
}
Don’t worry if you don’t see why this algorithm works. Our mai n concern here is
analyzing the algorithm.
The exact details of moveDisk depend on how the pegs/disks are implemented, so we
won’t provide an implementation of it. But it doesn’t actual ly matter anyway since
we just need to count the number of times moveDisk is called. As it turns out, any
reasonable implementation of moveDisk will take constant time, so the complexity
of the algorithm is essentially the same as the number of call s to moveDisk .
Let H ( n ) be the number of moves it takes to solve the Towers of Hanoi problem
with n disks. Then H ( n ) is the number of times moveDisk is called when running
solveHanoi(n,1,2,3) . It should be clear that H (1) = 1 since the algorithm simply
makes a single call to moveDisk and quits. When n > 1, the algorithm makes two
calls to solveHanoi with the first parameter being n − 1 and one call to moveDisk .
Therefore, we can see that
H ( n ) = 2 H ( n − 1) + 1.
As with the first example, we want a closed form for H ( n ). But we already showed
n 8.55 and 8.61 . that H ( n ) = 2 − 1 in Examples

Analyzing Recursive Algorithms 353
⋆ Exercise 8.88. Let T ( n ) be the complexity of blarg(n) . Give a recurrence relation for
T ( n ).
int blarg( int n) {
if (n>5) {
return blarg(n-1)+blarg(n-1)+blarg(n-5)+blarg(sqrt(n));
}
else {
return n;
}
}
Answer
⋆ Exercise 8.89. Give a recurrence relation for the running time of stoogeSort(A,0,n-1) .
(Hint: Start by letting T ( n ) be the running time of stoogeSort on an array of size n .)
void stoogeSort( int [] A, int L, int R){
if (R<=L) return ; // Array  has at most  one element
if (A[R]1){ // If the list has at least 2  elements
int third=(R-L+1)/3;
// Sort first two -thirds stoogeSort(A,L,R-third);
stoogeSort(A,L+third ,R); // Sort last two -thirds
stoogeSort(A,L,R-third); // Sort first two -thirds  again
}
}
Answer
⋆ Exercise 8.90. Solve the recurrence relation you developed for StoogeSort in the previous
exercise. (Make sure you verify your solution to the previou s problem before you attempt to
solve your recurrence relation).

354 Chapter 8
⋆ Question 8.91. Which sorting algorithm is faster, Mergesort or StoogeSort ? Justify your
answer.
Answer
⋆ Exercise 8.92. Give and solve a recurrence relation for the running time of a n algorithm
that does as follows: The algorithm is given an input array of size n . If n < 3, the algorithm
does nothing. If n ≥ 3, create 5 separate arrays, each one-third of the size of the original array.
This takes Θ( n ) to accomplish. Then call the same algorithm on each of the 5 a rrays.
8.4.1  Analyzing Quicksort
In this section we give a proof that the average case running t ime of randomized quicksort is
Θ( n log n ). This proof gets its own section because the analysis is fai rly involved. This proof is based
on the one presented in Section 8.4 of the classic Introduction to Algorithms by Cormen, Leiserson,
and Rivest. The algorithm they give is slightly different, and they include some interesting insights,
so read their proof/discussion if you get a chance.
There are several slight variations of the quicksort algori thm, and although the exact running
times are different for each, the asymptotic running times are all the same. Below is the version of
Quicksort we will analyze.

Analyzing Recursive Algorithms 355
Example 8.93. Here is one implementation of Quicksort :
int A[], int l, int r){ int Partition( int A[], int l, int r){ Quicksort(
if (r > l) { int piv=l+(rand()%(r-l+1));
int p = Partition(A,l,r); swap(A,l,piv);
Quicksort(A,l,p-1); int i = l+1;
int j = r; Quicksort(A,p+1,r);
while (1) { }
while (A[i]  <= A[l] && i= A[l] && j>l)
j--;
if (i  >= j) {
swap(A,j,l);
return j;
}
else swap(A,i,j);
}
}
We will base our analysis on this version of Quicksort . It is straightforward to see that the
runtime of Partition is Θ( n ) (Problem 8.14 asks you to prove this). We start by developing a
recurrence relation for the average case runtime of Quicksort .
Theorem 8.94. Let T ( n ) be the average case runtime of Quicksort on an array of size n .
Then
n − 1 ∑
2
T ( k ) + Θ( n ). T ( n ) =
n
k =1
Proof: Since the pivot element is chosen randomly, it is equally lik ely that the pivot will end
up at any position from l to r . That is, the probability that the pivot ends up at location l + i
is 1 /n for each i = 0, . . . , r − l . If we average over all of the possible pivot locations, we obt ain
(the last step holds since T (0) = 0 )
( )
n − 1 ∑
1
( T ( k ) + T ( n − k − 1)) + Θ( n ) T ( n )  =
n
k =0
n − 1 n − 1 ∑ ∑
1 1
T ( k ) + T ( n − k − 1) + Θ( n ) =
n n
k =0 k =0
n − 1 n − 1 ∑ ∑
1 1
T ( k ) + T ( k ) + Θ( n ) =
n n
k =0 k =0
n − 1 ∑
2
= T ( k ) + Θ( n )
n
k =0
n − 1 ∑
2
= T ( k ) + Θ( n ).
n
k =1
We will need the following result in order to solve the recurr ence relation.

356 Chapter 8
Lemma 8.95. For any n ≥ 3 ,
n − 1 ∑
1 1 2 2
n log n − n . k log k ≤
2 8
k =2
Proof: We can write the sum as
⌈ n/ 2 ⌉− 1 n − 1 n − 1 ∑ ∑ ∑
k log k = k log k k log k +
k =2 k =2 k = ⌈ n/ 2 ⌉
Then we can bound ( k log k ) by ( k log( n/ 2)) = k (log n − 1) in the first sum, and by
( k log n ) in the second sum. This gives
⌈ n/ 2 ⌉− 1 n − 1 n − 1 ∑ ∑ ∑
k log k k log k = k log k +
k =2 k =2 k = ⌈ n/ 2 ⌉
⌈ n/ 2 ⌉− 1 n − 1 ∑ ∑
k log n ≤ k (log n − 1) +
k =2 k = ⌈ n/ 2 ⌉
⌈ n/ 2 ⌉− 1 n − 1 ∑ ∑
k =  (log n − 1) k + log n
k =2 k = ⌈ n/ 2 ⌉
⌈ n/ 2 ⌉− 1 ⌈ n/ 2 ⌉− 1 n − 1 ∑ ∑ ∑
=  log n k k − k + log n
k =2 k =2 k = ⌈ n/ 2 ⌉
⌈ n/ 2 ⌉− 1 n − 1 ∑ ∑
k − k =  log n
k =2 k =2
⌈ n/ 2 ⌉− 1 n − 1 ∑ ∑
≤ log n k − k
k =1 k =1
1 n n 1
( n − 1) n − ( − 1) ≤ (log n )
2 2 2 2
n 1 n 1 2 2
n log n − log n − n + =
2 2 8 4
1 1 2 2
≤ n log n − n .
2 8
The last step holds since
n n
≤ log n ,
4 2
when n ≥ 3 . 

Analyzing Recursive Algorithms 357
Now we are ready for the final analysis.
Theorem 8.96. Let T ( n ) be the average case runtime of Quicksort on an array of size n .
Then
T ( n ) = Θ( n log n ).
Proof: We need to show that T ( n ) = O ( n log n ) and T ( n ) = Ω( n log n ) . To prove
that T ( n ) = O ( n log n ) , we will show that for some constant a ,
a T ( n ) ≤ an log n for all n ≥ 2.
When n = 2 ,
an log n = a 2 log 2 = 2 a ,
and a can be chosen large enough so that T (2) ≤ 2 a . Thus, the inequality holds
for the base case. Let T (1) = C , for some constant C . For 2 < k < n , assume
T ( k ) ≤ ak log k . Then
n − 1 ∑
2
T ( n )  = T ( k ) + Θ( n )
n
k =1
n − 1 ∑
2 2
T (1) + Θ( n ) ( by assumption ) ak log k + ≤
n n
k =2
n − 1 ∑
2 a 2
C + Θ( n ) = k log k +
n n
k =2
n − 1 ∑
2 a 2
≤ 1) ≤ k log k + C + Θ( n ) ( since n
n
k =2
Å ã
2 a 1 1 2 2
≤ n log n − n + C + Θ( n )  ( by Lemma 2 )
n 2 8
a
n + C + Θ( n ) = an log n −
4
) ( a
n = an log n + Θ( n ) + C −
4
a ≤ an log n ( choose a so Θ( n ) + C ≤ n )
4
We have shown that with an appropriate choice of a , T ( n ) ≤ an log n for all n ≥ 2 ,
so T ( n ) = O ( n log n ) .
We leave it to the reader to show that T ( n ) = Ω( n log n ) . 
a We pick 2 for the base case since n log n =0 if n = 1, so we cannot make the inequality hold. Another solution
would be to show that T ( n ) ≤ an log n + b . In this case, b can be chosen so that the inequality holds for n = 1.

358 Chapter 8
8.5  Reading Comprehension Questions
From Section 8.1
Question 8.1. Why is the base case required in an induction proof? ⋆
⋆ Question 8.2. The inductive step involves proving that if P ( k ) is true, then P ( k + 1) is true.
So it almost seems like you are using a statement to prove the s ame statement–in other words,
circular reasoning. Explain why it is not circular reasonin g.
⋆ Question 8.3. Recall that [ P ( a ) ∧∀ k ( P ( k ) → P ( k + 1))] → ( ∀ nP ( n )) is a tautology, where the
universe is { a , a + 1, a + 2, . . . } .
(a) Explain in English what this tautology is saying.
(b) Use modus ponens to explain what this has to do with induction.
⋆ Question 8.4. If I show that P (0) is true and that for all k > 0, P ( k ) → P ( k + 1), then can I
conclude that P ( k ) is true for all k ≥ 0? Explain.
⋆ Question 8.5. Use induction to prove that if k ≥ 1, then the number of binary strings of length
k k is 2 .
⋆ Question 8.6. Student A proves that P ( n ) is true for all n ≥ 1 by proving that P (1) is true
and that if P ( k ) is true, then P ( k +1) is true whenever k ≥ 1. Student B proves it by proving that
P (1) is true and that if k > 1, P ( k − 1) → P ( k ) is true. Which one has a correct proof technique?
⋆ Question 8.7. What is the difference between weak and strong induction?
⋆ Question 8.8. Come up with an analogy that helps to explain why proof by indu ction makes
sense. (A common one uses dominoes.)
8.2 From Section
⋆ Question 8.9. If you go to the PDF of this book and look at Definition 8.31 , you will notice
that the word recursive contains a hyperlink. What does it link to and why does it make sense?
⋆ Question 8.10. What two or three things (depending on how you count and/or de scribe it) are
required for a recursive algorithm to be correct? Explain wh y each requirement is necessary.
⋆ Question 8.11. Why are mathematical induction and recursion covered in the same chapter?
⋆ Question 8.12. Write a recursive algorithm that searches for a given value i n an array of integers
and returns the index of the location of the number in the arra y, or − 1 if the number is not present
in the array. (Note: There are a few reasonable ways this migh t be accomplished, and since the
argument list to the function might be different based on the ex act algorithm, you have to come
up with the function definition yourself. Likely your algori thm will need either 2 or 3 arguments.)
⋆ Question 8.13. Which type of algorithm is better, recursive or iterative? E xplain.
8.3 From Section
⋆ Question 8.14. In your own words, what is a recurrence relation?
⋆ Question 8.15. What does it mean to solve a recurrence relation?

Reading Comprehension Questions 359
⋆ Question 8.16. In a sentence or two, describe how each of the following techn iques is used to
solve a recurrence relation
(a) Substitution method
(b) Iteration method
(c) Master Theorem
⋆ Question 8.17. (a) Give one advantage of the substitution and iteration met hods over the
Master Theorem.
(b) Give one advantage of the Master Theorem over the substit ution and iteration methods.
(c) List one or two downsides of the substitution method.
(d) List one or two downsides of the iteration method.
(e) At least two downsides of the Master Method.
(f) Which of these three techniques would you rather use? Why ?
⋆ Question 8.18. Why is the topic of solving recurrence relations in the same c hapter as mathe-
matical induction and recursion?
8.4 From Section
⋆ Question 8.19. Why is the section on analyzing recursive algorithms in this chapter?
⋆ Question 8.20. Based on the examples in this section, outline a procedure to analyze a recursive
algorithm. Be as specific as possible.
⋆ Question 8.21. Analyze your algorithm from Question 8.12 by developing and solving a recur-
rence relation for it. Does this analysis provide a best or wo rst case complexity?

360 Chapter 8
8.6  Problems
n 2 2 ∑
n ( n + 1) 3
Problem 8.1. Use induction to prove that k = for all n ≥ 1.
4
k =1
Problem 8.2. Use induction to prove that for all n ≥ 2,
n ∑
1 1 1 1 n − 1 1
= + + + ··· + = .
( k − 1) k 1 · 2 2 · 3 3 · 4 ( n − 1) · n n
k =2
2 2 2 + ··· + f = f f , where f is the + f Problem 8.3. Prove that for all positive integers n , f
n n +1 n n 2 1
n th Fibonacci number.
Problem 8.4. Prove the following generalized De Morgan’s Law for sets (wh ere n ≥ 2):
( A ∪ A ∪···∪ A ) = A ∩ A ∩···∩ A . 1 2 n 1 2 n
(Note: There is a second law just like it that swaps the ∩ s and ∪ s.)
n Problem 8.5. Prove that if n ≥ 4, n ! > 2 .
k +1 Problem 8.6. Prove that the number of binary palindromes of length 2 k + 1 (odd length) is 2
for all k ≥ 0.
n Problem 8.7. Prove that a set of size n ≥ 1 has 2 subsets.
Problem 8.8. Prove that the FibR(n) algorithm from Example 8.41 correctly computes f . (Hint: n
Use induction. How many base cases do you need? Do you need wea k or strong induction?)
Problem 8.9. In Example 8.82 we gave a solution to the recurrence f = f + f , f = 0, n n − 1 n − 2 0
f = 1. Use the substitution method to re-prove this. (Hint: Rec all that the roots to the polynomial 1 √
5 1 ± 2 2 . This is equivalent to x = x +1. You will find this helpful in the inductive x − x − 1 = 0 are
2
step of the proof.
Problem 8.10. Explain why the following joke never ends: Pete and Repete got in a boat. Pete
fell off. Who’s left? .
Problem 8.11. Find and prove a solution for each of the following recurrenc e relations using two
different techniques (this will not only help you verify that y our solutions are correct, but it will
also give you more practice using each of the techniques). At least one of the techniques must yield
an exact formula if possible.
2 (a) T ( n ) = T ( n/ 2) + n , T (1) = 1. (You may assume n is a power of 2.)
(b) T ( n ) = T ( n/ 2) + n , T (1) = 1. (You may assume n is a power of 2.)
2 (c) T ( n ) = 2 T ( n/ 2) + n , T (1) = 1. (You may assume n is a power of 2.)
(d) T ( n ) = T ( n − 1) · T ( n − 2), T (0) = 1, T (1) = 2.
2 (e) T ( n ) = T ( n − 1) + n , T (1) = 1.
(f) T ( n ) = T ( n − 1) + 2 n , T (1) = 2.

Problems 361
Problem 8.12. Give an exact solution for each of the following recurrence r elations.
(a) a = 3 a , a = 5. n n − 1 1
(b) a = 3 a + 2 n , a = 5. n n − 1 1
(c) a = a + 2 a , a = 2, a = 5. n n − 1 n − 2 0 1
(d) a = 6 a + 9 a , a = 1, a = 2. n n − 1 n − 2 0 1
(e) a = − a + 6 a , a = 4, a = 5. n n − 1 n − 2 0 1
Problem 8.13. Use the Master Theorem to find a tight bound for each of the foll owing recurrence
relations.
3 2 + 6 n + 5 n + 4. (a) T ( n ) = 8 T ( n/ 2) + 7 n
2 (b) T ( n ) = 3 T ( n/ 5) + n − 4 n + 23.
(c) T ( n ) = 3 T ( n/ 2) + 3.
(d) T ( n ) = T ( n/ 3) + n .
(e) T ( n ) = 2 T (2 n/ 5) + n .
(f) T ( n ) = 5 T (2 n/ 5) + n .
8.93 has complexity Θ( n ). Problem 8.14. Prove that the Partition algorithm from Example
7.132 ). Problem 8.15. Consider the classic bubble sort algorithm (see Example
(a) Write a recursive version of the bubble sort algorithm. ( Hint: The algorithm I have in mind
should contain one recursive call and one loop.)
(b) Let B ( n ) be the complexity of your recursive version of bubble sort. Give a recurrence relation
for B ( n ).
(c) Solve the recurrence relation for B ( n ) that you developed in part (b).
(d) Is your recursive implementation better, worse, or the s ame as the iterative one given in Ex-
7.132 ? Justify your answer. ample
Problem 8.16. Consider the following algorithm (remember that integer di vision truncates):
int halfIt( int n) {
if (n>0) {
return 1 + halfIt(n/2);
else { }
return 0;
}
}
(a) What does halfIt(n) return? Your answer should be a function of n .
(b) Prove that the algorithm is correct. That is, prove that i t returns the answer you gave in part
(a).

362 Chapter 8
(c) What is the complexity of halfIt(n) ? Give and prove an exact formula. (Hint: This will
probably involve developing and solving a recurrence relat ion.)
Problem 8.17. This problem involves an algorithm to compute the sum of the fi rst n squares ( )
n ∑
2 i.e. using recursion. k
k =1
n ∑
2 k that uses recursion and only uses the increment/decre- (a) Write an algorithm to compute
k =1
ment operator for arithmetic (e.g., you cannot use addition or multiplication).  (Hint: The
algorithm I have in mind has one recursive call and one or two l oops. Also, you will probably
need a global variable or to assume you can pass a variable by r eference.)
(b) Let S ( n ) be the complexity of your algorithm from part (a). Give a rec urrence relation for
S ( n ).
(c) Solve the recurrence relation for S ( n ) that you developed in part (b).
(d) Give a recursive linear-time algorithm to solve this sam e problem (with no restrictions on what
operations you may use). Prove that the algorithm is linear.
(e) Give a constant-time algorithm to solve this same proble m (with no restrictions on what you
may use). Prove that the algorithm is constant.
(f) Discuss the relative merits of the three algorithms. Whi ch algorithm is best? Worst? Justify.
Problem 8.18. Assuming the priests can move one disk per second, that they s tarted moving
disks 6000 years ago, and that the legend of the Towers of Hano i is true, when will the world end?
8.89 correctly sorts an Problem 8.19. Prove that the stoogeSort algorithm given in Exercise
array of n integers.

Chapter 9: Counting
In this chapter we provide a very brief introduction to a field called combinatorics . We are actually
only going to scratch the surface of this very broad and deep s ubfield of mathematics and theoretical
computer science. We will focus on a subfield of combinatoric s that is sometimes called enumeration .
That is, we will mostly concern ourselves with how to count th ings.
It turns out that combinatorial problems are notoriously de ceptive. Sometimes they can seem
much harder than they are, and at other times they seem easier than they are. In fact, there are
many cases in which one combinatorial problem will be relati vely easy to solve, but a very closely
related problem that seems almost identical will be very diffi cult to solve.
When solving combinatorial problems, you need to make sure y ou fully understand what is
being asked and make sure you are taking everything into acco unt appropriately. I used to tell
students that combinatorics was easy. I don’t say that anymo re. In some sense it is easy. But it is
also easy to make mistakes.
9.1  The Sum and Product Rules
We begin our study of combinatorial methods with the followi ng two fundamental principles. They
are both pretty intuitive. The only difficulty is realizing wh ich one applies to a given situation. If
you have a good understanding of what you are counting, the ch oice is generally pretty clear.
Theorem 9.1 (Sum Rule) . Let E , E , . . . , E , be pairwise finite disjoint sets. Then 1 2 k
| E ∪ E ∪···∪ E | = | E | + | E | + ··· + | E | . 1 2 1 2 k k
Another way of putting the sum rule is this: If you have to accom plish some task and you
can do it in one of n ways, or one of n ways, etc., up to one of n ways, and none of the 1 2 k
ways of doing the task on any of the list are the same, then ther e are n + n + ··· + n ways 1 2 k
of doing the task.
Example 9.2. I have 5 brown shirts, 4 green shirts, 10 red shirts, and 3 blue shirts. How
many choices do I have if I intend to wear one shirt?
Solution: Since each list of shirts is independent of the others, I can u se the sum
rule. Therefore I can choose any of my 5 + 4 + 10 + 3 = 22 shirts.
Example 9.3. How many ordered pairs of integers ( x , y ) are there such that 0 < | xy |≤ 5?
2 Solution: Let E = { ( x , y ) ∈ Z : | xy | = k } for k = 1, . . . , 5. Then the desired
k
number is
| E | + | E | + ··· + | E | . 1 2 5
363

364 Chapter 9
We can compute each of these as follows:
E = { ( − 1, − 1), ( − 1, 1), (1, − 1), (1, 1) } 1
E = { ( − 2, − 1), ( − 2, 1), ( − 1, − 2), ( − 1, 2), (1, − 2), (1, 2), (2, − 1), (2, 1) } 2
E = { ( − 3, − 1), ( − 3, 1), ( − 1, − 3), ( − 1, 3), (1, − 3), (1, 3), (3, − 1), (3, 1) } 3
E = { ( − 4, − 1), ( − 4, 1), ( − 2, − 2), ( − 2, 2), ( − 1, − 4), ( − 1, 4), (1, − 4), 4
(1, 4), (2, − 2), (2, 2), (4, − 1), (4, 1) }
E = { ( − 5, − 1), ( − 5, 1), ( − 1, − 5), ( − 1, 5), (1, − 5), (1, 5), (5, − 1), (5, 1) } 5
The desired number is therefore 4 + 8 + 8 + 12 + 8 = 40.
⋆ Exercise 9.4. For dessert you can have cake, ice cream or fruit. There are 3 k inds of cake,
8 kinds of ice cream and 5 different of fruits. How many choices d o you have for dessert?
Answer
Theorem 9.5 (Product Rule) . Let E , E , . . . , E , be finite sets. Then 1 2 k
| E × E ×···× E | = | E |·| E |···| E | . 1 2 1 2 k k
Another way of putting the product rule is this: If you need to a ccomplish some task that
takes k steps, and there are n ways of accomplishing the first step, n ways of accomplishing 1 2
the second step, etc., and n ways of accomplishing the k th step, then there are n n ··· n ways 1 2 k k
of accomplishing the task.
Example 9.6. I have 5 pairs of socks, 10 pairs of shorts, and 8 t-shirts. How many choices do
I have if I intend to wear one of each?
Solution: I can think of choosing what to wear as a task broken into 3 step s:
I have to choose a pair of socks (5 ways), a pair of shorts (10 wa ys), and finally a
t-shirt (8 ways). Thus I have 5 × 10 × 8 = 400 choices.
⋆ Exercise 9.7. If license plates are required to have 3 letters followed by 3 digits, how many
license plates are possible?
Answer
Example 9.8. The positive divisors of 400 are written in increasing order
1, 2, 4, 5, 8, . . . , 200, 400.
How many integers are there in this sequence? How many of the d ivisors of 400 are perfect
squares?
4 2 a b Solution: Since 400 = 2 · 5 , any positive divisor of 400 has the form 2 5 where
0 ≤ a ≤ 4 and 0 ≤ b ≤ 2. Thus there are 5 choices for a and 3 choices for b for a

The Sum and Product Rules 365
total of 5 · 3 = 15 positive divisors.
α β To be a perfect square, a positive divisor of 400 must be of the form 2 5 with
α ∈{ 0, 2, 4 } and β ∈{ 0, 2 } . Thus there are 3 · 2 = 6 divisors of 400 which are also
perfect squares.
It is easy to generalize Example 9.8 to obtain the following theorem.
Theorem 9.9. Let the positive integer n have the prime factorization
a a a 1 2 k
n = p p , ··· p 1 2 k
where the p are distinct primes, and the a are integers ≥ 1 . If d ( n ) denotes the number of i i
positive divisors of n , then
d ( n ) = ( a + 1)( a + 1) ··· ( a + 1). 1 2 k
⋆ Exercise 9.10. Prove Theorem 9.9 . (Hint: Follow the idea from Example 9.8 .)
⋆ Question 9.11. Whether or not you realize it, you used the fact that the p were distinct i
9.9 (assuming you did the proof correctly). Explain where primes in your proof of Theorem
that fact was used (perhaps implicitly).
Answer

366 Chapter 9
Example 9.12. What is the value of sum after each of the following segments of code?
int sum=0; int sum=0;
for(int i=0;i 0,
k =0
appropriate set and count the cardinality of the set in two wa ys to obtain the identity.)
(b) When you fill out a bracket you are picking who you think the winner will be of each game.
How many different ways are there to fill out a bracket? (Hint: If you think about this in the
proper way, this is pretty easy.)
(c) If everyone on the planet (7,000,000,000) filled out a bra cket, is it guaranteed that two people
will have the same bracket? Explain.
(d) Assume that everyone on the planet fills out k different brackets and that no brackets are
repeated (either by an individual or by anybody else). How la rge would k have to be before it
is guaranteed that somebody has a bracket that correctly pre dicts the winner of every game?
(e) Assume every pair of people on the planet gets together to fill out a bracket (so everyone has
6,999,999 brackets, one with every other person on the plane t).  What is the smallest and
largest number of possible repeated brackets?
Problem 9.29. Mega Millions has 56 white balls, numbered 1 through 56, and 4 6 red balls,
numbered 1 through 46. To play you pick 5 numbers between 1 and 56 (corresponding to white
balls) and 1 number between 1 and 46 (corresponding to a red ba ll). Then 5 of the 56 balls and 1
of the 46 balls are drawn randomly (or so they would have us bel ieve). You win if your numbers
match all 6 balls.
(a) How many different draws are possible?
(b) If everyone in the U.S.A. bought a ticket (about 314,000, 000), is it guaranteed that two people
have the same numbers? Three people?
(c) If everyone in the U.S.A. bought a ticket, what is the maxi mum number of people that are
guaranteed to share the jackpot?
(d) Which is more likely: Winning Mega Millions or picking ev ery winner in the NCAA Basketball
Tournament (see previous question)? How many more times lik ely is one than the other?
(e) I purchased a ticket last week and was surprised when none of my six numbers matched. Should
I have been surprised? What are the chances that a randomly se lected ticket will match none
of the numbers?
(f) (hard) What is the largest value of k such that you are more likely to pick at least k winners
in the NCAA Basketball Tournament than you are to win Mega Mil lions?

402 Chapter 9
Problem 9.30. You get a new job and your boss gives you 2 choices for your sala ry. You can
$ 100 per day or you can start at $ .01 on the first day and have your salary doubled either make
every day. You know that you will work for k days. For what values of k should you take the first
offer and for which should you take the second offer? Explain.
Problem 9.31. The 300-level courses in the CS department are split into thr ee groups: Founda-
tions (361, 385), Applications (321, 342, 392), and Systems (335, 354, 376). In order to get a BS
in computer science at Hope you need to take at least one cours e from each group.
(a) How many different ways are there of satisfying this requir ement by taking exactly 3 courses?
(b) If you take four 300-level courses, how many different poss ibilities do you have that satisfy the
requirements?
(c) How many total ways are there to take 300-level courses th at satisfy the requirements?
(d) What is the smallest k such that no matter which k 300-level courses you choose, it is guaranteed
that you will satisfy the requirement?
Problem 9.32. I am implementing a data structure that consists of k lists. I want to store a total
of n objects in this data structure, with each item being stored o n one of the lists. All of the lists
will have the same capacity (e.g. perhaps each list can hold u p to 10 elements).
Write a method minimumCapacity(int n, int k) that computes the minimum capacity each of the
k lists must have to accommodate n objects. In other words, if the capacity is less than this, th en
there is no way the objects can all be stored on the lists.  You m ay assume integer arithmetic
truncates (essentially giving you the floor function), but that there is no ceiling function available.
Problem 9.33. Write a method choose(int n, int k) (in a Java-like language) that computes ) (
n .  Your implementation should be as efficient as possible.  Make sure to give and prove the
k
efficiency of your algorithm.

Chapter 10: Graph Theory
In this chapter we will provide a very brief and very selective introduction to graphs. Graph theory
is a very wide field and there are many thick textbooks on the su bject. The main point of this
chapter is to provide you with the basic notion of what a graph is, some of the terminology used,
a few applications, and a few interesting and/or important r esults.
10.1  Types of Graphs
Definition 10.1. A (simple) graph G = ( V , E ) consists of
• V , a nonempty set of vertices and
• E , a set of unordered pairs of distinct vertices called edges .
The order of a graph is | V | , the number of vertices.
Example 10.2. Here is an example of a graph with the set of vertices and edges listed on the
right. Vertices are usually represented by means of dots on t he plane, and the edges by means
of lines connecting these dots.
E D
V={A,B,C,D,E}
E={ (A,D),(A,E),(B,D),
        (B,E),(C,D),(C,E)} B
A C
Example 10.3. Sometimes we just care about the visual representation of a g raph. Here are
three examples.
There are several variations of graphs. We will provide defin itions and examples of the most
common ones.
Definition 10.4. A directed graph (or digraph ) G = ( V , E ) consists of
• V , a nonempty set of vertices and
• E , a set of ordered pairs of distinct vertices called directed edges (or just edges ).
The order of a digraph is | V | , the number of vertices.
403

404 Chapter 10
Example 10.5. Here are three examples of directed graphs.
As you would probably suspect, the only difference between sim ple graphs and directed graphs
is that the edges in directed graphs have a direction.  We shou ld note that simple graphs are
sometimes called undirected graphs to make it clear that the graphs are not directed.
Example 10.6. In a simple graph, { u , v } and { v , u } are just two different ways of talking
about the same edge–the edge between u and v . In a directed graph, ( u , v ) is the edge from
u to v and ( v , u ) is the edge from v to u . These are not the same, and they may or may not
both be present.
Definition 10.7. A multigraph (directed multigraph) G = ( V , E ) consists of
• V , a set of vertices,
• E , a set of edges, and
• a function f from E to {{ u , v } : u 6 = v ∈ V }
(function f from E to { ( u , v ) : u 6 = v ∈ V } .)
Two edges e and e with f ( e ) = f ( e ) are called multiple edges . 1 2 1 2
Although the definition looks a bit complicated, a multigraph G = ( V , E ) is just a graph in
which multiple edges are allowed between a pair of vertices.
Example 10.8. Here are a few examples of multigraphs.
Here are some examples of directed multigraphs.

Types of Graphs 405
Definition 10.9. A pseudograph G = ( V , E ) is a graph in which we allow loops –that is,
edges from a vertex to itself. As you might imagine, a pseudo-multigraph allows both loops
and multiple edges.
Example 10.10. Here are some pseudographs.
Here are a few directed pseudographs.
Definition 10.11. A weighted graph is a graph (or digraph) with the additional property
that each edge e has associated with it a real number w ( e ) called its weight .
A weighted digraph is often called a network .
Example 10.12. Here are two examples of weighted graphs and one weighted dir ected graph.
3 -2
2 1
12 3
7 0
0
-6 8 7
3 1 3 6 5
4 4 4
3
4 11
As we have seen, there are several ways of categorizing graph s:
• Directed or undirected edges.
• Weighted or unweighted edges.
• Allow multiple edges or not.
• Allow loops or not.
Unless specified, you can usually assume a graph does not allo w multiple edges or loops since
these aren’t that common. Generally speaking, you can assum e that if a graph is not specified as
weighted or directed, it isn’t. The most common graphs we’ll use are graphs, digraphs, weighted
graphs, and networks.

406 Chapter 10
Note: When writing graph algorithms, it is important to know what c haracteristics the graphs
have.  For instance, if a graph might have loops, the algorith m should be able to handle it.
Some algorithms do not work if a graph has loops and/or multip le edges, and some only apply
to directed (or undirected) graphs.

Graph Terminology 407
10.2  Graph Terminology
Definition 10.13. Given a graph G = ( V , E ) , we denote the number of vertices in G by | V |
and the number of edges by | E | (a notation that makes perfect sense since V and E are sets).
Definition 10.14. Let u and v be vertices and e = { u , v } be an edge in undirected graph G .
• The vertices u and v are said to be adjacent
• The vertices u and v are called the endpoints of the edge e .
• The edge e is said to be incident with u and v .
• The edge e is said to connect u and v .
• The degree of a vertex, denoted deg ( v ) , is the number of edges incident with it.
Example 10.15. Consider the following graphs.
x z x
w x
w v
u w
y z
v y
y u
v
u
G G G
1 2
3
In graph G , we can say: The following table gives the degree of each 1
of the vertices in the graphs above.
• w is adjacent to x .
G G G 1 2 3
• w and x are the endpoints of the edge
deg(u)=3 deg(u)=2 deg(u)=2
( w , x ).
deg(v)=5 deg(v)=3 deg(v)=4
deg(w)=3 deg(w)=2 deg(w)=3 • ( w , x ) is incident with both w and x .
deg(x)=2 deg(x)=4 deg(x)=2
• ( w , x ) connects vertices w and x . deg(y)=2 deg(y)=3 deg(y)=3
deg(z)=3 deg(z)=2
′ ′ ′ Definition 10.16. A subgraph of a graph G = ( V , E ) is a graph G = ( V , E ) such that
′ ′ V ⊂ V and E ⊂ E .

408 Chapter 10
Example 10.17. Consider the following three graphs:
H H H 1 3
2
Notice that H is a subgraph of H and that H is a subgraph of both H and H . 2 1 3 1 2
Definition 10.18. A u − v walk is an alternating sequence of vertices and edges in G with
starting vertex u and ending vertex v such that every edge joins the vertices immediately pre-
ceding it and immediately following it.
You can think of a walk as follows: Put your pencil down on a ver tex and trace around edges
however you like until you reach some destination vertex. Yo u are allowed to repeat edges and
vertices as often as you like–just like you may repeat sidewa lks and paths when you go for a walk
(thus the name).
Definition 10.19. A u − v trail is a u − v walk that does not repeat an edge.
Notice that a trail may repeat a vertex.
Definition 10.20. A u − v path is a walk that does not repeat any vertex.
It should be relatively easy to see that paths cannot repeat a n edge (because to repeat an edge
you have to repeat a vertex).
Example 10.21. In the first graph, the trail abecde is indicated with the dark lines. It is not
a path since it repeats the vertex e . The second and third graphs show examples of paths.
a b a b
b a
c c
c bec
d e d e
d e abecd e bedc
Although not drawn (because it is harder to represent clearl y on a drawing), acdecabecdeba
a To confirm it, you just need to verify that there is an edge betw een is an example of a walk
adjacent vertices on the list. On the other hand, abcde is not a path, trail, or walk because
( b , c ) is not an edge.
a This walk is specified by just the vertices and not both the ver tices and edges as in the definition. If multiple
edges are not allowed (i.e. we are not working with a multigra ph), then there is no need to list the edges since
they are clear.

Graph Terminology 409
Definition 10.22. A cycle (or simple cycle ) is a list of vertices v , v , . . . , v , with no repeats 1 2 k
such that ( v , v ) is an edge for i = 1, . . . , k − 1 , and ( v , v ) is an edge. i i +1 1 k
Put another way, a cycle is a path to which we append an edge fro m the last to the first
vertex.
The number of vertices in a cycle is called its length .
Example 10.23. Here is a graph with a cycle of length 3.
a b
c cdec
d e
⋆ Exercise 10.24. Find a cycle of length 4 and a cycle of length 5 in the graph from Exam-
10.23 . Is there a cycle of length 6? Explain why or why not. ple
Answer
Definition 10.25. A graph is called connected if there is a path between every pair of distinct
vertices.
A connected component of a graph is a maximal connected subgraph.
Example 10.26. Below are two graphs, each drawn inside dashed boxes. The gra ph on the
left is connected. The one on the right is not connected. It ha s two connected components.
b a a b
c c
d e d e
connected not connected
⋆ Exercise 10.27. Draw a graph that has two connected components, one that is a c ycle of
length 4 and one that is a cycle of length 3.

410 Chapter 10
Definition 10.28. A tree (or unrooted tree ) is a connected acyclic graph. That is, a graph
with no cycles.
A forest is a collection of trees.
Example 10.29. Here are four trees. If they were all part of the same graph, we could consider
the graph a forest.
tree
tree tree
tree
⋆ Exercise 10.30. Draw a tree that has 5 vertices, one vertex with degree 4 and th e others
with degree 1.
⋆ Exercise 10.31. Draw a forest with 5 trees that has 6 vertices.
Note: These trees are not to be confused with rooted trees (e.g. binary trees ). When computer
scientists use the term tree , they usually mean rooted trees, not the trees we are discuss ing here.
When you see/hear the term ‘tree,’ it is important to be clear about which one the writer/speaker
has in mind.
Definition 10.32. A spanning tree of G is a subgraph which is a tree and contains all of
the vertices of G .

Graph Terminology 411
Example 10.33. Below is a graph (on the left) and one of several possible span ning trees (on
the right).
G spanning tree of G
Here is some terminology related to directed graphs.
Definition 10.34. Let u , v be vertices in a directed graph G , and e = ( u , v ) be an edge in G .
• u is said to be adjacent to v .
• v is said to be adjacent from u .
• u is called the initial vertex of ( u , v ) .
• v is called the terminal or end vertex of ( u , v ) .
− • The in-degree of u , denoted by deg ( u ) , is the number of edges in G which have u as
their terminal vertex.
+ • The out-degree of u , denoted by deg ( u ) , is the number of edges in G which have u as
their initial vertex.

412 Chapter 10
Example 10.35. Consider the three graphs below.
y
w w x
y
x v w
v v
z
u x u u
y
G G G
6 4 5
Consider the edge ( w , x ) in G . 4
• w is adjacent to x and x is adjacent from w .
• w is the initial vertex and x is the terminal vertex of the edge ( w , x ).
This table gives the in-degree and out-degree for the vertic es in graphs G , G , and G . 4 5 6
G G G 4 5 6
− + − + − + deg (u)=2 deg (u)=4 deg (u)=1 deg (u)=0 deg (u)=1 deg (u)=1
− + − + − + deg (v)=2 deg (v)=2 deg (v)=1 deg (v)=2 deg (v)=2 deg (v)=2
− + − + − + deg (w)=1 deg (w)=1 deg (w)=1 deg (w)=1 deg (w)=2 deg (w)=2
− + − + − + deg (x)=2 deg (x)=3 deg (x)=1 deg (x)=1 deg (x)=1 deg (x)=1
− + − + − + deg (y)=3 deg (y)=0 deg (y)=2 deg (y)=2 deg (y)=2 deg (y)=2
− + deg (z)=1 deg (z)=1

Some Special Graphs 413
10.3  Some Special Graphs
Definition 10.36. The complete graph with n vertices K is the graph where every pair of n ) (
n edges. vertices is adjacent. Thus K has
n 2
Example 10.37. Here are the complete graphs with n = 2, 3, 4, 5.
K K K K
2 3 4 5
Definition 10.38. C denotes a cycle of length n . It is a graph with n edges, and n vertices n
v , . . . , v , where v is adjacent to v for n = 1, . . . , n − 1 , and v is adjacent to v . 1 n i i +1 1 n
Example 10.39. Here are the cycles of length 3, 4, and 5.
C C C
3 5 4
Definition 10.40. P denotes a path of length n . It is a graph with n edges, and n +1 vertices n
v , v , . . . , v , where v is adjacent to v for n = 0, 1, . . . , n − 1 . 0 1 n i i +1
We won’t provide an example of the paths because they are pret ty easy to visualize.  For
instance, P is simply C with one edge removed. 3 4
Definition 10.41. Q denotes the n -dimensional cube (or hypercube ). One way to define n
n Q is that it is a simple graph with 2 vertices, which we label with n -tuples of 0 ’s and 1 ’s.
n
Vertices of Q are connected by an edge if and only if they differ by exactly on e coordinate. n
n − 1 Observe that Q has n 2 edges.
n

414 Chapter 10
Example 10.42. Here are Q and Q , with vertices labeled as mentioned in the definition. 2 3
101 111
001 011 01 11
100 110
000 010 00 10
Q Q 3 2
Notice that in Q , the vertex labeled 11 is adjacent to the vertices labeled 10 and 01 since 2
each of these differ in one bit. Similarly, the vertex labeled 1 01 in Q is adjacent to the vertices 3
labeled 001, 111, and 100 for the same reason.  Next is Q , also labeled according to the 4
definition.
1111 1101
1011 1001
0101 0111
0001 0011
0100 0110
0000 0010
1100 1110
1000 1010
Q 4
It should not be too difficult to see that Q is the same as P which is the same as K . 1 1 2
Definition 10.43. A simple graph G is called bipartite if the vertex set V can be partitioned
into two disjoint nonempty sets V and V such that every edge connects a vertex in V to a 1 2 1
vertex in V . 2
Put another way, no vertices in V are connected to each other, and no vertices in V are 1 2
connected to each other.

Some Special Graphs 415
Note that there may be different ways of assigning the vertices to V and V .  That is not 1 2
important. As long as there is at least one way to do so such tha t all edges go between V and V , 1 2
then a graph is bipartite.
Example 10.44. Here are a few bipartite graphs.
Notice that although these are drawn to make it clear what the partition is (i.e. V is the 1
top row of vertices and V is the bottom row), a graph does not have to be drawn as such in 2
order to be bipartite. They are often drawn this way out of con venience. For instance, the
hypercubes are all bipartite even though they are not drawn t his way.
Definition 10.45. K denotes the complete bipartite graph with m + n vertices. That m , n
is, it is the graph with m + n vertices that is partitioned into two sets, one of size n and the
other of size m such that every possible edge between the two sets is in the gr aph.
Example 10.46. The first four graphs from Example 10.44 are complete bipartite graphs.
The first is K , the second is K (or K ), the third is K , and the fourth is K (or K ). 1,1 1,2 2,1 2,2 3,2 2,3

416 Chapter 10
10.4  Handshaking Lemma
The following theorem is valid not only for simple graphs, bu t also for multigraphs and pseudo-
graphs.
Theorem 10.47 (Handshake Lemma) . Let G = ( V , E ) be a graph. Then
∑
deg( v ) = 2 | E | .
v ∈ V
Proof: Let X = { ( e , v ) : e ∈ E , v ∈ V , and e and v are incident } . We will
compute | X | in two ways.  Each edge e ∈ E is incident with exactly 2 vertices.
Thus,
| X | = 2 | E | .
Also, each vertex v ∈ V is incident with deg( v ) edges. Thus, we have that
∑
| X | = deg ( v ).
v ∈ V
Setting these equal, we have the result. 
The proof in the previous theorem is an example of a combinato rial proof. It is a neat technique
where you prove a formula by counting the number of objects in a set in two different ways.
Example 10.48. Consider the following graphs.
x z x
w x
w v
u w
y z
v y
y u
v
u
G G G
1 2
3
A quick tabulation of the degrees of the vertices and the numb er of edges reveals the
following:
Graph G G G 1 2 3
| E | 9 7 8
∑
deg ( v ) 18 14 16
v ∈ V
These results are certainly consistent with Theorem 10.47 .
Undirected graphs have an interesting property that is real ly easy to prove using Theorem 10.47 .

Handshaking Lemma 417
Corollary 10.49. Every graph has an even number of vertices of odd degree.
Proof: The sum of an odd number of odd numbers is odd. Since the sum of th e
degrees of the vertices in a simple graph is always even, one c annot have an odd
number of odd degree vertices. 
The situation is slightly different, but not too surprising, f or directed graphs.
Theorem 10.50. Let G = ( V , E ) be a directed graph. Then
∑ ∑
− + deg ( v ) = deg ( v ) = | E | .
v ∈ V v ∈ V
We won’t provide a proof of this theorem (it’s almost obvious ), but you should verify it for the
graphs in Example 10.35 by adding up the degrees in each column and comparing the appr opriate
sums.

418 Chapter 10
10.5  Graph Representation
Much could be said about representing graphs. We provide onl y a very brief discussion of the topic.
Consult your favorite data structure book for more details.
Let G = ( V , E ) be a graph with n vertices and m edges. That is, | V | = n , and | E | = m . There
are two common ways of representing G . (There is actually a third, but it isn’t nearly as common
as the two we will discuss.)
The first method stores, for each vertex, a list of all of the ve rtices it is adjacent to.
Definition 10.51. The adjacency list representation of a graph maintains, for each vertex,
a list of all of the vertices adjacent to that vertex. This can b e implemented in many ways, but
often an array of linked lists is used.
Example 10.52. A drawing of C is given below on the left. An adjacency list representation 5
is given below on the right.
B A → E → B
B → A → C C
C → B → D A
D → C → E
D E
E → D → A
Example 10.53. A drawing of a directed cycle of length 5 is given below on the l eft. An
adjacency list representation is given next to it.
B A → B Notice that this is a lot like the previ-
ous example except that each list only B → C C
has one element on it. That is because
C → D A
( A , B ) is an edge (for instance), but
D → E ( B , A ) is not an edge. So B is on A ’s
D E
list, but A is not on B ’s list. E → A
Example 10.54. Here is another example of a graph on the left with the adjacen cy list
representation on the right.
A B A → B → E → D
B → A → E → C
C → B → D → E E
D → C → A → E
E → A → B → C → D D C
Note that the order the vertices are listed does not matter.

Graph Representation 419
⋆ Exercise 10.55. Give the adjacency list representation for K as drawn below. 3,3
→ A
→ B
A B C
→ C
→ D
→ E
D E F
→ F
⋆ Exercise 10.56. Give the adjacency list representation for the directed gra ph similar to
K drawn below. 3,3
→ A
→ B
A B C
→ C
→ D
→ E
D E F
→ F
The graph in Example 10.54 has 5 vertices and 8 edges (so n = 5 and m = 8). The adjacency list
uses an array of size 5 and there are 5 linked lists that contai n a total of 3+3+3+3+4 = 16 = 2 ∗ 8
nodes. Notice that this is twice the number of edges because e ach edge is stored twice (because if
( u , v ) is an edge, u is stored on v ’s list and v is stored on u ’s list). For each node we need to store
the value and the next node, so the linked lists take up about 2(2 ∗ 8) = 4 ∗ 8 = 4 m memory. Since
the array takes about 5 = n memory, the memory requirement for an adjacency list repres entation
of the graph is approximately n + 4 m = Θ( n + m ).
Notice that the discussion in the previous paragraph genera lizes to all graphs. That is, the space
requirement for the adjacency list representation of a grap h is approximately n + 4 m = Θ( n + m ).
Hopefully it is not too difficult to see that for directed graph s, the amount of memory required
is about n + 2 m = Θ( n + m ) because each edge is only stored once.
For weighted graphs, an additional field can be stored in each node for the weight of each edge.
So for undirected weighted graphs, the memory requirement g oes up to about n + 6 m , and for
directed weighted graphs it is about n + 3 m . In both cases, it is still Θ( n + m ).
The second method of storing a graph makes it so you can ask dir ectly “Is ( u , v ) and edge?”
This is accomplished by storing a matrix whose rows and colum ns are indexed by the vertices.

420 Chapter 10
Definition 10.57. The adjacency matrix M of a graph G is the n by n matrix M defined
as ß
1 if ( i , j ) is an edge
M ( i , j ) =
0 if ( i , j ) is not an edge
We often assume that the vertices are numbered 0, 1, . . . , n − 1 since that is how we typically index
matrices. In the next few examples we will continue with our e xamples with vertices labeled A , B ,
etc. To make the interpretation of the matrices clear, we lab el the rows and columns. You can also
just think of a mapping of A to 0, B to 1, etc.
Example 10.58. A drawing of C is given below on the left, the adjacency list in the middle, 5
and the adjacency matrix on the right.
A   B   C   D   E
B A → E → B  
A 0   1   0   0   1
B → A → C C  
B 1   0   1   0   0  
  C → B → D A C 0   1   0   1   0
 
  D 0   0   1   0   1
D → C → E
D E E 1   0   0   1   0
E → D → A
Example 10.59. A drawing of a directed cycle of length 5 is given below on the l eft. An
adjacency list representation is given in the middle and the adjacency matrix on the right.
A   B   C   D   E
B A → B  
A 0   1   0   0   0
B → C C  
B 0   0   1   0   0  
  C → D A C 0   0   0   1   0
 
  D 0   0   0   0   1
D → E
D E E 1   0   0   0   0
E → A
Example 10.60. Here is another example of a graph on the left, the adjacency l ist represen-
tation on the center, and the adjacency matrix on the right.
A   B   C   D   E A B
A → B → E → D  
A 0   1   0   1   1
B → A → E → C  
B 1   0   1   0   1  
  C → B → D → E E C 0   1   0   1   1
 
  D 1   0   1   0   1
D → C → A → E
E 1   1   1   1   1
E → A → B → C → D D C
From these examples, it should be relatively clear that the a mount of space needed to store an
2 2 adjacency matrix with n vertices and m edges is about n = Θ( n ). Notice that it does not depend
on m , since a larger m just means more 1s and fewer 0s in the matrix.
If G is weighted, we can store the weights in the matrix instead of just 0 or 1. For non-adjacent
INT (or − 1 if only positive weights are valid). If done this way, the vertices, we store ∞ , or MAX

Graph Representation 421
2 2 space requirement remains n = Θ( n ). Alternatively, a second matrix can be used to store the
2 weights, doubling the space requirement, which is still Θ( n ).
Notice the amont of space required to store both directed and undirected graphs is the same
with the adjacency matrix.
⋆ Exercise 10.61. Give the adjacency matrix representation for K as drawn below. 3,3
A B C
D E F
⋆ Exercise 10.62. Give the adjacency matrix representation for the directed g raph similar
to K drawn below. 3,3
A B C
D E F
Obviously, how much space is required to store a graph is of im portance, but so is how much
time is required to do basic operations on a graph. For instan ce, the most common things one
might want to do on a graph are determine whether or not two ver tices are adjacent and iterate
over the edges that are incident with a vertex (put another wa y, iterate over all of the neighbors of
a vertex). For a weighted graph, one would probably ask the we ight of an edge somewhat often.
There are certainly other important operations one might wa nt to perform on a graph. Since you
have all of the tools you need to answer such questions, we wil l ask you to explore them at the end
of the chapter.
So which representation is better?  We will also let you think about that at the end of the
chapter, but hopefully it is somewhat clear that answering t hat question requires you to consider
both time and space requirements.

422 Chapter 10
10.6  Problem Solving with Graphs
There are many problems on graphs that are of interest for var ious reasons. The following very
short list contains some of the more common ones.
• Path : Is there a path from A to B?
• Cycles : Does the graph contain a cycle?
• Connectivity : Is there a way to get between any two vertices in the graph?
• Biconnectivity : Will the graph become disconnected if one vertex is removed ?
• Planarity : Is there a way to draw the graph without edges crossing?
• Shortest Path : What is the shortest path from A to B? (weighted and unweight ed versions)
• Longest Path : What is the longest path from A to B? (weighted and unweighte d versions)
• Minimum Spanning Tree : What is the “most efficient” way to connect the vertices (weig hted
graphs)?
• Traversability : Is is possible to travel to every vertex without repeating a vertex? Is it
possible to travel over every edge without repeating an edge ?
• Traveling Salesman : What is the shortest route that visits every vertex and retu rns to
the starting vertex? (weighted graphs)
Knowing what graph problems have been studied and what is kno wn about each is very im-
portant. Many problems can be modeled using graphs, and once a problem has been mapped to a
particular graph problem, it can be helpful to know the best w ay to solve it.
We finish the chapter by giving several examples of problems w hose solutions become simpler
when using a graph-theoretic model as well as develop some ne w graph terminology. It is important
to mention that whole books are written just about graph theo ry, and even they have to pick a
small subset of the topic. Thus, what is presented in the rema inder of this chapter should not be
interpreted in any way to be the most important topics in grap h theory. It is just a very small
selection of easy to understand topics that are related to in teresting problems. Dozens–maybe even
hundreds–of other topics could have been chosen. It should b e noted that the author has even
resisted the urge to include one of his favorite graph topics , graph pebbling , even though it is a
somewhat interesting topic. Well, to him anyway.

Problem Solving with Graphs 423
Example 10.63. A wolf, a goat, and a cabbage are on one bank of a river. The ferr yman
wants to take them across, but his boat is too small to accommo date more than one of them
at a time. He cannot leave the wolf and the goat together (the w olf will eat the goat), or the
cabbage and the goat (the goat will eat the cabbage) unless he is with them. Can the ferryman
still get all of them across the river?
Solution: Represent the position of a single item by 0 for one bank of the river
and 1 for the other bank. The position of the three items can no w be given as an
ordered triplet, say ( W , G , C ). For example, (0, 0, 0) means that the three items
are on one bank of the river, (1, 0, 0) means that the wolf is on o ne bank of the river
while the goat and the cabbage are on the other bank. The objec t of the puzzle
is now seen to be to move from (0, 0, 0) to (1, 1, 1) by traversing certain edges of
Q while avoiding other edges. Note that Q is the correct set of edges to consider 3 3
since he can only move one of the three items at a time.
But there are some edges he cannot use. For instance, 000 → 100 is illegal since
it would mean he takes the wolf to the other side, leaving the g oat and cabbage
together. Similarly, 000 → 001 is illegal. Thus, from 000, the only choice is to go
to 010. Continuing this analysis, it can be determined that t he set of legal edges is
as in the following graph:
011 001
000 010 101 111
110  100
Based on this, one answer is 000 → 010 → 011 → 001 → 101 → 111. This means
that the ferryman (i) takes the goat across, (ii) returns and takes the cabbage over,
(iii) brings back the goat, (iv) takes the wolf over, (v) retu rns and takes the goat
over.
Another answer is 000 → 010 → 110 → 100 → 101 → 111. This means that the
ferryman (i) takes the goat across, (ii) returns and takes th e wolf over, (iii) brings
back the goat, (iv) takes the cabbage over, (v) returns and ta kes the goat over.
Go to https://xkcd.com/1134/ to see a funny, but incorrect, solution.
Example 10.64. Prove that amongst six people in a room there are at least thre e who know
one another, or at least three who do not know one another.
Solution: Consider an arbitrary person of this group (call him Peter). There
are five other people, and of these, either three of them know P eter or else, three
of them do not know Peter.
Let us assume three know Peter. If two of these three people kn ow one another,
then we have a triangle of three people who know each other (Pe ter and these
two–see the graph below on the left, where the acquaintances are marked by solid
lines). If no two of these three people know one another, then we have three mutual

424 Chapter 10
strangers (see the graph on the right).
Peter Peter
The argument for the case when three do not know Peter is simil ar and is left to
the reader.
Example 10.65. Mr. and Mrs. Landau invite four other married couples for din ner. Some
people shook hands with some others, and the following rules were noted: (i) a person did not
shake hands with himself, (ii) no one shook hands with his spo use, (iii) no one shook hands
more than once with the same person. After the introductions , Mr. Landau asks the nine
people how many hands they shook. Each of the nine people aske d gives a different number.
How many hands did Mrs. Landau shake?
Solution: The given numbers can either be 0, 1, 2, . . . , 8, or 1, 2, . . . , 9. Now, the
sequence 1, 2, . . . , 9 must be ruled out, since if a person shook hands nine times,
then he must have shaken hands with his spouse, which is not al lowed. The only
permissible sequence is thus 0, 1, 2, . . . , 8. Consider the person who shook hands 8
10.1 . Discounting himself and his spouse, he must have shaken times, as in figure
hands with everybody else. This means that he is married to th e person who shook
0 hands! We now consider the person that shook 7 hands, as in fig ure 10.2 . He
didn’t shake hands with himself, his spouse, or with the pers on that shook 0 hands.
But the person that shook hands only once did so with the perso n shaking 8 hands.
Thus the person that shook hands 7 times is married to the pers on that shook
hands once.  Continuing this argument, we see the following p airs: (8, 0), (7, 1),
(6, 2), (5, 3). This leaves the person that shook hands 4 times without a partner,
meaning that this person’s partner did not give a number, hen ce this person must
be Mrs. Landau! Conclusion: Mrs. Landau shook hands four tim es. A graph of
10.3 . the situation appears in figure
6 7 6 7 6 7
5 5 5
8 8 8
4 4 4 Mr. Landau Mr. Landau Mr. Landau
3 0 3 0 3 0
2  1 2  1 2  1
Figure 10.1: Example Figure 10.2: Example Figure 10.3: Example 10.65 . 10.65 . 10.65 .

Problem Solving with Graphs 425
Definition 10.66. Recall that a trail is a walk where all the edges are distinct. An Eulerian
trail on a graph G is a trail that traverses every edge of G . A tour of G is a closed walk
that traverses each edge of G at least once. An Euler tour (or Euler cycle ) on G is a tour
traversing each edge of G exactly once, that is, a closed Euler trail. A graph is Eulerian if it
contains an Euler tour.
It turns out there is a very easy way to determine whether or no t a graph has an Euler tour.
Theorem 10.67. A nonempty connected graph is Eulerian if and only if it has no vertices of
odd degree.
Proof: Assume first that G is Eulerian, and let C be an Euler tour of G starting
and ending at vertex u . Each time a vertex v is encountered along C , two of the
edges incident to v are accounted for. Since C contains every edge of G , d ( v ) is
then even for all v 6 = u . Also, since C begins and ends in u , d ( u ) must also be even.
Conversely, assume that G is a connected nonEulerian graph with at least one edge
and no vertices of odd degree. Let W be the longest walk in G that traverses every
edge at most once:
W = v , v v , v , v v , v , . . . , v , v v , v . 0 0 1 1 1 2 2 n − 1 n − 1 n n
Then W must traverse every edge incident to v , otherwise, W could be extended n
into a longer walk. In particular, W traverses two of these edges each time it passes
through v and traverses v v at the end of the walk. This accounts for an odd n n − 1 n
number of edges, but the degree of v is even by assumption. Hence, W must also n
begin at v , that is, v = v . If W were not an Euler tour, we could find an edge n 0 n
not in W but incident to some vertex in W since G is connected. Call this edge
uv . But then we can construct a longer walk: i
u , uv , v , v v , . . . , v v , v , v v , . . . , v v , v . i i i i +1 n − 1 n n 0 1 i − 1 i i
This contradicts the definition of W , so W must be an Euler tour. 
The following problem is perhaps the originator of graph the ory.
Example 10.68 (K ̈onigsberg Bridge Problem) . The town of K ̈onigsberg (now called Kalin-
ingrad) was built on an island in the Pregel River. The island sat near where two branches
of the river join, and the borders of the town spread over to th e banks of the river as well as
a nearby promontory. Between these four land masses, seven b ridges had been erected. The
townsfolk used to amuse themselves by crossing over the brid ges and asked whether it was
possible to find a trail starting and ending in the same locati on allowing one to traverse each
10.4 has a graph-theoretic model of the town, with the of the bridges exactly once. Figure
10.67 , this graph is not seven edges of the graph representing the seven bridges. By T heorem
Eulerian so it is impossible to find a trail as the townsfolk as ked.
Definition 10.69. A Hamiltonian cycle in a graph is a cycle passing through every vertex.
G is Hamiltonian if it contains a Hamiltonian cycle.

426 Chapter 10
A
B D
C
10.68 . Figure 10.4: Model of the bridges in K ̈onigsberg from Example
Unlike Theorem 10.67 , there is no simple characterization of all graphs with a Ham iltonian cycle.
In fact, the problem of determining whether or not a graph con tains a Hamiltonian cycle is one of
the most famous NP-Complete problems. The details are beyond the scope of this book, but b riefly
(and oversimplifying a bit), NP-Complete is a class of problems that are all equivalent in the sense
that if any of them can be solved in polynomial time, then they can all be solved in polynomial
time. Further, nobody currently knows whether or not any of t hem can be solved in polynomial
time. This leads to the so-called P versus NP problem, one of the most important open problems
in theoretical computer science. (Again, the details of pre cisely what this means are beyond the
scope of this book.)
Coming back to the Hamiltonian cycle problem, we do have the f ollowing one-way result.
Theorem 10.70 (Dirac’s Theorem, 1952) . Let G = ( V , E ) be a graph with n = | V | ≥ 3
n vertices where each vertex has degree ≥ . Then G is Hamiltonian.
2
Proof: Arguing by contradiction, suppose G is a maximal non-Hamiltonian graph
with n ≥ 3 , and that G has more than 3 vertices. Then G cannot be complete. Let a
and b be two non-adjacent vertices of G . By definition of G , G + ab is Hamiltonian,
and each of its Hamiltonian cycles must contain the edge ab .  Hence, there is a
Hamiltonian path v v . . . v in G beginning at v = a and ending at v = b . Put 1 2 n 1 n
S = { v : av ∈ E } and { v : v b ∈ E } . i i +1 j j
As v ∈ S ∩ T , we must have | S ∪ T | = n . Moreover, S ∩ T = ∅ , since if v §∩ T n i
then G would have the Hamiltonian cycle
v v ··· v v v ··· v v , 1 2 i n n − 1 i +1 1
as in the following figure, contrary to the assumption that G is non-Hamiltonian.
v v v v v v v 1 2 2 i i +1 n − 1 n
But then
d ( a ) + d ( b ) = | S | + | T | = | S ∪ T | + | S ∩ T | < n .
n n
and d ( b ) ≥ , we have arrived at a But since we are assuming that d ( a ) ≥
2 2
contradiction. 

Problem Solving with Graphs 427
Definition 10.71. A graph is planar if it can be drawn in a plane with no intersecting edges.
Such a drawing is called a planar embedding of the graph.
Example 10.72. Although the usual way K is drawn has two edges intersect, it is planar as 4
shown in figure 10.5 . It is important to understand that being planar means you can draw it
with no intersecting edges, not that every way of drawing it h as no edges intersecting.
B
A
3
2 1
4
D C
Figure 10.5: A planar embedding of K . 4
⋆ Exercise 10.73. Draw a planar embedding of K that does not have curved edges. 4
Definition 10.74. A face of a planar graph is a region bounded by the edges of the graph.
Example 10.75. K has 4 faces, labeled 1 through 4 in Figure 10.5 . Face 1 , which extends 4
indefinitely, is called the outside face .
Here are a few results about planar graphs. These theorems us e v and e instead of n and m
because although computer scientists often use n and m , graph theorists seem to prefer v and e .
And you should get used to the fact that not everybody uses the same notation, so it’s good for
you to see different letters used.
Theorem 10.76 (Euler’s Formula) . For every drawing of a connected planar graph with v
vertices, e edges, and f faces the following formula holds:
v − e + f = 2.
Proof: The proof is by induction on e . Let P ( e ) be the proposition that v − e + f =
2 for every drawing of a graph G with e edges. If e = 0 and it is connected, then we
must have v = 1 and hence f = 1 , since there is only the outside face. Therefore,
v − e + f = 1 − 0 + 1 = 2 , establishing P (0)
Assume now P ( e ) is true, and consider a connected graph G with e +1 edges. Either

428 Chapter 10
➊ G has no cycles. Then there is only the outside face, and so f = 1 . Since
there are e + 1 edges and G is connected, we must have v = e + 2 . This gives
( e + 2) − ( e + 1) + 1 = 2 − 1 + 1 = 2 , establishing P ( e + 1) .
➋ or G has at least one cycle. Consider a spanning tree of G and an edge uv in
the cycle, but not in the tree. Such an edge is guaranteed by th e fact that a tree
has no cycles. Deleting uv merges the two faces on either side of the edge and
′ ′ leaves a graph G with only e edges, v vertices, and f faces. G is connected
since there is a path between every pair of vertices within th e spanning tree.
So v − e + f = 2 by the induction assumption P ( e ) . But then
v − e + f = 2 = ⇒ ( v ) − ( e + 1) + ( f + 1) = 2 = ⇒ v − e + f = 2,
establishing P ( e + 1) .
This finishes the proof. 
Theorem 10.77. (a) Every simple planar graph with v ≥ 3 vertices has e ≤ 3 v − 6 edges.
as a subgraph (b) Every simple planar graph with v ≥ 3 vertices and which does not have C 3
has e ≤ 2 v − 4 edges.
Proof: If v = 3 , both statements are plainly true so assume that G is a maximal
planar graph with v ≥ 4 . We may also assume that G is connected, otherwise, we
may add an edge to G . Since G is simple, every face has at least 3 edges in its
boundary. If there are f faces, let F denote the number of edges on the k -th face, k
for 1 ≤ k ≤ f . We then have
F + F ··· + F ≥ 3 f . 1 2 f
Also, every edge lies in the boundary of at most two faces. Hen ce if E denotes the j
number of faces that the j -th edge has, then
2 e ≥ E + E + ··· + E . 1 2 e
Since E + E + ··· + E = F + F ··· + F , we deduce that 2 e ≥ 3 f . By Euler’s 1 2 e 1 2 f
Formula we then have e ≤ 3 v − 6 .
The second statement follows for v = 4 by inspecting all graphs G with v = 4 .
Assume then that v ≥ 5 and that G has no cycle of length 3 . Then each face has
at least four edges on its boundary. This gives 2 e ≥ 4 f and by Euler’s Formula,
e ≤ 2 v − 4 . 
10.77 part (a) implies that a graph with at least 3 vertices and more than To be clear, Theorem
3 v − 6 edges cannot be planar (the contrapositive of the statemen t). Similarly for part (b).
) ( 5
= 10 edges and 10 > Example 10.78. K is not planar by Theorem 10.77 since K has 5 5 2
9 = 3(5) − 6.

Problem Solving with Graphs 429
⋆ Exercise 10.79. Prove that K is not planar. 3,3
Answer

430 Chapter 10
10.7  Reading Comprehension Questions
10.1 From Section
⋆ Question 10.1. Draw an example of each of the following:
(a) An weighted undirected pseudograph
(b) An unweighted directed multigraph
(c) A network
⋆ Question 10.2. Give an example of a problem that might be modeled using the fo llowing types
of graphs. Make sure it is clear what the vertices and edges re present.
(a) A network
(b) An directed weighted multigraph.
(c) An unweighted undirected pseudograph
) ( n
edges. (There are several ⋆ Question 10.3. Prove that a graph with n vertices has at most 2
possible ways to prove this. You can use counting techniques or induction, for instance.)
From Section 10.2
Question 10.4. Draw an unconnected graph such that one component contains a cycle of length ⋆
4 and another component is a tree.
⋆ Question 10.5. (a) How many edges does a tree with n ≥ 2 vertices have? Draw a few trees of
various sizes and you should see an obvious pattern.
(b) (a bit challenging) Prove that your formula is correct. ( Hint: Use induction. But you have to
be a little careful in how you do it. Also, you may assume that e very tree contains at least one
vertex with degree 1.)
⋆ Question 10.6. answer the following questions about graph L below.
(a) Is L weighted or unweighted? a
(b) Is L directed or undirected?
e b (c) Are e and x adjacent? Are f and b adjacent?
v x (d) Is L connected?
c f (e) How many vertices does L have?
(f) How many edges does L have?
d
(g) What is deg( v )? deg( c )?
∑
(h) What is deg( v )? Does this number seem to be related to your answer from (e)? Explain. v ∈ L
(i) Draw a spanning tree of L . How many edges does it have? Does your spanning tree contain
any cycles? Explain why or why not.

Reading Comprehension Questions 431
(j) What is the minimum number of edges that you can remove to m ake the graph disconnected
(that is, not connected)? Which ones?
(k) Find a cycle of length 3 in L . Then find one of length 4. Repeat for 5, 6, 7, and 8.
10.3 From Section
⋆ Question 10.7. Draw K . 6
⋆ Question 10.8. Draw C . 8
⋆ Question 10.9. Draw P . 5
⋆ Question 10.10. Draw Q . Just kidding. That would be a bit difficult to visualize. Inst ead, 5
describe how you could construct Q recursively. For instance, can you see how to go from Q 5 1
to Q ?  And from Q to Q ?  And from Q to Q ? Once you observe the pattern it is pretty 2 2 3 3 4
straightforward to see how to construct Q from Q . k +1 k
⋆ Question 10.11. Give a partition of the vertices of Q to show that it is bipartite. In other 3
words, which vertices go in V and which go in V ? Use 3-bit numbers to list the vertices (since 1 2
that is the natural way to construct the graph).
. Then draw a graph G such that G is a subgraph of K . ⋆ Question 10.12. Draw K 3,5 3,5
From Section 10.4
⋆ Question 10.13. Give an informal proof of Theorem 10.47 . That is, argue why it makes sense
by talking about edges, degrees, and vertices.
⋆ Question 10.14. You are at a party with some friends and one of them claims “I ju st did a
quick count, and it turns out that at this party, there are an o dd number of people who have
shaken hands with an odd number of other people at the party.” Prove or disprove that this friend
is correct.
From Section 10.5
Question 10.15. (a) If a graph has very few edges, which representation is a be tter choice if ⋆
space is the only consideration? Explain.
(b) If a graph has many edges, which representation is a bette r choice if space is the only consid-
eration? Explain.
⋆ Question 10.16. Are space considerations actually that important? In other words, practically
speaking, if you can store a graph using one of the representa tion, can you store it in the other
without worrying too much about space? Explain. (This is an i mportant question, so think carefully
about it!) (Hint: Think about storing the graph of friends on Facebook or another social media
site.)
⋆ Question 10.17. Given an adjacency list representation of a graph with n vertices and m edges,
how long do the following operations take?
(a) Determine whether or not ( u , v ) ∈ E .
(b) Determine deg( u ).

432 Chapter 10
(c) Iterate over the neighbors of vertex u (assume u has k neighbors).
⋆ Question 10.18. Given an adjacency matrix representation of a graph with n vertices and m
edges, how long do the following operations take?
(a) Determine whether or not ( u , v ) ∈ E .
(b) Determine deg( u ).
(c) Iterate over the neighbors of vertex u (assume u has k neighbors).
⋆ Question 10.19. (a) If adding and removing edges is an important operation, is one of the
representations a better choice? Explain.
(b) If adding and removing vertices is an important operation, is one of the representations a be tter
choice? Explain.
From Section 10.6
Question 10.20. (a) Is K Eulerian? Explain. ⋆ 5
(b) Is K Eulerian? Explain. 6
(c) Is Q Eulerian? If so, number the edges of Q in order to demonstrate the Euler tour. If not, 3 3
explain why not.
(d) Is Q Eulerian? If so, number the edges of Q in order to demonstrate the Euler tour. If not, 4 3
explain why not.
(e) Is Q Hamiltonian? If so, draw a Hamiltonian cycle on Q . If not, explain why not. 3 3
(f) Is Q Hamiltonian? If so, draw a Hamiltonian cycle on Q . If not, explain why not. 4 4
(g) Is asking if C is Hamiltonian a stupid question? Explain. 7
⋆ Question 10.21. Give a planar embedding of K . 2,3
⋆ Question 10.22. Does Theorem 10.77 imply that if a graph with v ≥ 3 vertices has fewer than
3 v − 6 edges that it is planar? Explain, using an example if approp riate.
is planar. ⋆ Question 10.23. (a) Prove that Q 3
(b) Prove that Q is not planar. 4

Problems 433
10.8  Problems
Problem 10.1. Give the degrees of the vertices of each of the following grap hs. Assume m and n
are positive integers. For instance, for P , n − 1 of the vertices have degree 2, and 2 vertices have n
degree 1.
(a) C n
(b) Q n
(c) K n
(d) K m , n
Problem 10.2. Can a graph with 6 vertices have vertices with the following d egrees: 3, 4, 1, 5, 4, 2?
If so, draw it. If not, prove it.
Problem 10.3. Prove or disprove that Q is bipartite for n ≥ 1. n
Problem 10.4. For what values of n is K bipartite? n
Problem 10.5. Give the adjacency matrix representation of Q , numbering the vertices in the 3
obvious order.
Problem 10.6. (a) Give the adjacency matrix representation for K . 4
(b) Give the adjacency list representation for K . 4
Problem 10.7. Describe what the adjacency matrix looks like for K for n > 1. n
Problem 10.8. Describe what the adjacency matrix looks like for C for n > 1. n
Problem 10.9. Given an adjacency matrix for C , with n > 1, how can you modify it to make it n
the adjacency matrix for P ? n
Problem 10.10. What property does the adjacency matrix of every undirected graph have that
is not necessarily true of directed graphs?
Problem 10.11. Let G be a graph and let u and v be vertices of G .
(a) If G is undirected and there is a path from u to v , is there necessarily a path from v to u ?
Explain, giving an example if possible.
(b) If G is directed and there is a path from u to v , is there necessarily a path from v to u ? Explain,
giving an example if possible.
Problem 10.12. For what values of n is Q Eulerian? Prove your claim. n
Problem 10.13. Is C Eulerian for all n ≥ 3? Prove it or give a counter example. n
Problem 10.14. Prove that K is Hamiltonian for all n ≥ 3. n
Problem 10.15. Prove that K is Hamiltonian for all n ≥ 3. n , n
Problem 10.16. For what values of m and n is K Eulerian? m , n
Problem 10.17. A graph is Eulerian if and only if its adjacency matrix has wha t property?

434 Chapter 10
Problem 10.18. What properties does an adjacency matrix for graph G need in order to use
10.70 to prove it is Hamiltonian? Theorem
Problem 10.19. Let G be a bipartite graph with v vertices and e edges. Prove that if e > 2 v − 4,
then G is not planar.
Problem 10.20. For each of the following, either give a planar embedding or p rove the graph is
not planar.
(a) Q 3
(b) Q 5
(c) K 2,3
(d) K 6
Problem 10.21. Let G be a graph with n vertices and m edges and let u and v be arbitrary vertices
of G . Describe an algorithm that accomplishes each of the follow ing assuming G is represented
using an adjacency matrix . Then give a tight bound on the worst-case complexity of the a lgorithm.
Your bounds might be based on n , m , deg ( u ), and/or deg ( v ).
(a) Determine the degree of u .
(b) Determine whether or not edge ( u , v ) is in the graph.
(c) Iterate over the neighbors of u (and doing something for each neighbor, but don’t worry abou t
what and assume it takes constant time for each neighbor).
(d) Add an edge between u and v .
10.21 , but this time assume that G is represented using adjacency Problem 10.22. Repeat Problem
lists .
(a) Determine the degree of u .
(b) Determine whether or not edge ( u , v ) is in the graph.
(c) Iterate over the neighbors of u (and doing something for each neighbor, but don’t worry abou t
what).
(d) Add an edge between u and v .
Problem 10.23. (a) List several advantages that the adjacency matrix repre sentation has over
the adjacency list representation.
(b) List several advantages that the adjacency list represe ntation has over the adjacency matrix
representation.

Chapter 11: Reading Question Solutions
2.1 A proposition is a statement that is either true or false.
2.2 The operators are negation , or , and , exclusive-or , conditional , and biconditional . See Table 2.1
and Table 2.2 for the truth tables.
2.3 p ∨ q is true if p is true, q is true, or both p and q are true, whereas p ⊕ q is true if and only
if exactly one of p or q is true. So the difference is that is both p and q are true, p ∨ q is true, but
p ⊕ a is false.
2.4 It is true unless p is true and q is false.
2.5 Here is a truth table with some intermediate columns to help. As long as you have the same
final column, yours is probably fine.
p   q p ∧ q ¬ p ( p ∧ q ) ∨¬ p
T   T T F T
T   F F F F
F   T F T T
F   F F T T
2.6 Here is a truth table with some intermediate columns to help. As long as you have the same
final column, yours is probably fine.
p   q    r p ∧ q ( p ∧ q ) ∨ r
T   T   T T T
T   T   F T T
T   F   T F T
T   F   F F F
F   T   T F T
F   T   F F F
F   F   T F T
F   F   F F F
2.7 By definition, no. If p is true, ¬ p is false, and if p is false, ¬ p is true.
2.8 q must be true since one of them has to be and p is not.
2.9 Nothing. It might be true, but it also might be false.
2.10 They are both true.
2.11 q has to also be false since p ↔ q implies they have the same truth value.
2.12 In this case q also has to be true.
2.13 Since p → q is true whenever p is false, we cannot say anything about q , so it could be true
or false.
2.14 By definition, if a proposition is a contingency, then it is not a tautology.
2.15 By definition, a proposition and its negation can never both be true. If the proposition is
true, its negation is false, and if the proposition is false, its negation is true.
2.16 (a) p ∨ T is true if and only if either p or T is true. Since clearly T is true, p ∨ T is always
true. Therefore, p ∨ T = T . Alternatively, you can give a truth table for p ∨ T and then comment
something like “since the final column of the truth table is al ways true, p ∨ T = T .” (b) We will
do this one with a truth table: Notice that the column for p ∧ F in the truth table below is always
false. Therefore p ∧ F = F .
p p ∧ F
T F
F F
435

436 Chapter 11
2.17 You could draw a truth table and show that the columns for thes e two differ. However, there
is any easier approach. Notice that if p is true and q is false, ¬ p ∧¬ q is false, but ¬ ( p ∧ q ) is true.
Therefore they are not equivalent.
2.18 We can’t use the first reason because DeMorgan’s law isn’t the only rule we have to determine
whether or not two propositions are equivalent. Perhaps the y are equivalent by some other rule (in
this case they aren’t, which you should know if you answered t he previous question). The second
reason is also not valid because every proposition is equiva lent to many other propositions that look
different than it, so just knowing that they look different doesn ’t tell us anything. For instance,
DeMorgan’s law says that ¬ p ∧¬ q = ¬ ( p ∨ q ). So even though those two don’t look that same,
they are equivalent.
2.19 Find an assignment of true values to the variables such that o ne is true and the other is false.
That’s all there is to it. Although sometimes this is easier s aid than done!
2.20 A propositional function is a statement that contains one or more variables and depending on
the values of the variable(s), the statement is true or false . In other words, a propositional function
is a function whose outputs are propositions.
2.21 ¬∀ xP ( x ) means that it is not the case that P ( x ) is true for all values of x . So it doesn’t
mean it is never true. It means that for one or more values of x it is false. That is, it means means
that it is not always true.
2.22 ¬∃ xP ( x ) means that it is not the case that there is a value of x for which P ( x ) is true. In
other words, it is indeed saying that P ( x ) is never true.
2.23 The two obvious alternatives are ¬∃ x ∃ yQ ( x , y ) and ∀ x ∀ y ¬ Q ( x , y ).
2.24 These are all equivalent: ∀ x ¬ ( x < 0 ∧ x > 0), ∀ x ( ¬ ( x < 0) ∨¬ ( x > 0)), and ∀ x ( x > =
0 ∨ x < = 0).
2.25 ∀ x ∃ yH ( x , y ).
2.26 Let C ( x , y ) =“ x changes at time y .” Then ¬ C ( x , y ) =“ x stays the same at time y .” If
you did not define a predicate similar to this, stop reading no w and try to come up with the rest
of the answer using C ( x , y ) before continuing to read. Then the expression can be written as
¬∃ x ∃ yC ( x , y ) ∧¬∃ x ∃ y ¬ C ( x , y ), which of course can be simplified ∀ x ∀ y ¬ C ( x , y ) ∧∀ x ∀ yC ( x , y ) (but
you would probably re-interpret this version in English as “ Everything stays the same, everything
changes,” which if you think about is it essentially saying t he same thing.).
2.27 (a) Given any integer, there is an integer that is at least as l arge as it. (b) There is an integer
such that every integer is at least as large as it is. (c) They d o not seem to be saying the same
thing at all. (d) True. (e) False. (f) If the universe of disco urse is changed to positive integers,
then both statements are true. (The second one becomes true b ecause every positive integer is at
least as large as 1.) (g) No. Just because two statements have the same truth value, that does not
2 mean they are saying the same thing. For instance, “1+1=2” is true and “ x ≥ 0” is true, but they
definitely are saying very different things.
2.28 ¬ p , q , ¬ r , r .
2.29 ¬ p , p ∧ r , ¬ p ∧ r , q , ¬ r .
2.30 ¬ p , p ∧ r , q ∨¬ r , ¬ p ∧ r ,  ( p ∧ q ) ∨ ( q ∧¬ r ) ∨¬ p ,  ( p ∧¬ r ∧ q ) ∨ ( ¬ p ∧ r ∧¬ q ) ∨ ( p ∧ r ∧
q ) ∨ ( ¬ p ∧¬ r ∧¬ q ).
3.1 Answers will vary, but it should say something like “An argum ent using logic and/or math to
demonstrate or show the nature of a conclusion,” or “the proc ess or an instance of establishing the
validity of a statement especially by derivation from other statements in accordance with principles
of reasoning” (the latter is from Merriam-Webster).
3.2 If someone correctly proves statement A , that means it is a true statement, regardless of
whether or not you understand the proof. That’s because, by d efinition, a proof establishes the
validity of a statement.

Reading Question Solutions 437
3.3 True. An even integer is one of the form 2 k , where k is an integer. An odd integer is one of
the form 2 k + 1 where k is an integer. Thus, even numbers are divisible by 2 whereas o dd numbers
are not. A number cannot both be divisible by 2 and not divisib le by 2 at the same time.
3.4 No. For instance, 6 is divisible by 2, but 2 is not divisible by 6.
3.5 No. A number cannot be both composite and prime because by defi nition, a composite integer
is a positive integer c > 1 that is not prime. Thus, every integer greater than 1 is either prime or
composite, but never both.
3.6 3, 97, 173, and 999983 are prime. 4, 6, 27, 38, 150, and 999985 a re composite. 1 is neither. It
is impossible to be both.
3.7 6! = 6 · 5 · 4 · 3 · 2 · 1 = 720. 7! = 7 · 6! = 7 ∗ 720 = 5040, computed the easy way be recognizing
I just needed to multiply the previous answer by 7.
3.8 Clearly 2! = 2 is prime. We will show that this is the only case i n which n ! is prime. 1! = 1,
which is not prime by definition. 3! = 2 · 3, which is clearly not prime. If n > 3, n ! is divisible by
3! = 3 · 2, so it not prime.
3.9 No. Take the example from the book, “If you know Java, then you know a programming
language” (where A is the proposition “you know Java” and B is the proposition “you know a
programming language.” Since Java is a programming languag e, this proposition is true. Then B
implies A is the proposition “if you know a programming language, then you know Java.” But that
is clearly not true. You might know C++ , which is a programming language, but not know Java.
3.10 False.  From the previous answer, consider the implication “ if you know a programming
language, then you know Java,” and its inverse, “if you do not know a programming language, then
you do not know Java.” It shouldn’t be too difficult to see that a lthough the inverse is true, the
implication is false.
3.11 This one is true since the inverse and converse of an implicat ion are contrapositives of each
other, and an implication and its contrapositive are equiva lent.
3.12 An implication and its contrapositive are equivalent. Ther efore, if one is true, then the other
is true (and if one is false, the other is false, of course).
3.13 Your answer will likely be different, and hopefully more detai led than the one provided here.
But you should say something about how you assume that what yo u want to prove is false, then
use logic to arrive at a contradiction (that is, a statement t hat you know to be false). Since you
“proved” a false statement using correct logic, it must be th at your premise (that is, the statement
that you assumed was false) is incorrect. Since your premise was that the statement you wanted
to prove was false, then it must be that the statement is true ( again, because you showed that if it
is false, then you can prove something that is not true).
3.14 They are (cow, chicken, rabbit), (cow, rabbit, chicken), (c hicken, cow, rabbit), (chicken,
rabbit, cow), (rabbit, cow, chicken), and (rabbit, chicken , cow).
a 3.15 True. Every integer a can be written as a = , where a and 1 are both integers and 1 6 = 0,
1
so it is rational.
3.16 Assume that k is the smallest positive rational number. Since k is rational, we can write it
as p/q for integers p and q 6 = 0. But clearly k/ 2 = p/ (2 q ) is positive, rational, and smaller than
k , which contradicts our assumption that k was the smallest such number. Therefore there is no
smallest positive rational number.
3.17 Since an implication and its contrapositive are equivalent , if you prove the contrapositive of
a implication is true, then the implication must also be true . And that is exactly what proof by
contraposition does.
3.18 Contradiction: Assume that p and ¬ q are both true. Get a contradiction. Conclude that
if p is true, ¬ q cannot be true, so q must be true. Thus, p → q is true.
Contraposition: Prove that ¬ q →¬ p , which is equivalent to p → q .

438 Chapter 11
In both cases, you assume that ¬ q is true. Often the contradiction you get is that ¬ p is true (which
is the goal in contraposition proof), so the majority of the p roofs look the same. But they begin
and end slightly differently.
3.19 True. From the Question 3.15 , we know that every integer is rational, so integers are not
irrational.  Therefore, if a number is irrational, it cannot be an integer.  Alternatively, you can
recognize that this is essentially the contrapositive of th e Question 3.15 , so it is also true.
√ √
3.20 (a) Assume that x > 0 is irrational, but that x is rational.  Then x = p/q for some
√ 2 2 2 2 2
integers p , q 6 = 0. That means that x = ( x ) = ( p/q ) = p /q , which is clearly rational since p
2 and q 6 = 0 are both rational. But this contradicts our assumption th at x is irrational. Therefore,
√
x must be irrational.
√
x is rational, then x is rational, which will imply our statement is true (b) We will prove that if
√ √
since this is the contrapositive of our statement. Assume x is rational. Then x = p/q for some
√ 2 2 2 2 2
x ) = ( p/q ) = p /q which is clearly rational since p and integers p , q 6 = 0. Therefore, x = (
2 q 6 = 0 are both rational.
3 is rational, but clearly not an integer. 3.21 False. For instance, 1. 5 =
2
3.22 We will use a proof by cases. Case 1: If n is even, then n = 2 k for some integer k . Then
2 2 2 2 2 n = (2 k ) = 4 k = 2(2 k ), which is even since 2 k is an integer.  Case 2: If n is odd, then
2 2 2 2 n = 2 k + 1 for some integer k . Then n = (2 k + 1) = 4 k + 4 k + 1 = 2(2 k + 2 k ) + 1, which is odd
2 since 2 k + 2 k is an integer. In both cases, the parity remains unchanged.
3.23 No you would have to show the reverse as well. That is, if I want to prove A if and only if
B , I would have to prove either the proposition ( A → B ) or the contrapositive ( ¬ B →¬ A ) and I
would have to prove the inverse ( ¬ A →¬ B ) or the converse ( B → A ).
3.24 (a) No.  This is proving the forward direction twice by provin g the implication and its
contrapositive. One of these needs to be replaced with eithe r the inverse or converse. (b) Yes. This
is proving the contrapositive and the converse.
3.25 For the forward direction, we assume that n is even. Then n = 2 k for some integer k , so
2 2 2 2 2 2 n = (2 k ) = 4 k = 2(2 k ), which is even since 2 k is an integer. Thus, n even implies n is even.
2 For the reverse direction, we will prove that n is not even implies n is not even. In other words,
2 n is odd implies that n is odd.  Assume n is odd.  Then n = 2 k + 1 for some integer k , so
2 2 2 2 2 n = (2 k + 1) = 4 k + 4 k + 1 = 2(2 k + 2 k ) + 1, which is odd since 2 k + 2 k is an integer. Thus,
2 n odd implies that n is odd, which (as we have already said, but we’ll say it again a nyway) is
2 equivalent to n is even implies n is even.
3.26 You use proof by counterexample to disprove statements. You only need to show one instance
where the statement is not true to demonstrate that it is not a lways true, so proof by counterexample
is valid. On the other hand, proof by example is just demonstr ating the truth of a statement given
some specific values. Just because it works for the given valu es, that does not prove that it works
for all values, so it is not a valid proof technique.
3.27 This is definitely not a valid proof technique! The problem is that when you write do wn an
equation and start working both sides of it, you are implicit ly assuming that the equation you are
starting with is true. But since you are trying to prove that i t is true, you can’t start your proof
with the fact that it is true–that is circular reasoning. For instance, do you remember the supposed
proof of − 1 = 1 that started by working both sides of the equation?
3.28 The step that divided both sides by a − b was division by zero, which is not allowed!
4.1 (b), (d), (f) make sense. For the incorrect ones, first note th at A and B are both sets of
numbers. (a) does not make sense because an element cannot be a subset of a set. For (c), A
contains the number 3, but not the set containing 3, which is w hat { 3 } is. For (e), A does not
contain as an element another set (i.e. B ), so that notation does not make sense.
4.2 5. Remember, repeated elements do not count!

Reading Question Solutions 439
4.3 (a) i. Yes, ii. No, iii. No. (b) 6, 3, 4. (c) They are all finite se ts.
4.4 (a) Yes (b) No (c) Yes (d) Yes (e) No
3 4.5 { n | n ∈ Z }
4.6 { n/ 100 | n ∈ Z }
4.7 Yes (because the power set of A is the set of all subsets of A , and A ⊆ A , so A ∈ P ( A )) and
No (because the elements of P ( A ) are subsets of elements of A , so a subset of P ( A ) would be a set
of subsets of A , but A is a set of elements (of whatever type A consists of). This is a subtle point,
so do not worry too much about it unless you plan to major in mat hematics.
5 4.8 2 = 32.
5 4.9 (a) | A | = 5 and | P ( a ) | = 2 = 32. (b) No. The elements of A are a , b , etc. If that statement
were true, { a }∈ A , but it is not. Remember, a ∈ A (which is true) and { a }∈ A (which is not true)
are not saying the same thing. (c) Yes. (d) No. As in part (b), t he elements of A are a , b , etc.
but { b , c , e } is a set of those elements. Remember: ∈ means “element of,” and ⊆ means “subset
of,” which are not the same thing! (e) Yes because each of the t hree sets in the set on the left are
subsets of A . (f) No. To be a subset of the power set, it needs to be a set of su bsets. This is a set
of elements. (g) Yes because the set { b , c , e } ⊆ A .
4.10 (a) { a , b , c , d , f , g , h , j , k , l , m , n , p , q , r , s , t , v , w , x , y , z } (b) { b , d , g , k , p , v } (c) { a } (NOT a !)
(d) { a } (e) { e , i , o , u }
4.11 (a) True; (b) False; (c) False; (d) True (This is DeMorgan’s l aw in words)
4.12 (a) answers will vary, but should be things like (1, z ), (3, x ), and (2, v ). (b) answers will vary,
2 3 4 ∗ 6 96
but should be things like (1, 2), (3, 3), and (4, 1). (c) 24. (d) 4 = 64. (e) 2 = 2 .
4.13 The area being pointed to is “with AND without you,” so it is not at all correct.
That is definitely not where Bono can’t live. Notice that “wit h
without
you” and “without you” are complements, so the Venn dia-
you with
gram to the right demonstrates a proper relationship betwee n
you them. So where can’t Bono live? He can’t live anywhere in
the rectangle (the universe) because he can’t live in the cir cle
(“with you”) or outside the circle (“without you”). Put an-
Where Bono can’t live other way, the entire diagram is the place where Bono can’t
live.
4.14 (a) A ⊆ B . (b) A = B .
4.15 First, A ∩ B is the set of elements that are in both A and B . Therefore, A ∩ B is the set
of elements that are not in both A and B . (This includes elements that are in A but not B , in B
A ∪ B is the union of the elements that are not in A and the but not A , or in neither A nor B .)
elements that are not in B . That is, it is any element that is either not in A or not in B . So it is all
A ∩ B is. Therefore, A ∩ B = A ∪ B . elements that are not in both A and B , which is exactly what
4.16 First, notice that since U is the universal set, A ⊆ U and A ⊆ U . Let x ∈ A ∪ A . Then either
x ∈ A or x ∈ A . In either case, x ∈ U (since A ⊆ U and A ⊆ U ). Therefore A ∪ A ⊆ U .
Now, assume x ∈ U . If x ∈ A , then x ∈ A ∪ A . If x 6∈ A , then by definition, x ∈ A , and
A . In either case, x ∈ A ∪ A . Therefore U ⊆ A ∪ A . therefore x ∈ A ∪
Since we proved containment both ways, A ∪ A = U .
4.17 Given an integer a , compute a mod 2. If it is 0, a is even, and if it is 1, a is odd.
4.18 It certainly can be used. If the current time is t , and you are on 24-hour time, then in 8
hours the time will be ( t + 8 mod 24. If you are using 12-hour time, it is a little more com plicated.
You can compute ( t + 8) mod 12 to get the time in 8 hours, but if the result is 0, you n eed to treat
it like 12. Also, this does not take into account whether ther e was a switch from am to pm. That
is more complicated and we would need to use additional logic to get that part correct.

440 Chapter 11
4.19 Compute c = a mod n and d = b mod n . According to Theorem 4.74 , c = d if and only if
a ≡ b (mod n ). so just determine whether or not c = d .
4.20 No. In fact, they are usually not going to be the same (unless y ou start with an integer). As
an example, the floor of 3.2 is 3, and the ceiling of 3 is 3, so the ceiling of the floor of 3.2 is 3. The
ceiling of 3.2 is 4, and the floor of 4 is 4, so the floor of the ceil ing of 3.2 is 4.
4.21 (a) Z . (b) Z . (c) { 2 z | z ∈ Z } . That is, the set of all even numbers.
4.22 Here are possible answers. There are many other possible cor rect answers. (a) f ( x ) = 2 x .
(b) f ( x ) = 6. (c) f ( x ) = 2 x . (d) f ( x ) = 4. (e) f ( x ) = 2 x .
4.23 Here are possible answers. There are many other possible cor rect answers. (a) f ( x ) = 2 x .
(b) f ( x ) = (2 x ) mod 6 (so f (4) = 2 instead of 8). (c) Impossible. The domain only has 4 num bers,
and the codomain has 6, so it is impossible to map to all of them . (d) f ( x ) = 2 x (it doesn’t map
to 10 or 12). (e) Impossible. Since an onto function is imposs ible, a bijective one is as well.
x +2 x 4.24 ( f ◦ g )( x ) = 2 and ( g ◦ f )( x ) = 2 + 2. Did you get them backwards? If so, look at the
definition of composition of functions again.
4.25 (a) False. If a = b , then clearly f ( a ) = f ( b ), so that’s meaningless. You need to show that if
f ( a ) = f ( b ), then a = b . (b) True. (c) False. That’s the definition of a function. to s how onto, you
need to show that every element of the codomain gets mapped to by some element of the domain.
(d) True. Since the range is the set of values actually mapped to, if it equals the codomain, then
every value is mapped to and the function is onto. (e) False. F or two reasons. First, elements of the
range are always mapped to–that’s the definition of range. Ev en if you change range to codomain,
it is still false. You only need to show that there is at least o ne element of the codomain that is
not mapped to. (f)True.
3 3 3 3 4.26 First, notice that if f ( a ) = f ( b ), then a − 8 = b − 8, which implies a = b . Taking the third
√ 3
x + 8 ∈ R , root of each side, we get a = b . Thus, f is one-to-one. Now, notice that if x ∈ R , then ( ) ( ) √ √
3 3 3
and f − 8 = x + 8 − 8 = x , so f is onto. To find the inverse (which I already x + 8 = x + 8
3 did in order to prove it was onto, but I’ll show the work anyway ), we solve y = x − 8 for x . We
√ √ 3 − 1 3 3
y + 8. Replacing variables, we have that f x + 8. = get x = y + 8, so x =
4.27 (a) C = { 1, 3, 5, 7, 9 } .  (b) C = { 1, 2, 3, 5, 7, 9 } (or any set that contains all of 1,3,5,7,9,
and at least one of 2, 4, 6, 8, or 10). (c) C = { 1, 3, 7, 9 } (or any proper subset of { 1, 3, 5, 7, 9 } ).
(d) C = { 1, 3, 5 } and D = { 7, 9 } (or any two disjoint sets such that C ∪ D = { 1, 3, 5, 7, 9 } . (e)
C = { 1, 2, 3, 5 } and D = { 7, 9 } (or many other possibilities).
4.28 Yes. It is a subset of Z × Z .
4.29 There are many possible answers. Here is one. Define T to be the relation on human beings
such that xT y if and only if x is at least as tall as y . It is not hard to see that T is reflexive,
anti-symmetric, and transitive, so it is a partial order.
4.30 answers we vary, but here is one possibility. Let C be the set of all cars. Define the relation R
on C by xRy if and only if x was manufactured in the same year as y . It is not hard to see that R
is symmetric, reflexive, and transitive, so it is an equivale nce relation. Let C be the set of all cars y
manufactured in year y . Then it is not hard to see that C = C ∪ C ∪···∪ C ∪ C ∪ C 1886 1887 2023 2024 2025
is a partition of C (assuming you aren’t reading this in 2026 or later, and assum ing we regard 1886
as the first year a car was made, which turns out to be a question without a clear answer). For a
representative for class C , simply pick any car that was manufactured in year y . y
4.31 (a) It is straightforward to prove that B is symmetric, reflexive, and transitive, so it is an
equivalence relation. (b) It is not. It is no anti-symmetric . (c) Let B be the positive integers that i
have i ones in their binary representation. It is easy to see that B ∩ B = ∅ if i 6 = j and that i j
+ + Z = B ∪ B ∪ B ∪··· , so this definition gives us a partition of Z . (d) We just let a be the
1 2 3 i
number whose binary representation is i 1s. For instance, a = 1, a = 3, a = 7, etc. Notice that 1 2 3
i we can do better by defining it explicitly: a = 2 − 1. (e) The smallest elements of B would be
i 2

Reading Question Solutions 441
3 = 11 , 5 = 101 , 6 = 110 , and 9 = 1001 . There are infinitely many other possible answers. 2 2 2 2
5.1 It means that the result of the algorithm is some value that ca n be assigned to a variable.
For instance, when a line of code like int a = min(4,5) executes, the min method (algorithm)
“returns” the minimum value so it can be assigned to the varia ble a .
5.2 Here it is. Note that the order of the parameters does not matt er.
double cuboidVolume( double w, double h, double d) {
return w*h*d;
}
5.3 Here is one possibility: keep subtracting n from a until you get to a number less than n :
int modN( int a, int n) {
while (a>=n) {
a=a-n;
return a;
}
That is not very efficient if a is large, however. A more efficient solution would be as follow s:
int modN( int a, int n) {
return a - (a/n)*n;
}
Make sure you understand why this solution works! Also, it sh ould be noted that both of these
solutions require that a ≥ 0.
5.4 As was the case there, two reasonable solutions include (n+m/2)/m and (2n+m)/(2m) .
5.5 Here is one possible solution:
int a, int b, int n) { boolean congruentModN(
if (a%n==b%n) {
return true;
} else {
return false;
}
}
Here is a very concise solution. Do you see why it works?
boolean congruentModN( int a, int b, int n) {
return ((a-b)%n == 0);
}
5.6 The first one will not work if a and b have different signs. The second one will always work
since if the difference between a and b is a multiple of n , it will always return 0. Thus, the second
solution is better.
5.7 This one is pretty straightforward: if(x%2==1)
5.8 The easy answer is as follows:
if (x%2==0) {
x++;
else { }
x--;
}
One way to do it without a conditional statement is: x+=1-2*(x%2); Yikes!
5.9 It is probably a contingency. A tautology is a proposition th at is always true. Since there is a
conditional statement involved, it is likely that different c ases happen. In other words, there would
be no need for the if statement if the expression inside it is a tautology.
5.10 We need to use a nested conditional statement:

442 Chapter 11
if (!list.isEmpty()) {
if (list.get(0) >= 100) {
list.clear();
}
}
5.11 if( x > 0 && y > 0 ) (using DeMorgan’s law). Note that if( x >= 0 && y >= 0 ) is
not correct since x>0 is the negation of x<=0 .
5.12 ~ x = 218 (11011010), x & y = 32 (00100000), x | y = 117 (01110101), and x ^ y = 85 (01010101).
5.13 n − 1. Notice that the loop starts at 1 and ends at n − 1, so that’s n − 1 times (not n as you
might have guessed).
5.14 Here is the solution I expected you to come up with:
sumFirstN( int n) {
int sum = 0;
for ( int i = 1; i  <= n; i++) {
sum+=i;
}
}
O.K., I can’t resist giving the better answer. The following is much more efficient, but it may be
unclear to you why it is correct. Do not worry–we will see the i dea behind it later.
int n) { sumFirstN(
return n*(n + 1) / 2;
}
Do not worry if you do not understand this one—I definitely did not expect you to come up with
this one yet. But I wanted to prime your mind for something we w ill learn very soon.
5.15
int minimum( int a[], int n) {
int min = a[0];
for ( int i=1;i 0 they are
monotonic. They are also sometimes increasing. For instanc e, if r > 1, it will be increasing, but if
0 < r < 1 it will be decreasing. If r < 0, they are neither increasing nor decreasing since they go
back and forth between positive and negative.
6.7 They are always monotonic.  A given arithmetic progression i s either always increasing or
always decreasing, depending on whether d is positive or negative.
6.8 Many answers are possible, but your answer should be very sim ilar in form as the ones given.
n (a) a = 3(2 / 3) . (b) b = 2 + 8 n . (c) c = (5 / 3) c , c = 3. (d) d = d + 9 / 4, d = 8.
n n n n − 1 0 n n − 1 0
i i i i i 6.9 They are not because − x = − ( x ) and ( − x ) = ( − 1) ( x ) . Depending on whether x is positive
or negative and depending on whether i is even or odd, these may have opposite signs.
6 6 ∑ ∑
i +1 i i ( − 1) 3 . 6.10 − ( − 3) or
i =0 i =0
30 30 30 30 ∑ ∑ ∑ ∑
30 · 31
− 217 = 2108 6.11 5 k − 7 = 5 k − 7 = 5 k − 7 ∗ 31 = 5
2
k =0 k =0 k =0 k =0
n n n +1 n +1 n +1 ∑ ∑
2 − 1 1 − 2 1 − 2 k k n +1 n +1
6.12 2 = 2 = = 2 − 1 or = = 2 − 1.
2 − 1 1 − 2 − 1
k =0 k =0
6.13 Sure. Whenever x = 0. 0
6.14 If you can get this one without mistakes, you are doing really well! If you don’t quite get it,

Reading Question Solutions 445
keep trying to do it on your own. You will learn a lot in the proc ess and it will be a good algebra
refresher. ) (
Å Å ã ã ã ã Å Å 23 23 23 23 23 k k k 0 ∑ ∑ ∑ ∑ ∑
1 1 1 11 1 1
= 11 = 11 = 11 = 11 − − − − k k
( − 7) ( − 7) − 7 7 7 7
k =1 k =1 k =1 k =0 k =1 ) ( ) ( Ç Ç å å ) ) ( (
Å ã 24 24 24 1 1 24
1 − ( − 1) 1 − − 7 1 7 7
) ( − 1 = 11 − 1 = 11 = 11 1 − − 1 8 1
8 7 1 − − 7 7
Ç å å å Ç Ç Å Å ã Å ã ã 24 23 23
1 11 1 7 1 1 1 7
1 + = − . − 1 = 11 − − − = 11
8 8 7 8 8 7 8 7
2 n 4 2 x x x
n + −··· + ( − 1) + ··· . To approximate 6.15 According to Theorem 6.84 , cos x = 1 −
2! 4! (2 n )!
cos(1), we can just use several terms of the infinite sum. So,
2 4 6 1 1 1 1 1 1 720 − 360 + 30 − 1 389
cos(1) ≈ 1 − + − = 1 − + − = = ≈ 0. 540277.
2! 4! 6! 2 24 720 720 720
Note that cos(1) = 0. 540302305 ··· , so our approximation is pretty good.
7.1 f ( n ) = O ( g ( n )) means that f ( n ) grows no faster than g ( n ). Another way of phrasing it is
saying that g ( n ) is an upper bound on f ( n ). If you said that it means g ( n ) grows faster than
f ( n ) , you are not quite correct. Go reread the definition and make s ure you are clear on this point!
f ( n ) = Θ( g ( n )) means that f ( n ) and g ( n ) grow at the same rate. Another way of phrasing it is
saying that g ( n ) is a tight bound on f ( n ).
7.2 (a) No. It means there is some n such that whenever n ≥ n , f ( n ) ≤ cg ( n ) (where c > 0 0 0
is some constant). So there are two problems with saying it me ans f ( n ) ≤ g ( n ). First, there is a
constant involved. So f ( n ) ≤ c g ( n ), not just f ( n ) ≤ g ( n ). Second, it does not have to hold for all
values of n , but only for (i.e. n ≥ n ). (b) No. Repeating what was said in the previous part, it 0
has to hold for all values of n at least as large as some given value n , but it does not have to hold 0
2 for smaller values of n . (c) That is certainly possible. For instance, if f ( n ) = 100 n and g ( n ) = n ,
g (10) = 100 < 1000 = f (10), but hopefully it is clear that f ( n ) = O ( g ( n )).
2 7.3 No. For instance, if f ( n ) = 23 n and g ( n ) = n , then f ( n ) = O ( g ( n )), but f ( n ) 6 = Θ( g ( n )).
7.4 Yes. f ( n ) = Θ( g ( n )) if and only if f ( n ) = O ( g ( n )) and f ( n ) = Ω( g ( n )). So if f ( n ) = Θ( g ( n )),
then f ( n ) = O ( g ( n )).
7.5 If f ( n ) = o ( g ( n )), then we know that f ( n ) grows slower than g ( n ). If f ( n ) = O ( g ( n )), then
f ( n ) grows no faster than g ( n ). That is, f ( n ) either grows slower than g ( n ) or they grow at the
same rate.
7.6 More. If you know that f ( n ) = Θ( g ( n )), then you know that they grow at the same rate. But
if you only know that f ( n ) = O ( g ( n )), it is possible that the grow at the same rate, but it is also
possible that f ( n ) grows slower than g ( n ).
3 2 3 2 3 3 3 3 7.7 Proof 1: Notice that if n ≥ 1, 7 n +4 n − 8 n +27 ≤ 7 n +4 n +27 ≤ 7 n +4 n +27 n = 38 n .
3 2 3 By definition of Big-O, 7 n + 4 n − 8 n + 27 = O ( n ).
3 2 2 3 7 n + 4 n − 8 n + 27 4 n 8 n 27 4 8 27 7 n
Proof 2: Notice that lim = lim + − + = lim 7+ − + = 3 3 3 3 3 2 3
n →∞ n →∞ n →∞ n n n n n n n n
3 2 3 7 + 0 + 0 + 0 = 7. Thus, 7 n + 4 n − 8 n + 27 = Θ( n ) by Theorem 7.50 (part 3). By Theorem 7.18 ,
3 2 3 7 n + 4 n − 8 n + 27 = O ( n ).
ã Å n n
3 3 3 n
7.8 Notice that lim 7.50 (part 1), 3 = < 1. By Theorem = 0 since = lim 3.1 n
n →∞ n →∞ 3. 1 3. 1
n o (3. 1 ).
7.9 Notice that both functions have a factor of n . Since log n grows faster than c (which doesn’t
grow at all since it is a constant), n log n grows faster than cn .

446 Chapter 11
n log n log n
7.50 , It is actually easy to prove this formally:  lim = lim = ∞ , so by Theorem
n →∞ n →∞ c n c
n log n = ω ( cn ). In other words, n log n grows faster than cn .
7.10 No! The function may grow slowly, but it is still growing . So you are multiplying a function
by another function that is growing (even if slowly), which g rows faster than 1. Thus, f ( n ) log n
definitely grows faster than f ( n ).
As with the previous question, a simple limit computation gi ves a clear proof of this fact.
log n f ( n ) log n
=  lim = ∞ , so by Theorem 7.50 , f ( n ) log n = ω ( f ( n )). In other words, lim
n →∞ n →∞ f ( n ) 1
f ( n ) log n grows faster than f ( n ).
2 2 3 3 2 n n 7.11 8675309, 7 log n ∼ log n , 27 n , 7 n log n , n + n + 1 ∼ 3 n , n ∼ n + n log n , 2 , 7 , n !,
10 3 2 e
n n
7.12 It is unclear what types of machines the algorithms were run o n. If one was run on a cellphone
and another on a supercomputer, it is definitely not a fair com parison. If they were run on the
same machine and on the same data, then we can compare them.
7.13 No. If one always takes 3 times as long, it’s just a constant mu ltiple difference, so they have
the same growth rate. E.g. if one takes f ( n ) time, the other takes 3 f ( n ) time, and these have the
same growth rate. Remember, when we are talking about growth rates, the constant multiples do
not matter.
7.14 Since g ( n ) grows faster than f ( n ), as n increases, algorithm B will take (relatively) longer
than A . In other words, algorithm A is faster. Remember: Faster growth rate of computational
complexity means slower algorithm!
7.15 You cannot even read all of the inputs in Θ(log n ) time, so this is clearly ludicrous. It would
have to take at least Ω( n ) time (and even that is not attainable, but we aren’t ready fo r that proof
yet).
7.16 This would be an awful algorithm since searching should not t ake more than Θ( n ) time.
2 1.5 2 7.17 Better because insertionSort takes Θ( n ) time and n = o ( n ).
7.18 One (or both) of the loops could only execute a constant numbe r of times. Also, maybe
the index variable(s) aren’t just incremented/decremente d by 1 each time through the loop.  If
instead the variables are doubled or halved, for instance, t he complexity might involve a logarithm
or something (e.g. maybe Θ( n log n )). Here’s a third (for free!): Maybe the outer loop executes n
times and the inner loop executes m times. Then the complexity is Θ( n m ).
7.19 (a) Generally speaking, B is faster. Since we are given Θ bounds on the complexities, we know
2 the exact growth rates and n log n = o ( n ), so B is definitely a faster algorithm. We know that B
is faster for large enough input. We do not know if is is faster for small inputs. (b) As mentioned in
the previous part, for small values of n , A could possibly be faster because the constants involved
in B might be much larger.
7.20 This is a trick question! The answer is unclear. We know that A has complexity Θ( n log n ),
but we are only given a Big-O bound on the complexity of B . It is possible that B has complexity
Θ( n ) and it is faster, or that it has complexity Θ( n log n ) and it is the same as A , or that it has
2 complexity Θ( n ) and it is slower than A .
7.21 Memory usage; how complicated the algorithms are to impleme nt, maintain, and debug; the
constants; how convinced you are of the correctness of each a lgorithm.
8.1 We need a “starting point.” Induction proofs involve provin g a statement of the form P ( k ) →
P ( k + 1). That is, we prove that if P is true for some value, then it is true for the next value. But
that does not imply that it is ever true–only that if it is true for some value, it is true for the next
value. So we need to prove that P is true for some value to get things started.
8.2 This is not circular reasoning because we are not proving tha t P ( k +1) is true. We are proving

Reading Question Solutions 447
that P ( k ) → P ( k +1) is true. In other words we are assuming P ( k ) is true, and the using that fact
to prove that P ( k + 1), which is a different statement, is true. But again, we did not prove that
P ( k + 1) is always true. We only proved that IF P ( k ) is true, then P ( k + 1) is true.
8.3 (a) It is saying that if P ( a ) is true and it is also true that whenever P ( k ) is true that P ( k + 1)
is true, then P ( n ) is true for all n ≥ a .  (b) We know that P ( a ) is true.  We also know that
P ( k ) → P ( k + 1) is true for all k ≥ a . In particular, we know that P ( a ) → P ( a + 1) is true. Using
modus ponens, we can conclude that P ( a + 1) is true. But then we can use modus ponens again to
conclude that P ( a + 2) is true (since we know P ( a + 1) and P ( a + 1) → P ( a + 2) are both true).
We can keep doing this over and over again so that eventually w e can show that P ( a + k ) is true
for any k ≥ 0. Thus, P ( n ) is true for all n ≥ a .
8.4 No. Notice that we know that P (0) is true, but we only know that P ( k ) → P ( k +1) for k > 0.
So we know P (1) → P (2), but we do not know whether or not P (0) → P (1). In other words, we
have a base case and an inductive case, but the inductive case does not go all the way down to the
base case, so we cannot connect them. (Note: this is not a fail ure of induction. It is a failure in
trying to use induction. A proper induction proof would show that P ( k ) → P ( k + 1) for k ≥ 0 so
that the inductive step applies to the base case.)
1 k 8.5 There are clearly 2 = 2 binary strings of length 1 (‘0’ and ‘1’). Assume that there ar e 2
binary strings of length k . Every string of length k + 1 ends with either a ‘0’ or a ‘1’, and the first
k characters can be any of the possible binary strings of lengt h k . In other words, the number of
k k +1 k binary strings of length k +1 is 2 · 2 = 2 since we can append to each of the 2 strings of length
k k k either a ‘0’ (producing 2 strings of length k + 1) or a ‘1’ (producing a different 2 strings of
length k ). Since we proved the base and inductive cases, we have shown that the number of binary
k strings of length k is 2 .
8.6 These are both correct techniques.
8.7 In weak induction you assume P is true for a given value and show P is true for the next value.
For instance, you might assume P ( k ) is true and prove that P ( k + 1) is true. In strong induction
you assume that P is true for every value from the base case up to a certain value , and then you
prove it for the next value. For instance, you assume P (1) ∧ P (2) ∧···∧ P ( k − 1) is true and prove
that P ( k ) is true. (By the way, I purposely used P ( k ) and P ( k + 1) for one and P ( k − 1) and P ( k )
for the other to re-emphasize that you can do it either way.)
8.8 Induction is like a bunch of dominoes lined up. If you push the first one over, it will push the
next one over, which will push the next one over, etc., until t hey have all fallen down. The first
domino is the base case. The fact that the dominoes are placed close enough to each other is like
the inductive case (because they are close enough, if one fal ls, the next one will).
8.9 It links to itself, kind of like how a recursive algorithm cal ls itself.
8.10 (1) A recursive algorithm mush have one ore more inductive cases (or recursive case) where
the algorithm calls itself. This is required since otherwis e the algorithm is not recursive. (2) A
recursive algorithm must have one or more base cases that can be solved directly (or at least non-
recursively). This is required since otherwise the algorit hm would never finish. (3) The recursive
calls must be making progress toward the base cases.  This is a lso required since otherwise the
algorithm would never finish.
8.11 They are both based on the same ideas, particularly that of ba ses cases and inductive cases.
8.12 Here is one solution.  This should be called with n being the size of the array.  Notice
that it searches from the end of the array to the beginning of t he array because it is the most
straightforward way to implement the recursive idea.
int search( int [] a, int n, int value) {
if (n<=0) {
return -1;

448 Chapter 11
} else if (a[n-1]== value) {
return n-1;
else { }
return search(a,n-1,value);
}
}
8.13 Neither is better. Iterative algorithms are often faster th an their recursive equivalents, but
recursive algorithms are often easier to come up with and imp lement. So they both have their
merits.
8.14 A recurrence relation is a recursively defined formula for th e values of a sequence. In other
words, it is a formula to compute a based on one or more values of a where i < n . n i
8.15 It means to come up with a closed formula. That is, formula to c ompute the n th term of the
sequence directly (not based on previous values of the seque nce).
8.16 (a) The substitution method essentially involves guessing the correct formula and using
induction to prove it. (b) The iteration method keeps applyi ng the recursive definition to the right
side of the formula until it can be simplified down to (general ly speaking) a summation and the base
case(s) that is then simplified. (c) To use the Master Theorem , one verifying that the recurrence
relation is in the correct form, identifies the constants fro m the theorem ( a , b , and d ), determines
which case the formula falls into based on the values of the co nstants, and writes down the answer
based on which case it is. This technique only gives an asympt otic bound on the solution, not an
exact solution.
8.17 (a) They both give an exact formula whereas the Master Theore m only gives an asymptotic
bound. (b) The Master Method is much easier to use than the other two techniques. (c) You need
to be able to determine the answer before you prove it. If the f ormula is complicated, you may not
be able to determine what it is. (d) The main downside is that i t is messy. It also only works well
on simple recurrence relations. For instance, if a recurren ce relation has several recursive terms
(e.g. T ( n ) = T ( n − 1) − 2 T ( n − 3)), it would probably be quite complicated to try to solve it using
iteration. (e) The Master Theorem also only works on one spec ific type of recurrence relation and it
does not give an exact solution. (f) If I don’t care about an ex act solution, the Master Theorem is
by far the easiest, so I would use that one. If I want an exact so lution, I would prefer substitution if
I can see an obvious pattern and find the formula. If I can’t find a formula, I would prefer iteration
because I should be able to work it out using that technique.
8.18 Because the three topics have a lot in common.  Recurrence rel ations are just a form of
recursion, and they can be solved using induction.
8.19 Because recursive algorithms are often analyzed by develop ing and solving recurrence rela-
tions.
8.20 Develop a recurrence relation that describes the running ti me of the algorithm, including one
or more base cases. Use one of the techniques from the previou s section to solve the recurrence
relation.
8.21 Your answer may be different depending on your algorithm.  Howe ver, if your algorithm
does not have a complexity of Θ( n ), you either have an incorrect algorithm (if its complexity is
better than this), a really bad algorithm (if its complexity is worse than this), or you analyzed it
incorrectly.
Let T ( n ) be the time it takes to run search(int[] a, int n, int value) . If n ≤ 0, the
algorithm just returns -1 which takes constant time. So T (0) = 1. If n > = 0, the algorithm checks
one value of the array, which takes constant time, and then ei ther returns or (in the worst case)
makes a recursive call on an array of size n − 1. (technically the array still has size n , but we
are telling the algorithm that it only has size n − 1.) So in this case, T ( n ) = T ( n − 1) + 1. This

Reading Question Solutions 449
one is easy to solve by a variety of techniques. Let’s do it usi ng iteration. First, notice that if
T ( n ) = T ( n − 1) + 1, then if we plug in n − 1 for n , we would get T ( n − 1) = T ( n − 2) + 1.
Therefore, T ( n ) = T ( n − 1) + 1 = ( T ( n − 2) + 1) + 1) = T ( n − 2) + 2. But T ( n − 2) = T ( n − 3) + 1,
so T ( n ) = T ( n − 2) + 2 = ( T ( n − 3) + 1) + 2 = T ( n − 3) + 3. It’s not difficult to see that we can
generalize this to T ( n ) = T ( n − k )+ k . When k = n , we get T ( n ) = T ( n − n )+ n = T (0)+ n = n +1.
So the worst-case performance of the algorithm on an array of size n is n + 1 steps.
9.1 Answers will vary, but here are a few examples. (a) I want to ad opt a dog. At the pet shop,
there are four golden retrievers, two poodles and 5 corgis. H ow many choices do I have if I plan
to adopt one dog? You can choose either a golden retriever (4 o ptions), a poodle (2 options), or a
corgi (5 options). So the total number of choices is 4 + 2 + 5 = 11 .
(b) I go to a restaurant and see that there are 15 dessert choic es, 10 main courses, and 2
appetizers. How many choices do I have if I want to order one of each? You have 15 choices for
desserts, and independent of that you have 10 choices for a ma in course, and independent of both
of those you can choose one of two appetizers. So you have 15 ∗ 10 ∗ 2 = 300 choices.
(c) Your password can be from 4 to 8 lower case alphabetic char acters. How many possibilities
4 are there? There are 26 possible characters. If you use 4 char acters, there are 26 × 26 × 26 × 26 = 26
5 possible passwords. Similarly, with 5 characters there are 26 possible passwords. Likewise, for 6,
6 7 8 7, and 8 characters, there are 26 , 26 , and 26 possible passwords. Since you have to choose one
4 5 6 7 8 of these lengths, the total number of possible passwords is 2 6 + 26 + 26 + 26 + 26 .
9.2 You cannot conclude that a box has at least 3 objects, that two boxes have at least two items,
or that every box has at least one item. (For each of these you c an come up with a distribution of
objects in boxes that does not fit the description.) The most y ou can conclude is that at least one
box has at least 2 objects.
9.3 You might have all 30 balls in one bin. You might have 15 balls i n one bin, and 15 in a second
bin. You might have 1 balls in each of the first 6 bins and 24 in th e 7th bin. You might have 4 balls
in each of the first 6 bins and 6 balls in the 7th bin. You might ha ve 4 balls in each of the first 5
bins, and 5 balls in each of the final two bins. Notice that in al l of these examples, there is at least
one box which has at least ⌈ 30 / 7 ⌉ = 5 balls as guaranteed by the generalized pigeonhole princi ple.
9.4 There are 4 types of discs. Therefore by the generalized pige onhole principle, I know that I
have at least ⌈ 21 / 4 ⌉ = 6 discs of at least one type. But that is all I can say. I do not k now which
type I have at least 6 of. For instance, it is possible all 21 ar e putter, or all 21 are distance drivers,
for instance, so I do not even know if I have a single disc of any type.
9.5 The numbers between 1 and 1000 can all be represented with 10 b its. A number between 1
and 1000 can have between 1 and 10 bits that are 1s. So the 12 num bers can each be placed in one
of 10 “bins” based on how many bits they have in their binary re presentation. Since we are placing
12 numbers in 10 bins, at least one bin has at least 2 numbers. I n other words, two of the numbers
have the same number of 1s in their binary representation. (N one of the numbers can actually have
10 1s because the number with 10 1s is 1023 which is larger than 1000. So technically there are
only 9 bins. But the argument is the same either way. However, if I said that ten people picked
numbers, then we would need to take this into account to solve the problem correctly.)
9.6 Permutations are ordered and combinations are not. More spe cifically, a permutation is a
reordering of objects, whereas a combination is a selection of objects. They are basically completely
different things.
3 9.7 (a) 10 · 10 · 10 = 10 = 1000 (assuming you regard 0 = 000, 12 = 012, etc. as 3 digit num bers).
) ( 10 10 · 9 · 8
= 120. Notice = (b) 10 · 9 · 8 = 720. (c) Because sets cannot have repeats, there are 3 · 2 · 1 3
that there are 6 times as many three-digit numbers with no rep eated digits than sets of three digits
because each set with three digits leads to 6 different three- digit numbers (e.g. the set { 1, 2, 3 } is
the same as the set { 3, 1, 2 } , for instance, but the numbers 123, 132, 213, 231, 312, 321 ar e all

450 Chapter 11
3 different.) (d) Because lists can have repeats, there are 10 · 10 · 10 = 10 = 1000.
9.8 (a) 7!. (b) 5!.
5! 120 9.9 Using Theorem 9.49 , there are = = 30.
2! · 2! · 1! 4
9.10 Choose 5 people who are not on the team.
) ) ( ( 25 · (6 · 4) · 23 25 25 25 · 24 · 23
= = 9.11 = = 25 · 4 · 23 = 2300. 3 22 3 · 2 · 1 6
) ) ( ( 11 11
ways) and then place them into the . (b) 4!. (c) We can choose the 4 members ( 9.12 (a) 4 4
) ( 11
· 4! = 11 · 10 · 9 · 8 = 7920 ways. Alternatively, offices (i.e. order them, so 4! ways) for a total of 4
we have 11 choices for president, and once the president has b een decided there are not 10 choices
for vice-president, then 9 for treasurer, and finally 8 for se cretary, for a total of 11 · 10 · 9 · 8 = 7920
ways of choosing.
9.13 Whether or not order matters, whether or not there are repeti tions, whether or not objects
are distinguishable or not. Ç å Ç å
n n ∑ ∑
n n k n − k n n k 0 1 2
10 1 = (10 + 1) = 11 .  (b) 11 = 1, 11 = 11, 11 = 10 = 9.14 (a)
k k
k =0 k =0
3 4 5 121, 11 = 1331, 11 = 14641, 11 = 161051. (c) The rows of Pascal’s triangle look kind of like
the powers of 11. When the numbers in the triangle are longer t han 1 digit, you have to actually
line them up and add them to get the correct result. But the con nection is more clear when you
consider the formula for the Binomial Theorem and think abou t what it says about a row of the
triangle.
9.15 Plugging in 2 x and − 3 y into the formula, we obtain
Ç Ç Ç Ç å å å å
5 5 5 5 5 0 5 1 4 2 3 3 2
(2 x − 3 y ) = (2 x ) ( − 3 y ) + (2 x ) ( − 3 y ) + (2 x ) ( − 3 y ) + (2 x ) ( − 3 y )
0 1 2 3
Ç å Ç å
5 5 4 1 5 0
+ (2 x ) ( − 3 y ) + (2 x ) ( − 3 y )
4 5
5 4 2 4 3 2 4 5 = − 243 y + 810 x y − 1080 x y + 720 x y − 240 x y + 32 x .
Notice that the negative sign goes inside the parentheses so that it is included in the powers, and
that the constants are also inside the parentheses so they ar e included in the powers. Ç å Ç å
n n ∑ ∑
n n k n − k n n
1 1 = (1 + 1) = 2 , where the second-to-last step uses = 9.16 Notice that
k k
k =0 k =0
the Binomial Theorem.
9.17 Let M be the set of children who took math and C those who took computer science. Notice
that 12 − 4 = 8 children took either math or computer science, Thus, | M | = 6, | C | = 5, and
| M ∪ C | = 8. Therefore, it must be that | M ∩ C | = 6 + 5 − 8 = 3 children took both.
9.18 It is possible that the 4 students who sleep were also late, in which case 13 students did
neither. On the other extreme, the 4 students who slept are al l different than the 7 who came late.
In that case there are 9 students who did neither. So at least 9 and at most 13 students did neither.
9.19 No. There are 7 things on the right side of the equation, so if y ou only have 6 pieces of
information you cannot fully solve the problem.
9.20 | A ∪ B ∪ C ∪ D | = | A | + | B | + | C | + | D |
−| A ∩ B |−| A ∩ C |−| A ∩ D |−| B ∩ C |−| B ∩ D |−| C ∩ D |
+ | A ∩ B ∩ C | + | A ∩ B ∩ D | + | A ∩ C ∩ D | + | B ∩ C ∩ D |
−| A ∩ B ∩ C ∩ D |
10.1 (a) answers will vary. Your graph should have numbers (weigh ts) on every edge, no arrows
on the edges, and can contain loops (edges from a vertex to its elf). (b) answers will vary. You

Reading Question Solutions 451
graph should not have any numbers on the edges, the edges shou ld have arrows, and there may be
repeated edges–that is, there might be two different edges fro m some vertex u to another vertex
v . (c) answers will vary. A network is just a weighted directed graph. So your graph should have
numbers on the edges and every edge should have an arrow. It sh ould not have loops or repeated
edges.
10.2 (a) A road system, where the vertices are intersections and t he edges are the segments of
road between intersections. The weights on the edges might b e distances, speed limits, expected
time to traverse, etc. (b) A ski trail map, where the vertices are intersections and the edges are the
segments of trail between intersections. The edges are dire cted because on som trails you are only
allowed to go one direction. Since sometimes a trail splits a nd comes back together, multiple edges
are allowed between vertices. The weights can be distances o r difficulty ratings. (c) Representing
connections on a social media app, where it is assumed that be ing connected is two-way (e.g. on
Facebook when you are friends versus on Instagram where foll owing is one-way), and where you
are allows to connect to yourself (I actually do not know of a s ocial media site that allows this, but
I suppose it is possible).
10.3 The easiest proof is to realize that edges are just pairs of ve rtices. There are n vertices. How
many ways are there of choosing pairs of vertices? You are cho osing 2 things out of n things, so ) (
n .
2
) ( 2
possible edge, so it holds for Here is a proof by induction: A graph with 2 vertices has 1 = 2
the base case (We could use 1 vertex as a base case, but it is mor e confusing so we start at 2). ) (
k − 1 possible edges. If you add a vertex, it Assume a graph with k − 1 vertices, where k ≥ 3 has
2 ) (
k − 1 + ( k − 1) = can be connected to each of the k − 1 vertices, so a graph with k vertices has
2 ) ) ( ) ( (
( k − 1)( k ) ( k − 1)( k − 2) k k − 2 k − 2+2
= possible edges. Since + ( k − 1) = ( k − 1) + 1 = ( k − 1) = 2 2 2 2 2
the formula is true for k = 2, and whenever it is true for k − 1 it is true for k , it is true for all n ≥ 2
by induction.
10.4 answers will vary, but here are two examples:  | or ⊠ ∧ .
10.5 (a) n − 1. (b) Clearly a tree with 2 vertices has 2 − 1 = 1 edges. Assume all trees with n − 1
vertices have n − 2 edges. Let T be a tree with n > 2 vertices. Since it is a tree, it contains at least
′ ′ one vertex v of degree 1. Let T be the tree T with vertex v deleted. Then T has n − 1 vertices
and is clearly still a tree since removing a vertex of degree 1 cannot either add a cycle or disconnect
′ the graph. Thus T has n − 2 edges. But it was created from T by removing a single vertex and
edge. Therefore T has n − 1 edges. Since the formula holds for n = 2 and whenever it holds for
n − 1 it holds for n , every tree with n ≥ 2 vertices has n − 1 edges.
10.6 (a) unweighted. (b) undirected. (c) e and x are not adjacent, but f and b are adjacent. (d)
L is connected. (e) 8. (f) 17. (g) deg( v ) = 2 and deg( c ) = 5. (h) 34. It is twice the number
of edges which makes sense because of the Handshaking Lemma. (i) answers will vary, but if you
drew a subgraph of L that contains exactly 7 edges and contains no cycles, then it is a spanning
tree. Of course it cannot contain cycles because it is a tree. (j) If you remove ( e , v ) and ( f , v ), then
v is disconnected from the rest of the graph. No single edge wil l disconnect the graph so 2 edges is
the minimum number. (k) answers will vary, but mine are ef v , bcdf , abcdx , axdf ve , aef bcdx , and
finally aevf bcdx . Notice in all of these, the vertices listed next to each othe r are adjacent and the
first and last one on the list are adjacent.
10.7 Here are the graphs for the next 3 questions. The vertices lab els are optional.

452 Chapter 11
1
1 1
2 8 2
6 2
3
7 3
4 5 3
6 4
5 5 4 K C P 6 8 5
10.8 See above.
10.9 See above.
10.10 Notice to draw Q , you can draw two copies of Q (i.e. two lines) and connect corresponding 2 1
vertices (i.e. if you draw the two lines vertically, connect the top vertices and the bottom vertices)
to make a square (notice that Q is the same as C ). To draw Q (a cube), you can draw two 2 4 3
copies of Q (squares) and connect corresponding vertices. Using the sa me idea, to draw Q , I 2 5
would draw 2 copies of Q , and then connect corresponding vertices between the two co pies. 4
10.11 Notice that two vertices are adjacent iff they differ by exactly 1 bit. Also notice that if
two numbers have the same parity, they cannot differ by exactly 1 bit.  So we can pick V = 1
{ 000, 011, 101, 110 } , and V = { 001, 010, 101, 111 } . The numbers in V have even parity, and the 2 1
numbers in V have odd parity. So within each subset, none of the numbers di ffer by exactly one 2
bit since all of the numbers in each set have the same parity. T hus, this is a valid partition.
10.12 Here is K and one possible subgraph. 3,5
1    2    3 1    3
a c e a    c    e b d
a subgraph of K K 3 , 5 3 , 5
10.13 Every edge has two endpoints. Each endpoint adds one to the de gree of the vertex it is
incident with. So if you sum the degree of all of the vertices, it should be twice the number of
edges.
10.14 This is a simple application of the Handshaking Lemma. We cre ate a graph as follows:
People are vertices, and there is an edge between two people i f they have shaken hands. So the
statement would imply that in the graph there are an odd numbe r of vertices of odd degree. This
contradicts Corollary 10.49 (which is a corollary of the Handshaking Lemma). Thus, the fr iend is
incorrect.
10.15 (a) Recall that an adjacency list requires on the order of Θ( n + m ) memory, whereas for
2 the adjacency matrix it would be Θ( n ). If the graph has few edges, then m is much smaller than
2 n , so Θ( n + m ) would be smaller and the adjacency list would be appropriat e. (b) If the number
2 of edges is larger, then either might be appropriate, depend ing on how large. If m ≈ n , then we
2 2 2 are comparing Θ( n + m ) = Θ( n + n ) = Θ( n ) with Θ( n ), so there is minimal difference between
2 the two. But if m is large but smaller than n , the adjacency list might be the better choice.
10.16 If you are storing small graph (e.g.  hundreds of vertices or l ess), it probably does not
matter a whole lot. But imagine storing the Facebook friends hip graph. As of 2021, there are
2.85 billion Facebook users and each has an average of 350 fri ends (as of 2019 it was about 338, so
this number should be close). Since we are talking about exac t numbers, we will compare without
using Θ notation. Recall that an adjacency list takes Θ( n + m ) space and an adjacency matrix
2 2 takes Θ( n ) time. We will just treat these as n + m and n . In our example, n = 2, 850, 000, 000,
and m = 2, 850, 000, 000 ∗ 350 = 997, 500, 000, 000.  So an adjacency list would take about n +
m = 2, 850, 000, 000 + 997, 500, 000, 000 = 1, 000, 350, 000, 000 spa ce. An adjacency matrix would
2 2 take about n = 2, 850, 000, 000 = 8, 122, 500, 000, 000, 000, 000 space. In case it isn’t clear, the

Reading Question Solutions 453
adjacency matrix takes about 8,119,658 times as much space! To be more precise, assuming it takes
32 bits to store each number in an adjacency list or matrix (an d that is pushing it), the adjacency
list requires about 4 TB (terabtyes) of space, which is doabl e if you want to fill up the majority of
the hard drive on a very new top-of-the-line computer. On the other hand, the adjacency matrix
requires about 32.49 EB (exabytes). The largest hard drive y ou can currently buy is about 18 TB,
so you would need about 1,804,369 hard drives to store the adj acency matrix. (Even if you encoded
the matrix densely, using only 1 bit per entry, it would still require about 56,387 hard drives.) So
yes, it does matter.
10.17 (a) Arbitrarily pick either u or v and check its list for the other–we will look at u ’s list. Since
it might have to traverse the entire list of the neighbors of u , it would be O (deg( u )), which might
be as large as n − 1. So O ( n ) in the worst case (although O (deg( u )) is more precise). I use big- O
notation on this one because it is possible it finds it sooner. (b) Either Θ(deg( u )) if it has to traverse
the list and count, or Θ(1) if this is maintained in the data st ructure. (c) Θ(deg( u )) = Θ( k ).
10.18 (a) Θ(1) since it can just look at the ( u , v ) entry of the matrix. (b) Θ( n ) since it has to look
through an entire row of the matrix to determine which vertic es are neighbors. (c) Same answer
and reason as (b).
10.19 (a) Either one works fine, but it is more efficient with an adjace ncy matrix since an edge
( u , v ) can be added and removed in constant time by just changing th e matrix entry ( u , v ) to a 0
or 1. For an adjacency list, to remove ( u , v ), you would have to find u on v ’s list and v on u ’s list
and then remove them from the lists, so it would take longer. ( b) Adjacency list by far. If you add
a vertex, you can just add an adjacency list for it to your curr ent list. With a matrix, you need to
create an entirely new matrix with one more row and column and copy all of the entries, so it is
not very efficient. Similar problems exist when removing vert ices.
10.20 (a) Since every vertex of K has degree 4, it is Eulerian by Theorem 10.67 . (b) Since every 5
10.67 . (c) Since every vertex of Q has vertex of K has degree 5, it is not Eulerian by Theorem 3 6
10.67 . (d) Since every vertex of Q has degree 4, it is degree 3, it is not Eulerian by Theorem 4
10.67 .  Here is one of many possible orderings of the edges that form an Eulerian by Theorem
Eulerian tour:

454 Chapter 11
1111 1101 22
21 23
14 18
1011 1001 31
0101 0111 13 32 20
5 19
0001 0011 15 17 1
6 12
4 2
0100 0110 11
24 30
7 27
0000 0010 3 10 28
1100 1110 16
8 26
9 29
25 1010 1000
(e) and (f) are both are Hamiltonian. Here is one possible Ham iltonian cycle for each:
1111 1101
1011 1001
0101 0111
0001 0011
101 111
0100 0110
001 011 0000 0010
1100 1110
100 110
1010 1000 000 010
(g) Yes. Since it is just a cycle with all of the vertices, it is clearly a Hamiltonian cycle.

Reading Question Solutions 455
10.21 Here is the most obvious way to draw it:
10.22 It is not saying that. No planar graphs have more edges than th at, but not every graph
with fewer edges is planar. For instance, K has v = 6 and e = 9. So e = 9 < 12 = 3 v − 6, but as 3,3
we saw earlier, K is not planar. 3,3
10.23 (a) I am too lazy to do another drawing, but draw it as a box insi de a box with the corners
connected to each other and it is clearly planar. (b) Notice t hat v = 16, e = 32, and C is not a 3
subgraph of Q . Then e = 32 > 28 = 2 v − 4, so by part (b) of Theorem 10.77 , Q cannot be planar. 4 4

456 Chapter 11

Chapter 12: Exercise Solutions
2.3 (a) false. (b) true. (c) false. If you don’t know the story beh ind this, Google it.
2.5 (a) Not a proposition. (b) I would like to think this is true. H owever, this is not a proposition
since not everyone agrees with me. (c) Also not a proposition . (d) true. (e) false. This one is a bit
tricky to think about it, so the next example will ask you to pr ove it.
2.9 “I am not learning discrete mathematics.” You could also hav e “It is not the case that I am
learning discrete mathematics,” although it is better to sm ooth out the English when possible.;
False. Since you are currently reading the book, you are learning discrete mathematics.
2.13 Either “I like cake and I like ice cream,” or “I like cake and ic e cream” are correct.
2.16 “ x > 0 or x < 10”; true; true; x < 10; true.
2.17 (a) “It is not the case that Jill is tall,” which is awkward, so could be shorted to “Jill is not
tall” or perhaps “Jill is short.” (b) “Jill is tall or Jill is s mart,” or more compactly, “Jill is tall or
smart.” (c) “Jill is tall and Jill is smart,” or more compactl y, “Jill is tall and smart.” (d) “Jill is
tall and Jill is not smart.” (e) This one is a bit tricky, and we will see a tool shortly that will make
it easier. But for now, hopefully you can see that is would be “ it is not the case that Jill is tall and
Jill is smart.” Notice that an incorrect answer would be “Jill is neither tall nor smart.” We will
see why later.
2.20 (a) XOR; (b) OR. This one is a little tricky because parts can’ t be simultaneously true so it
sounds like an XOR. But since the point of the statement is not to prevent both from being true,
it is an OR. (c) Without more context, this one is difficult to an swer. I would suspect that most
of the time this is probably OR. The purpose of this example is to demonstrate that sometimes
life contains ambiguities. This is particularly true with s oftware specifications. Generally speaking,
you should not just assume one of the alternative possibilities. Instead, get the ambiguity clarified.
(d) When course prerequisites are involved, OR is almost cer tainly in mind. (e) The way this is
phrased, it is almost certainly an XOR.
2.21 p ∨ q is “either list 1 or list 2 is empty.” To be completely unambig uous, you could rephrase
it as “at least one of list 1 or list 2 is empty.” p ⊕ q is “either list 1 or list 2 is empty, but not both,”
or “precisely one of list 1 or list 2 is empty.” They are differen t because if both lists are empty,
p ∨ q is true, but p ⊕ q is false.
2.22 (a) No. If p and q are both true, then p ∨ q is true, but p ⊕ q is false, so they do not mean
the same thing. For example, consider when x = 10. In this case, p ∨ q is true, but p ⊕ q is false.
(b) We have to be very careful here. In general, the answer to t his would be absolutely not (we’ll
discuss this more next). However, for this particular p and q , they actually essentially are the same.
But the reason is that it is impossible for x to be less than 5 and greater than 15 at the same time.
In other words, p and q can’t both be true at the same time. The only other way for p ⊕ q to be
false is if both p and q are false, which is exactly when p ∨ q is false.
2.26 (a) An A. This is pretty obvious since we earned 94% and if we ea rn 94%, then we will get
an A. (b) We can’t be sure. We know that earning 94% is enough fo r an A, but we don’t know
whether or not there are other ways of earning an A. (c) We can’ t be sure. If the premise is false,
we don’t know anything about conclusion.
2.30 (a) An A. (b) Yes. Because it is a biconditional statement tha t we assumed to be true, the
statements “you will receive an A in the course” and “you earn at least 94%” have the same truth
value. Since the former is true, the latter has to be true. (c) Yes. Notice that p ↔ q is equivalent
to ¬ p ↔¬ q (You should convince yourself that this is true). Thus the st atements “you don’t earn
at least 94%” and “you didn’t get an A” have the same truth valu e.
457

458 Chapter 12
2.32 The answers are in bold .
With Variables/Operators In English
p → q If Iron Man is on TV, then I will watch it.
( ¬ r ∧ p ) → q If I don’t own Iron Man on DVD and it is on TV, I will
watch it.
p ∧ r ∧¬ q Iron Man is on TV and I own the DVD, but I
won’t watch it.
q ↔ p I will watch Iron Man every time it is on TV, and that
is the only time I watch it.
r → q I will watch Iron Man if I own the DVD.
2.35 Here is the truth table with one (optional) intermediate col umn.
p   q p → q ( p → q ) ∧ q
T   T T T
T   F F F
F   T T T
F   F T F
2.37 Here is the truth table with two intermediate columns. For co nsistency, your table should
have the rows in the same order.
a b c ¬ b a ∨¬ b ( a ∨¬ b ) ∧ c )
T    T    T F T T
T    T    F F T F
T    F    T T T T
T    F    F T T F
F    T    T F F F
F    T    F F F F
F    F    T T T T
F    F    F T T F
2.40 ( a ∧ b ) ∨ c
2.41 They are not equivalent. For instance, when a = F , b = F , and c = T , ( a ∧ b ) ∨ c is true but
a ∧ ( b ∨ c ) is false.
2.42 Since ( a → b ) → c is how it should be interpreted, the first statement is correc t. The second
statement is incorrect. We’ll leave it to you to find true valu es for a , b , and c that result in these
two parenthesizations having different truth values.
2.45 (a) tautology (b) contradiction; p and ¬ p cannot both be true. (c) contingency; it can be
either true or false depending on the truth values of p and q .
2.47
Evaluation of Proof 1:  Nice truth table, but what does it mean ? It is just a bunch of symbols
on a page. Why does this truth table prove that the propositio n is a tautology? The proof
needs to include a sentence or two to make the connection betw een the truth table and the
proposition being a tautology.
Evaluation of Proof 2:  This is mostly correct, but the phrasi ng could be improved. For instance,
the phrase ‘they all return true’ is problematic. Who/what a re ‘they’? And what does it
mean that they ‘return’ true? Propositions don’t ‘return’ a nything. Replace ‘Since they all
return true’ with ‘Since every row of the table is true’ and th e proof would be good.

Exercise Solutions 459
Evaluation of Proof 3:  While I applaud the attempt at complet eness, this proof is way too compli-
cated. It is hard to understand because of the incredibly lon g sentences and the mathematical
statements written in English in the middle of sentences. Bu t I suppose that technically speak-
ing it is correct. Here are a few specific examples of problems with the proof (not exhaustive).
The first three sentences are confusing as stated. The point t hat the author is trying to make
is that whenever q is true, the statement must be true regardless of the value of p , so there is
nothing further to verify. Thus the only case left is when q is false. This point could be made
with far few words and more clearly. The phrase ‘we would have true and (true implies false),
which is false,’ is very confusing, as are a few similar state ments in the proof. The problem
is that the writer is trying to express mathematical stateme nts in sentence form instead of
using mathematical notation. There is a reason we learn math ematical notation–to use it!
Evaluation of Proof 4:  This proof is correct and is not too diffi cult to understand. It is a lot better
than the previous proof for a few reasons. First of all, it sta rts off in a better place–focusing
in on the single case of importance. Second, it uses the appro priate mathematical notation
and refers to definitions and previous facts to clarify the ar gument.
Evaluation of Proof 5:  While I appreciate the patriotism (in case you don’t know, some people
use ‘merica as a shorthand for America), this has nothing to d o with the question. Sorry, no
points for you! By the way, I did not make this solution up. Although it wasn’t really used on
this particular problem, one student was in the habit of givi ng answers like this if he didn’t
know how to do a problem.
2.51 Below is the truth table for ¬ ( p ∧ q ) and ¬ p ∨¬ q (the gray columns).
p q p ∧ q ¬ ( p ∧ q ) ¬ p ¬ q ¬ p ∨¬ q
T    T T F F F F
T    F F T F T T
F    T F T T F T
F    F F T T T T
Since they are the same for every row of the table, ¬ ( p ∧ q ) = ¬ p ∨¬ q .
2.53
p = p ∧ T (identity)
= p ∧ ( p ∨¬ p ) (negation)
(distributive) =  ( p ∧ p ) ∨ ( p ∧¬ p )
=  ( p ∧ p ) ∨ F (negation)
= p ∧ p (identity )
Thus, p ∧ p = p .
2.55 (a) We can use the identity, distributive, and dominations l aws to see that
p ∨ ( p ∧ q ) = ( p ∧ T ) ∨ ( p ∧ q ) = p ∧ ( T ∨ q ) = p ∧ T = p .
(b) We can prove this similarly to the previous one, or we can u se the previous one along with
distribution and idempotent laws:
p ∧ ( p ∨ q ) = ( p ∧ p ) ∨ ( p ∧ q ) = p ∨ ( p ∧ q ) = p .
2.57 (a) p ⊕ q ; (b) ( p ∧¬ q ) ∨ ( ¬ p ∧ q ) or ( p ∨ q ) ∧¬ ( p ∧ q ). Other answers are possible, but most
likely you came up with one of these. If not, construct a truth table to determine whether or not
your answer is correct.
2.59

460 Chapter 12
Evaluation of Proof 1:  This is an incomplete proof. It only pr oves that in one case ( p and q both
being true) they are equivalent. It says nothing about, for i nstance, whether or not they have
the same truth value when p is true and q is false.
Evaluation of Proof 2:  This proof is also incomplete. It prov es that in two cases they have the
same truth value, but is silent about the other cases. Are we s upposed to assume that in all
other cases the expressions are both false?
Evaluation of Proof 3:  This is either incomplete or incorrec t, depending on how you read it. If by
“precisely” the writer means “exactly when”, then it is inco rrect since the propositions are
also true when both p and q are false. Otherwise the proof is incomplete because it does not
deal with every case.
Evaluation of Proof 4:  This is correct because it exhausts al l of the cases. It is perhaps a bit brief,
however. The only way I know the proof is actually correct is t hat I have to verify what the
writer said. By the definition of p ↔ q , what they said is clearly true. But to see that it
is true of ( p ∧ q ) ∨ ( ¬ p ∧¬ q ) I have to actually plug in a few values and/or think about the
meaning of the expression.
2.63 (a) is a predicate since it can be true or false depending on th e value of x .; (b) is not a
predicate since it is simply a false statement–it doesn’t co ntain any variables.; (c) is a predicate
since it can be true or false depending on the value of M .; (d) is not a predicate. This one is tricky.
This is a definition. In this statement, x is not a variable but a label for a number so that it can
be referred to later in the sentence.
2.67
(a) ∀ x (2 x < 3 x ). In case it isn’t obvious, there is nothing magical about x . You could also write
your answer as ∀ a (2 a < 3 a ), for instance.
n (b) ∀ n ( n ! < n ).
2 2 2.70 ∀ x 6 = 0( x 6 = 0). Alternatively, ∀ x ( x 6 = 0 → x 6 = 0).
2.73 ∃ x ( x > 0).
2.75
Evaluation of Solution 1:  While perhaps technically correc t, this solution is not very good. It at
least uses a quantifier. But the fact that it includes the phra se “is even” suggests that it
could be phrased a bit more ‘mathematically.’
Evaluation of Solution 2:  This solution is pretty good. It is concise, but expresses the idea with
mathematical precision. Although it doesn’t directly appe al to the definition of even, it does
use a fact that we all know to be true of even numbers.
Evaluation of Solution 3:  This solution is also good. It clea rly uses the definition of even. It is
a bit more complicated since it uses two quantifiers, but I pre fer this one slightly over the
second solution. But that may be because I didn’t come up with the second solution and I
refuse to admit that someone had a better solution than what I thought of (which was this
one).
2 2 2.77 ∀ x ∃ y ∃ z ( x = y + z ).
2.78 You may have a different answer, but here is one possibility bas ed on the hint. If we let
P ( x , y ) be x < y where the domain for both is the real numbers, then ∀ x ∃ y ( x < y ) is true since for

Exercise Solutions 461
any given x , we can choose y = x + 1. However, ∃ y ∀ x ( x < y ) is false since no matter what value
we pick for y , x < y is false for x = y + 1. In other words, it is not true for all values of x . As with
the previous examples, the difference is that in this case we ne ed to have a single value of y that
works for all values of x .
2.82
(a) It is saying that every integer can be written as two times another integer. Simplified, it is
saying that every integer is even.
(b) The most direct translation of the final line of the soluti on is “There is some integer that cannot
be written as two times another integer for any integer.” A sm oothed-out translation would be
“There is at least one odd integer.”
(c) Since 3 is odd, the statement is clearly false.
2.85 ¬ p , q , and r .
2.89 ¬ p , q , p ∧ q ∧ r , ¬ p ∧ q , r , ¬ r ∧ p ∧ q .
2.92 ¬ p , q ∨ r , ¬ q ∧ r , p ∧ q ∧ r , ¬ r ∧ p ∧ q , ( p ∧¬ r ) ∨ ( r ∧ q ) ∨ ( ¬ q ∧ p ), ( p ∧¬ r ) ∨ ( r ∧ q ) ∨ ( ¬ q ∧ p ∧ r )
2.95 The truth table for p ↔ q is given to the right.  The first
p q p ↔ q row yields conjunctive clause p ∧ q , and the fourth row yields
T    T T conjunctive clause ¬ p ∧¬ q . The disjunction of these is ( p ∧
T    F F q ) ∨ ( ¬ p ∧¬ q ). Thus, p ↔ q = ( p ∧ q ) ∨ ( ¬ p ∧¬ q ).
F    T F
F    F T
2.97 Y = ( p ∧ q ∧¬ r ) ∨ ( ¬ p ∧ q ∧ r ) ∨ ( ¬ p ∧¬ q ∧ r ) ∨ ( ¬ p ∧¬ q ∧¬ r ).
3.4 2 d + 1; c + d + 1; even
3.6 2 n ; 2 o + 1; some integers n and o ; 4 no + 2 n = 2(2 no + n ) or 2( n (2 o + 1)). (Your steps might
vary slightly, but you should end up with either 2(2 no + n ) or 2( n (2 o +1)) in the final step); 2 no +1
or n (2 o + 1); ‘an even integer’ or ‘even’.
3.7 Let a and b be even integers. Then a = 2 m and b = 2 n for some integers m and n . Their
product is ab = (2 m )(2 n ) = 2(2 mn ) which is even since 2 mn is an integer. Notice that we used two
different letters here! You cannot assume a = 2 n and b = 2 n because then you are assuming that
a = b whether or not you realize it!
3.8 Here are my comments on the proof.
• The first sentence is phrased weird–we are not letting a and b be odd by the definition of odd.
We are using the definition.
• It does not state that n and q need to be integers.
• Although it is not incorrect, using n and q is just weird in this context. It is customary to
use adjacent letters, like n and m , or q and r .
• Given the above problems, I would rephrase the first sentence as ‘Let a and b be an odd
numbers. Then a = 2 n + 1 and b = 2 m + 1 for some integers n and m .’
• There is an algebra mistake. The product should be 2(2 nq + q + n ).
• If you replace 2 nq + 1 with 2 nq + q + n (twice) in the last sentence (see the previous item) it
would be a perfect finish to the proof.

462 Chapter 12
3.9 Hopefully it is clear to you that the proof can’t be correct since the sum of an even and an
odd number is odd, not even. The algebra is correct. The problem is that n + m + 1 / 2 is not an
integer. In order to be even, a number must be expressed in the form 2 k where k is an integer .
Any number can be written as 2 x if we don’t require that x be an integer, so you cannot say that
a number is even because it is of the form 2 x unless x is an integer.
2 3.13 a an integer; (3 x + 2); (5 x − 7);7; 7 divides 15 x − 11 x − 14.
3.15 This proof is correct. Not all of the Evaluate problems have a n error!
3.17 The number 2 is positive and even but is clearly not composite since it is prime. Since the
statement is false the proof must be incorrect. So where is th e error? It is in the final statement.
Although a can be written as the product of 2 and k , what if k = 1 (that is, a = 2). In that case
we have not demonstrated that a has a factor other than a or 1, so we can’t be sure that it is
composite.
3.18 If you didn’t get, try this hint before reading the rest of the solution: Assume a is an even
number other than 2 and prove that a is composite.
Let a > 2 be an even integer. Then a = 2 k for some integer k . Since a 6 = 2, a has a factor other
than a or 1. Therefore a is not prime. Therefore 2 is the only even prime number.
3.19 It was O.K. because according to the definition of prime, only positive integers can be prime.
Therefore we only needed to consider positive even integers .
3.23 This one has a combination of two subtle errors. First of all, if a | c and b | c , that does not
necessarily imply that ab | c .  For instance, 6 | 12 and 4 | 12, but it should be clear that 6 · 4 ∤ 12.
Second, what if a = b ? We’ll see how to fix the proof in the next example.
3.25 Since n is not a perfect square, we know that a 6 = b .  Therefore a < b or b < a .  Since
a and b are just labels for two factors of n , it doesn’t matter which one is larger.  So we can
just assume a is the smaller one without any loss of generality.  By definiti on of composite, we
know that a > 1.  Finally, it should be pretty clear that b < n − 1 since if b = n − 1, then
n = ab = a ( n − 1) ≥ 2( n − 1) = 2 n − 2 = n + ( n − 2) > n since n > 4. But clearly n > n is
impossible.
2 3.26 We assumed that n = a > 4, so clearly a > 2.
3.28
1. Experiment . If you aren’t sure what to do, don’t be afraid to try things.
2. Read Examples . But don’t just read. Make sure you understand them.
3. Practice . It makes perfect!
3.32 Only when you read xkcd and you don’t laugh.
3.33 If you build it and they don’t come, the proposition is false. This is the only case where it
is false. To see this, notice that if you build it and they do co me, it is true. If you don’t build it,
then it doesn’t matter whether or not they come–it is true.
3.35 If you don’t know a programming language, then you don’t know Java.
3.37 true; ¬ p ; false; p ; p is true; q is false (the last two can be in either order).
3.39 If you don’t know Java, then you don’t know a programming lang uage.
3.40 They are not equivalent. Since Java is a programming language, the propo sition seems obvi-
ously true. However, what if someone knows C++ but not Java? T hen they know a programming
language but they don’t know Java. Thus, the inverse is false . Since one is true and the other is
false, the proposition and its inverse are clearly not equiv alent.
3.42 If you know a programming language, then you know Java.

Exercise Solutions 463
3.43 They are not equivalent. Since Java is a programming language, the propo sition seems obvi-
ously true. However, what if someone knows C++ but not Java? T hen they know a programming
language but they don’t know Java. Thus, the converse is fals e. Since one is true and the other is
false, the proposition and its converse are clearly not equi valent.
3.46 (a) The implication states that if I get to watch “The Army of D arkness” that I will be
happy. However, it doesn’t say that it is the only thing that w ill make me happy. For instance, if
I get to see “Iron Man” instead, that would also make me happy. Thus, the inverse statement is
false.
(b) I will use fact that p → q is true unless p is true and q is false. The implication is true unless
I watch “The Army of Darkness” and I am not happy. The contrapo sitive is “If I am not happy,
then I didn’t get to watch ‘The Army of Darkness.’ ” This is tru e unless I am not happy and I
watched “The Army of Darkness.” Since this is exactly the sam e cases in which the implication
are true, the implication and its contrapositive are equiva lent. √ √
3.49 35; 10 35; 3481 ≥ 3500; nonsense or false or a contradiction .
3.50
Evaluation of Proof 1:  Here are my comments on this proof:
• It is proving the wrong thing. This proves that the product of an even number and an
odd number is even. But it doesn’t even do that quite correctl y as we will see next.
• The first sentence is phrased weird–we are not letting a be even by the definition of even.
We are using the definition.
• It does not state that n and q need to be integers.
• Although it is not incorrect, using n and q is just weird. It is customary to use adjacent
letters, like n and m , or q and r .
• Given the above problems, I would rephrase the first sentence as ‘Let a be an even
number and b be an odd number. Then a = 2 n and b = 2 m + 1 for some integers n and
m .’
• There is an algebra mistake. The product should be 2(2 nq + n ).
• The last sentence is actually perfect (again, except for the fact that it isn’t proving the
right thing).
Evaluation of Proof 2:  This proof is incorrect. It actually p roves the converse of the statement.
(We’ll learn more about converse statements later.) In othe r words, it proves that if at least
of one of a or b is even, then ab is even. This is not the same thing. It is a pretty good proof
of the wrong thing, but it can be improved in at least 4 ways.
• It defines a and b but never really uses them. They should be used at the beginni ng
of the algebra steps (i.e. a · b = ··· ) to make it clear that the algebra is related to the
product of these two numbers.
• It needs to state that k and x are integers.
• As above, using k and x is weird (but not wrong). It would be better to use k and l , or
x and y .
• It needs a few words to bring the steps together. In particula r, sentences should not
generally begin with algebra.
Taking into account these things, the second part could be re phrased as follows.

464 Chapter 12
Let a = 2 n and b = 2 m +1, where n and m are integers. Then ab = (2 n )(2 m +1) =
4 nm + 2 n = 2(2 nm + n ), which is even since 2 nm + n is an integer.
Evaluation of Proof 3:  This proof is correct.
3.54 (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), and (3, 2, 1).
3.56 Since it wasn’t obvious how to do a direct proof of the fact, pr oof by contradiction seemed
like the way to go. So we begin by assuming what we want to prove (that the product is even) is
false. The short answer: Because contradiction proofs generally begin by assuming t he negation of
what you want to prove.
3.57 The proof gives the justification for this, but you may have to think about it for it to entirely
sink in. Consider carefully the definition of S : S = ( a − 1)+( a − 2)+ ··· +( a − n ). Notice it adds 1 2 n
and subtracts terms. If S = 0, then the amount added and subtracted must be the same. And if
you think about it for a few minutes, especially in light of th e justification given in the proof, you
should see why. If you can’t see it right away, go back to how th e a ’s are defined and think a little k
more. If you get totally stuck, try an example with n = 3 or 4.
2 2 2 3.60 Because a = a · a , so to list the factors of a you can list the factors of a twice. Thus, a
has twice as many factors as a , so it must be an even number.
3.63 (1) No. (2) Yes. (3) No. (4) No. (5) Statements of the form “ p implies q ” are false precisely
when p is true and q is false. (6) No. Whether or not you are 21, you aren’t breakin g the rule.
(7) No. If p is false, whether or not q is true or false doesn’t matter–the statement is true. Let’s
consider the previous question–if you do not drink alcohol, you are following the rule regardless of
whether or not the statement “you are 21” is true or false.
a − b a b a b a a − b ; ; b + − = + ; subtract from both sides and multiple both sides by 2; 3.64 a > b ;
2 2 2 2 2 2 2
a > b ; contradiction; a ≤ b .
Ä Ä ä ä 2
p p 2 2 2 3.66 a + b + c ; multiple both sides by q ; odd; 0; ap + bpq is even and cq is odd, so
q q
2 2 2 2 2 2 2 ap + bpq + cq is odd; bpq + cq is even and ap is odd, so ap + bpq + cq is odd; ax + bx + c = 0
does not have a rational solution if a , b , and c are odd.
3.70
Evaluation of Proof 1:  This is attempting to prove the converse , not the contrapositive. Since the
converse of a statement is not equivalent to the original sta tement, this is not a valid proof.
Further, the proof contains an algebra mistake. Finally, it uses the property that the sum of
two even integers is even. Although this is true, the problem specifically asked to prove it
using the definition of even/odd.
Evaluation of Proof 2:  This proof starts out correctly by usi ng the contrapositive statement and
6
k + 1) is ‘clearly odd.’ This the definition of odd. Unfortunately, the writer claims that 5(
5
is not at all clear. What about this number makes it odd? Is it e xpressed as 2 a + 1 for some
integer a ? No. Even worse, there is a fraction in it, obscuring the fact that the number is
even an integer.
Evaluation of Proof 3:  This proof is really close . The only problem is that we don’t know that
6 k + 5 is odd using the definition of odd . All the writer needed to do is take their algebra a
little further to obtain 2(3 k + 2) + 1, which is odd by the definition of odd since 3 k + 2 is an
integer.
3 3.76 Answers will vary greatly, but one proof is: 3 and 5 are prime b ut 3 + 5 = 8 = 2 is clearly
not prime.

Exercise Solutions 465
r r − 1 r r +1 3.79 2 s is a power of two that is in the closed interval.; 2 = 2 · 2 < 2 s < 2 · 2 = 2 , so
r r +1 r s < 2 < 2 s < 2 , and so the interval [ s , 2 s ] contains 2 , a power of 2.
3.80 Because these statements are contrapositives of each other . In other words, they are equiva-
lent. Therefore you can prove either form of the statement.
3.82 If x is odd, then x = 2 k + 1 for some integer k . Then x + 20 = 2 k + 1 + 20 = 2( k + 10) + 1,
which is odd since k + 10 is an integer. If x + 20 is odd, then x + 20 = 2 k + 1 for some integer k .
Then x = ( x + 20) − 20 = 2 k + 1 − 20 = 2( k − 10) + 1, which is odd since k − 10 is an integer.
Therefore x is odd iff x + 20 is odd.
3.83 If x is odd, then x = 2 k + 1 for some integer k . Then x + 20 = 2 k + 1 + 20 = 2( k + 10) + 1,
which is odd since k + 10 is an integer.  If x is even, then x = 2 k for some integer k .  Then
x + 20 = 2 k + 20 = 2( k + 10). Since k + 10 is an integer, then x + 20 is even. Therefore x is odd
iff x + 20 is odd.
3.84 p implies q ; q implies p ; p implies q ; ¬ p implies ¬ q
3.85
Evaluation of Proof 1:  For the forward direction, they didn’ t use the definition of odd. Otherwise,
that part is fine. For the backward direction, their proof is n onsense. They assumed that
x = 2 k + 1 when they wrote (2 k + 1) − 4 in the second sentence. This need to be proven .
Evaluation of Proof 2:  For the forward direction, they didn’ t specify that k was an integer. Oth-
erwise it is correct. The second part of the proof is not proving the converse. It is proving the
forward direction a second time using a proof by contraposit ion. In other words, this proof
just proves the forward direction twice and does not prove th e backward direction.
3.87 This only proves that 4 + 6 is even. It says nothing about the su m of any other two even
numbers.
3.89 The problem is that this is actually a proof that x + x is even if x is even since x = 2 a = y
was assumed.
3.90 Notice that 4 and 6 are even, but 4 + 6 = 10 is not divisible by 4. S o clearly the statement
is incorrect. Therefore, there must be something wrong with the proof. The problem is the same
as in the previous example–the proof assumed x = y , even if that was not the intent of the writer.
So what was proven was that if x is even, then x + x is divisible by 4.
3.91 Since it should be clear that the result ( − 1 = 1) is false, the proof can’t possibly be correct.
3.92 No! Example 3.91 should have made it clear that this approach is flawed.
3.93 No, you should not be convinced. As we just mentioned, whethe r or not the equation is true,
sometimes you can work both sides to get the same thing. Thus t he technique of working both
sides is not valid. It doesn’t guarantee anything unless you already know that the equation is valid.
p + q
is an integer. But p < q 3.94 Since p and q are odd, we know that p + q is even, and so
2
p + q
gives 2 p < p + q < 2 q and so p < < q , that is, the average of p and q lies between them.
2
Since p and q are consecutive primes, any number between them is composit e, and so divisible by ) (
p + q
is divisible by the prime 2 and by at least two other at least two primes. So p + q = 2
2
p + q
primes dividing .
2
3.95
y Evaluation of Proof 1:  This is not correct. It needs to be show n that x can be written as c/d ,
y y where c and d are integers with d 6 = 0. Ask yourself this: Are a and b necessarily integers?

466 Chapter 12
Evaluation of Proof 2:  This is not correct. If y = 3 / 2, what does it mean to multiple x by itself
one and a half times?
3.96 The statement is false. There are many counterexamples, but here is an easy one: Let x = 2 √
y 1 / 2 2, which is irrational. and y = 1 / 2. Then x = 2 =
3.97
Evaluation of Proof 1:  This solution has two serious flaws. Fi rst, we absolutely cannot assume x
is an integer. The only thing we can assume about x is that it is rational, and not every
rational number is an integer. The other problem is that the w riter proved the inverse , not
the contrapositive . What they needed to prove was that if 1 /x is rational, then x is rational.
So in actuality, we know is that 1 /x is rational, not x . We need to prove that x is rational
based on the assumption that 1 /x is rational.
Evaluation of Proof 2:  This is not really a proof. It just take s the statement of the problem one
step further. Is the writer sure that 1 /x can’t be expressed as an integer over an integer?
Why? There are just too many details omitted.
Evaluation of Proof 3:  The biggest flaw is that this is a proof o f the inverse statement, not the
contrapositive . So even it the rest of the proof were correct, it would be prov ing the wrong
thing since the inverse and contrapositive are not equivalent. But the rest is not even entirely
correct because the inverse statement is not quite true. If x = 0, then p = 0 as well and the
statement and proof falls apart for the same reason–you can’ t divide by 0.
Evaluation of Proof 4:  This proof is almost correct . It does correctly try to prove the contrapos-
itive, and if it had done so correctly, that would imply the or iginal statement is true. But
there is one small problem: If a = 0 the proof would fall apart because it would divide by 0.
This possibility needs to be dealt with. This is actually not too difficult to fix. We just need
to add the following sentence before the last sentence: “Since 0 6 = 1 /x for any value of x , we
know that a 6 = 0 .”.
Evaluation of Proof 5:  This proof is correct.
3.98
Evaluation of Proof 1:  As you will prove next, the statement i s actually false. Therefore the proof
has to be incorrect. But where did it go wrong? It turns out the y they tried to prove the wrong
p thing. What needed to be proved was “If p is prime then 2 − 1 is prime.” They attempted
to prove the converse statement, which is not equivalent. We can still learn somet hing by
evaluating their proof. It turns out that the converse is act ually true, and the proof has a
lot of correct elements. Unfortunately, they are not put tog ether properly. First of all, the
proof seems to be a combination of a contradiction proof and a proof by contrapositive. They
needed to pick one and stick with it. Second, the arrows ( → ) are confusing. What do they
mean? I think they are supposed to be read as “implies”, but a f ew more words are needed to
make the connections between these phrases. Finally, the fin al statement is incorrect. This
p does not prove that all numbers of the form 2 − 1 are prime when p is prime.
Evaluation of Proof 2:  This proof is not even close. This is a c ase of “I wasn’t sure how to prove it
p so I just said stuff that sounded good.” You can’t argue anythi ng about the factors of 2 − 1
p p based on the factors of 2 . Further, although 2 − 1 being odd means 2 is not a factor, it
doesn’t tell us whether or not the number might have other factors.

Exercise Solutions 467
11 3.99 Notice that 11 is prime but that 2 − 1 = 23 · 89 is not. Therefore, not all numbers of the
p form 2 − 1, where p is prime, are prime.
4.5 The prime numbers less than 10 are 2, 3, 5, and 7. But the proble m asked for the set of
prime numbers less than 10. Therefore, the answer is { 2, 3, 5, 7 } . If you were asked to list the prime
numbers less than 10, an appropriate answer would have been 2 , 3, 5, 7 (but that is not what was
asked). The cardinality of the set is 4. That is, |{ 2, 3, 5, 7 }| = 4.
4.8 6; 5; 6; A and C represent the same set. That is, A = C .
4.11 ∞ ; ∞ .  You might think it is ∞ / 2, but you can’t do arithmetic with ∞ since it isn’t a
+ number. Without getting too technical, although Z seems to have about half as many elements
as Z , it actually doesn’t. It has the exact same number: ∞ . ; 0.
4.14 { 2 a : a ∈ Z } and { . . . , − 4, − 2, 0, 2, 4, . . . } .
4.17 Q = { a/b : a , b ∈ Z , b 6 = 0 } .
4.20 (a) Yes. (b) Yes. A is a proper subset since 25, for instance, is in S but not in A . (c) Yes.
Every set is a subset of itself. (d) No. No subset is a proper subset of itself. (e) No. 25 ∈ S , but
25 6∈ A .
4.21 (a) yes. Any number that is divisible by 6 is divisible by 2.; ( b) yes. Any number that is
divisible by 6 is divisible by 3.; (c) no. 4 ∈ B , but 4 6∈ A .; (d) no. 4 ∈ B , but 4 6∈ C .; (e) no. 3 ∈ C ,
but 3 6∈ A .; (f) no. 3 ∈ C , but 3 6∈ B .
4.24 We will use the result of example 4.23 . A subset of { a , b , c , d } either contains d or it does
not. Since the subsets of { a , b , c } do not contain d , we simply list all the subsets of { a , b , c } and
then to each one of them we add d . This gives
S = ∅ S = { d } 1 9
S = { a } S = { a , d } 2 10
S = { b } S = { b , d } 3 11
S = { c } S = { c , d } 4 12
S = { a , b } S = { a , b , d } 5 13
S = { b , c } S = { b , c , d } 6 14
S = { a , c } S = { a , c , d } 7 15
S = { a , b , c } S = { a , b , c , d } 8 16
4.27 Based on the answer to Exercise 4.24 , we have that P ( { a , b , c , d } ) = { ∅ , { a } , { b } , { c } , { a , b } ,
{ b , c } , { a , c } , { a , b , c } , { d } , { a , d } , { b , d } , { c , d } , { a , b , d } , { b , c , d } , { a , c , d } , { a , b , c , d }} . Notice that a
list of these 16 sets not separated by commas and not enclosed in {} is not correct. It may have
the correct content , but it is not in the proper form .
4 16 4.29 (a) By Theorem 4.28 , | P ( A ) | = 2 = 16. (b) Similarly, | P ( P ( A )) | = 2 = 65536. (c) This is
65536 just getting a bit ridiculous, but the answer is | P ( P ( P ( A ))) | = 2 .
4.30 Applying Theorem 4.28 , it is not too hard to see that the power set will be twice as big after
a single element is added.
4.33 Z , or the set of (all) integers.
4.36 ∅ .
4.39 A ; B .
4.43 B ; A .
4.47 Since no integer is both even and odd, A and B are disjoint.
4.49 Let E be the set of all English speakers, S the set of Spanish speakers and F the set of

468 Chapter 12
French speakers in our group.  We fill-up the Venn
F
diagram (to the right) successively. In the intersection
of all three we put 3. In the region common to E and
1
S which is not filled up we put 5 − 3 = 2. In the region
2 4
common to E and F which is not already filled up we
3
put 5 − 3 = 2.  In the region common to S and F
1 3 E S
which is not already filled up, we put 7 − 3 = 4. In the
2 remaining part of E we put 8 − 2 − 3 − 2 = 1, in the
remaining part of S we put 12 − 4 − 3 − 2 = 3, and
in the remaining part of F we put 10 − 2 − 3 − 4 = 1.
Therefore, 1 + 2 + 3 + 4 + 1 + 2 + 3 = 16 people speak
at least one of these languages.
4.52 A × B = { (1, 3), (2, 3), (3, 3), (4, 3) } .
2 4.55 A = { (0, 0), (0, 1), (1, 0), (1, 1) } .
3 = { (0, 0, 0), (0, 1, 0), (1, 0, 0), (1, 1, 0), (0, 0, 1), (0, 1, 1), (1, 0, 1), (1, 1, 1) } . A
4.58 (a) 10 ∗ 50 = 500 (b) 10 ∗ 20 = 200 (c) 50 ∗ 50 ∗ 50 = 125, 000 (d) 10 ∗ 50 ∗ 20 = 10, 000
4.59
Evaluation of Solution 1:  Although it is on the right track, t his solution has several problems.
First, it would be better to make it more clear that the assump tion is that both A and B
are not empty. But the bigger problem is the statement ‘( a , b ) is in the cross product’. The
problem is that a and b are not defined anywhere. Saying ‘where a ∈ A and b ∈ B ’ earlier
does not guarantee that there is such an a or b . The proof needs to say something along the
lines of ‘Since A and B are not empty, then there exist some a ∈ A and b ∈ B . Therefore
( a , b ) ∈ A × B . . . ’
Evaluation of Solution 2:  This one is way off. The proof is essen tially saying ‘Notice that p → q .
Therefore q → p .’ But these are not equivalent statements. Although it is tr ue that if both A
and B are the empty set, then A × B is also the empty set, this does not prove that both A
and B must be empty in order for A × B to be empty. In fact, this isn’t the correct conclusion.
Evaluation of Solution 3:  The conclusion is incorrect, as is the proof. The problem is that the
negation of ‘both A and B are empty’ is ‘it is not the case that both A and B are empty’
or ‘at least one of A or B is not empty,’ which is not the same thing as ‘neither A nor B
is empty.’ So although the proof seems to be correct, it is not . The reason it seems almost
correct is that except for this error, the rest of the proof fo llows proper proof techniques.
Unfortunately, all it takes is one error to make a proof inval id.
Evaluation of Solution 4:  This is a correct conclusion and pr oof.
4.63
Evaluation of Proof 1:  This solution has several problems.
1. x ∈{ A − B } means ‘ x is an element of the set containing A − B ,’ not ‘ x is an element
of A − B .’ What they meant was ‘ x ∈ A − B .’
2. At the end of the first sentence, ‘ x is not ∈ B ’ mixes mathematical notation and English
in a strange way. This should be either ‘ x 6∈ B ’ or ‘ x is not in B .’

Exercise Solutions 469
3. In the second sentence, the phrase ‘ x ∈ A and B ’ is a strange mixture of math and
English that is potentially ambiguous. It should be rephras ed as something like ‘ x ∈ A
and x ∈ B ’ or ‘ x is in both A and B .’
4. Finally, what has been shown here is that A − B ⊆ A ∩ B . This is only half of the proof.
B ⊆ A − B . They still need to prove that A ∩
Evaluation of Proof 2:  Overall, this proof is very confusing and unclear. More specifically,
1. This is an attempt at working through what each set is by usi ng the definitions. That
would be fine except for two things. First, they were asked to g ive a set containment
proof. Second, the wording of the proof is confusing and hard to follow. I do not come
away from this with a sense that anything has been proven.
2. They are not using the terminology properly.  The terms ‘un iverse’ or ‘universal set’
would be appropriate, but not ‘universal’ on its own (used tw ice). Similarly, what does
the phrase ‘all intersection part’ mean? Also, a set doesn’t ‘return’ anything. A set is
just a set. It contains elements, but it doesn’t ‘do’ anythin g.
Evaluation of Proof 3:  This proof contains a lot of correct el ements. In fact, the first half is on
B . Between these the right track. However, they jumped from x ∈ A and x 6∈ B to x ∈ A ∩
B ’ since the latter statements they should say something like ‘ x 6∈ B is equivalent to x ∈
statement is really needed before they can conclude that x ∈ A ∩ B . Also, it would be better
B . Finally, if they had ‘by the definition of intersection’ before or afte r the statement x ∈ A ∩
it would help clarify the proof if the end was something like ’ We have shown that whenever
x ∈ A − B , x ∈ A ∩ B . Thus, A − B ⊆ A ∩ B .’
The second half of the proof starts out well, but has serious fl aws. The statement ’This means
that x ∈ A and x 6∈ B ’ should be justified by the definitions of complement and inte rsection,
and might even involve two steps. This is the same problem the y had in the first half of the
proof. More serious is the statement ‘which is what we just pr oved in the previous statement’.
What exactly does that mean? It is unclear how ‘what we just pr oved’ immediately leads us
B . First we need to establish that x ∈ A − B based on the to the conclusion that A − B = A ∩
B ⊆ A − B . Finally, we can combine previous statements (easy). Then we can say that A ∩
this with the first part of the proof to say that A − B = A ∩ B .
In summary, the first half is pretty good. It should at least ma ke the connection between
B . The other suggestions clarify the proof a little, but the pr oof would be x 6∈ B and x ∈
O.K. if they were omitted. The second half is another story. I t doesn’t really prove anything,
but instead makes a vague appeal to something that was proven before. Not only is what
they are referring to unclear, but how the proof of one direct ion is related to the proof of the
other direction is also unclear.
4.65 x ∈ C ; x ∈ B ; definition of union; ( x ∈ B ∧ x ∈ C ); distributive law (the logical one);
( x ∈ A ∩ C ); definition of intersection; definition of union.
4.68 (a) 45; (b) 8; (c) 3; (d) 6; (e) 0; (f) 7; (g) 7; (h) 7; (i) 11.
4.77 -15; -7; 9; 13; 21. Notice that it is every 4th number along the number line, both in the
positive and negative directions.
4.80 (1) 9; (2) 10; (3) 9; (4) 10; (5) 9; (6) 9.
4.89 f ( x ) = x mod 2 works. The domain is Z , and the codomain can be a variety of things. Z ,
N , and { 0, 1 } are the most obvious choices.  Note that we can pick any of thes e since the only

470 Chapter 12
requirement of the codomain is that the range is a subset of it . On the other hand, R , C and Q
could also all be given as the codomain, but they wouldn’t mak e nearly as much sense.
2 4.93 (a) F. Consider f ( x ) = ⌊ x ⌋ from R to Z . (b) F. Consider f ( x ) = x from R to R which is not
4.92 . (d) F. f maps 1 to two different values, so it isn’t a function. one-to-one. (c) T. See Theorem
(e) T. We previously showed it was onto, and it isn’t difficult t o see that it is one-to-one. (f) F. f
is not onto, but it is one-to-one. (g) T. By definition of range , it is a subset of the codomain. (h)
F. We have seen several counter examples to this. (i) F. If a = 2 and b = 0, the odd numbers are
not in the range. (j) F. Same counterexample as the previous q uestion. (k) T. The proof is similar
to several previous proofs.
2 x − 1 − ). 4.99 Let y = 7 x + 2. Then 7 x = y − 2, so x = ( y − 2) / 7. Thus, f ( x ) = ( x − 2) / 7 (or
7 7
4.102 ( f ◦ g )( x ) = f ( x/ 2) = ⌊ x/ 2 ⌋ , and ( g ◦ f )( x ) = g ( ⌊ x ⌋ ) = ( ⌊ x ⌋ ) / 2.
4.106 (a) F. f might not be onto–e.g. if a = 2 and b = 0. (b) F. Same reason as the previous
question. (c) T. Since over the reals, f is one-to-one and onto. (d) F. There are several problems.
2 First, x may not even have an inverse depending on the domain (which wa s not specified). Second,
2 even if it had an inverse, it certainly wouldn’t be 1 /x . That’s its reciprocal, not its inverse. Its
√
x (again, assuming the domain was chosen so that it is invertib le).  (e) F. inverse would be √
This is only true if n is odd.  (f) F. 2 6∈ N , so not only is it not invertible, it can’t even be
defined on N . (g) T. The n th root of a positive number is defined for all positive real nu mbers,
so the function is well defined.  It is not too difficult to convin ce yourself that the function is
both one-to-one and onto when restricted to positive number s, so it is invertible. (h) T. In both
2 2 2 2 cases you get 1 /x . (i) F. ( f ◦ g )( x ) = f ( x + 1) = ( x + 1 + 1) = ( x + 2) = x + 4 x + 4, and
2 2 2 ( g ◦ f )( x ) = g (( x + 1) ) = ( x + 1) + 1 = x + 2 x + 2, which are clearly not the same. (j) F.
( f ◦ g )( x ) = ⌈ x ⌉ , and ( g ◦ f )( x ) = ⌊ x ⌋ . (We’ll leave it to you to see why this is the case.) (k)
F. Certainly not. f (3. 5) = 3, but g (3) = 3, not 3. 5. (l) T. With the restricted domain, they are
indeed inverses.
4.109 We never said it was always wrong to work both sides of an equation. If you are working on
an equation that you know to be true, there is absolutely noth ing wrong with it. It is a problem
only when you are starting with something you don’t know to be true. In this case, we know that
2 a − 3 = 2 b − 3 is true given the assumption made. Therefore, we are free to ‘work both sides’.
4.110 Let a , b ∈ R . If f ( a ) = f ( b ), then 5 a = 5 b . Dividing both sides by 5, we get a = b . Thus, f
is one-to-one.
4.113 Notice that f (4. 5) = f (4) = 4, so clearly f is not one-to-one. (Your proof may involve
different numbers, but should be this simple.)
4.116 Notice that if y = 2 x + 1, then y − 1 = 2 x and x = ( y − 1) / 2.  Let b ∈ R .  Then
f (( b − 1) / 2) = 2(( b − 1) / 2) + 1 = b − 1 + 1 = b . Thus, every b ∈ R is mapped to by f , so f is onto.
4.119 Since the floor of any number is an integer, there is no a such that f ( a ) = 4. 5 (for instance).
Thus, f is not onto.
4.120 (a) f is not one-to-one. See Example 4.112 for a proof.  (b) The same proof from
Example 4.112 works over the reals. But I guess it doesn’t hurt to repeat it: Since f ( − 1) = f (1) = 1,
2 2 f is not one-to-one. (c) Let a , b ∈ N . If f ( a ) = f ( b ), that means a = b . Taking the square
√ √ √
2 2 2 a b , or | a | = | b | (if you didn’t remember that x = | x | , you = root of both sides, we obtain
do now). But since a , b ∈ N , | a | = a and | b | = b . Thus, a = b . Thus, f is one-to-one.
4.121 If f ( a ) = f ( b ), 3 a − 5 = 3 b − 5. Subtracting 5 from both sides and then dividing both sides
by 3, we get a = b . Thus, f is one-to-one. If b ∈ R , notice that f (( b + 5) / 3) = 3(( b + 5) / 3) − 5 =
b + 5 − 5 = b , so there is some value that maps to b . Therefore, f is onto. Since f is one-to-one and
onto, it has an inverse. To find the inverse, we let y = 3 x − 5. Then 3 x = y + 5, so x = ( y + 5) / 3.
5 x − 1 + ). Thus, f ( x ) = ( x + 5) / 3 (or
3 3
4.122 (a) Notice that if f ( a ) = f ( b ), then a − 7 = b − 7 so a = b . Thus, f is one-to-one. Also

Exercise Solutions 471
notice that for any b ∈ Z , f ( b + 7) = b + 7 − 7 = b , so f is onto. (b) Since g (1) = g ( − 1) = 1, g is
4 not one-to-one. Also notice that there is no integer a such that g ( a ) = a = 5, so g is not onto. (c)
If h ( a ) = h ( b ), then 3 a = 3 b so a = b . Thus, h is one-to-one. But there is no integer a such that
h ( a ) = 3 a = 1, so a is not onto. (d) Notice that r (0) = ⌊ 0 / 2 ⌋ = ⌊ 0 ⌋ = 0 and r (1) = ⌊ 1 / 2 ⌋ = ⌊ 0 ⌋ = 0,
so r is not one-to-one. But for any integer b , r (2 b ) = ⌊ 2 b/ 2 ⌋ = ⌊ b ⌋ = b , so r is onto.
4.130 The following three cases probably make the most sense: When a = b , when a < b and
when a > b . These make sense because these are likely different cases in t he code. Mathematically,
we can think of it as follows. The possible inputs are from the set Z × Z . The partition we have
in mind is A = { ( a , a ) : a ∈ Z } , B = { ( a , b ) : a , b ∈ Z , a < b } , and C = { ( a , b ) : a , b ∈ Z , a > b } .
Convince yourself that these sets form a partition of Z × Z . That is, they are all disjoint from each
other and Z × Z = A ∪ B ∪ C .
Alternatively, you might have thought in terms of a and/or b being positive, negative, or 0.
Although that may make some sense, given that we are comparin g a and b with each other, it
probably doesn’t matter exactly what values a and b have (i.e. whether they are positive, negative,
or 0), but what values they have relative to each other . That is why the first answer is much better.
With that being said, it wouldn’t hurt to include several tes ts for each of our three cases that
involve various combinations of positive, negative, and ze ro values.
4.131 Did you define two or more subsets of Z ?  Are they all non-empty?  Do none of them
intersect with each other? If you take the union of all of them , do you get Z ? If so, your answer is
correct! If not, try again.
4.133 Since R = Q ∪ I and Q ∩ I = ∅ , { Q , I } is a partition of R . Hopefully this comes as no
surprise.
4.138 R is a subset of Z × Z , so it is a relation. By the way, this relation should look fam iliar.
4.130 ? Did you read the solution to Exercise
+ + + 4.139 Is it a subset of Z × Z ? It is. So it is a relation on Z .
4.141 (a) T is not reflexive since you cannot be taller than yourself. (b) N is reflexive because
everybody’s name starts with the same letter as their name do es. (c) C is reflexive because every-
body have been to the same city as they have been in. (d) K is not reflexive because you know
who you are, so it is not the case that you don’t know who you are . That is, ( a , a ) 6∈ K for any a .
(e) R is not reflexive because (Donald Knuth, Donald Knuth) (for instanc e) is not in the relation.
4.143 (a) T is not symmetric since if a is taller than b , b is clearly not taller than a . (b) N
is symmetric since if a ’s name starts with the same letter as b ’s name, clearly b ’s name starts
with the same letter as a ’s name.  (c) C is symmetric since it is worded such that it doesn’t
distinguish between the first and second item in the pair.  In o ther words, if a and b have
been to the same city, then b and a have been to the same city.  (d) K is not symmetric
since (David Letterman, Chuck Cusack) ∈ K , but (Chuck Cusack, David Letterman) 6∈ K .  (e)
R is not symmetric since (Barack Obama, George W. Bush) ∈ R , but (George W. Bush, Barack
Obama) 6∈ R .
4.145 (a) Just knowing that (1, 1) ∈ R is not enough to tell either way. (b) On the other hand, if
(1, 2) and (2, 1) are both in R , it is clearly not anti-symmetric.
4.146 This is just the contrapositive of the original definition.
4.147 (a) T is anti-symmetric since whenever a 6 = b , if a is taller than b , then b is not taller
than a , so if ( a , b ) ∈ T , then ( b , a ) 6∈ T . (b) N is not anti-symmetric since (Bono, Boy George)
and (Boy George, Bono) are both in N . (c) C is not anti-symmetric since (Bono, The Edge) and
(The Edge, Bono) are both in C (since they have played many concerts together, they have ce r-
tainly been in the same city at least once). (d) Since both (Di rk Benedict, Jon Blake Cusack 2.0)
and (Jon Blake Cusack 2.0, Dirk Benedict) are in K , K is not anti-symmetric.  (e) R is anti-
symmetric since it only contains one element, (Barack Obama , George W. Bush), and (George W.

472 Chapter 12
Bush, Barack Obama) 6∈ R .
4.148 (a) No. The relation R = { (1, 2), (2, 1), (1, 3) } is neither symmetric ((3, 1) 6∈ R ) nor anti-
symmetric ((1, 2) and (2, 1) are both in R ).  (b) No.  For example, R from answer (a) is not
anti-symmetric, but isn’t symmetric either. (c) Yes. If you answered incorrectly, don’t worry. You
get to think about why the answer is ‘yes’ in the next exercise .
4.149 Many answers will work, but they all have the same thing in com mon: They only contain
‘diagonal’ elements (but not necessarily all of the diagona l elements). For instance, let R = { ( a , a ) :
a ∈ Z } . Go back to the definitions for symmetric and anti-symmetric and verify that this is indeed
both. Another examples is R = { (Ken, Ken) } on the set of English words.
4.151 (a) T is transitive since if a is taller than b , and b is taller than c , clearly a is taller than c .
In other words ( a , b ) ∈ R and ( b , c ) ∈ R implies that ( a , c ) ∈ R . (b) N is transitive because if a ’s
name starts with the same letter as b ’s name, and b ’s name starts with the same letter as c ’s name,
clearly it is the same letter in all of them, so a ’s name starts with the same letter as c ’s. (c) C is
not transitive. You might think a similar argument as in (a) and ( b) works here, but it doesn’t.
The proof from (b) works because names start with a single let ter, so transitivity holds. But if
( a , b ) ∈ C and ( b , c ) ∈ C , it might be because a and b have both been to Chicago, and b and c have
both been to New York, but that a has never been to New York. In this case, ( a , c ) 6∈ C . So C is
not transitive. (d) K is not transitive. For instance, (David Letterman, Chuck Cu sack) ∈ K and
(Chuck Cusack, David Letterman’s son) ∈ K , but (David Letterman, David Letterman’s son) 6∈ K
since I sure hope he knows his own son. (e) R is transitive since there isn’t even an a , b , c ∈ R such
that ( a , b ) and ( b , c ) are both in R , so it holds vacuously.
4.154 (a) T is not an equivalence relation since it is not symmetric. (b) N is an equivalence
relation since it is reflexive, symmetric, and transitive. ( c) C is not an equivalence relation since
it is not transitive. (d) K is not an equivalence relation since it is not reflexive, symmetric , or
transitive. This one isn’t even close! (e) R is not an equivalence relation since it is not reflexive.
4.156 (a) T is a not partial order because it is not reflexive. (b) N is not a partial order since
it is not anti-symmetric. (c) C is not a partial order since it is not anti-symmetric or transitive .
(d) K is not a partial order since it is not reflexive, anti-symmetric, or transitive. (e) R is not a
partial order since it is not reflexive.
4.157 In the following, A , B , and C are elements of X . As such, they are sets.
( Reflexive ) Since A ⊆ A , ( A , A ) ∈ R , so R is reflexive.
( Anti-symmetric ) If ( A , B ) ∈ R and ( B , A ) ∈ R , then we know that A ⊆ B and B ⊆ A . By
Theorem 4.60 , this implies that A = B . Therefore R is anti-symmetric.
( Transitive ) If ( A , B ) ∈ R and ( B , C ) ∈ R , then A ⊆ B and B ⊆ C . But the definition of ⊆
implies that A ⊆ C , so ( A , C ) ∈ R , and R is transitive.
Since R is reflexive, anti-symmetric, and transitive, it is a partia l order.
4.158 (a) Since (1, 1) 6∈ R , R is not reflexive.  (b) Since (1, 2) ∈ R , but (2, 1) 6∈ R , R is not
symmetric.  (c) A careful examination of the elements reveal s that it is anti-symmetric.  (d) A
careful examination of the elements reveals that it is transitive.  (e) Since it is not reflexive or
symmetric, it is not an equivalence relation. (f) Since it is not reflexive, it is not a partial order.
4.160 (( a , b ), ( a , b )); bc ; da ; (( c , d ), ( a , b )); symmetric; ad = bc ; cf = de ; de/f ; b ( de/f ); af = be ;
(( a , b ), ( e , f ))
5.7
areaSquare( double s) { return s*s; } double
5.10 It does not work. To see why, notice that if we pass in a and b , then x = a and y = b at
the beginning. After the first line, x = b and y = b . After the second line x = b and y = b . The
problem is that the first line overwrites the value stored in x ( a ), and we can’t recover it.

Exercise Solutions 473
5.13 Either − 1 or 3 are possible answers if we are uncertain whether it will return a positive or
negative answer. But we know it is one of these. It won’t be -5, for instance.
5.14
Evaluation of Solution 1:  This solution is both incorrect an d a bit confusing. The phrase ‘both
sides’ is confusing–both sides of what? We don’t have an equa tion in this problem. But there
is a more serious problem. If you thought it was correct, go ba ck and try to figure out why it
is incorrect before you continue reading this solution. The main problem is that although this
may return a value in the correct range, it doesn’t always ret urn the correct value. In fact,
what if ( a (mod b ) + b − 1) is odd? Mathematically, this would result in a non-intege r result
which is clearly incorrect. In most programming languages i t would at least truncate and
return an integer–but again, not always the correct one. Thi s person focused on the wrong
thing–getting the number in a particular range. Although th at is important, they needed to
think more about how to get the correct number. They should have plugged in a few more
values to double-check their logic.
Evaluation of Solution 2:  Incorrect. Generally speaking, a mod b 6 = − a mod b . In other words,
returning the absolute value when the result is negative is a lmost always incorrect.
Evaluation of Solution 3:  Incorrect. If you think about if fo r a few minutes you should see that
this is just one way of implementing the idea from the previou s solution.
Evaluation of Solution 4:  Incorrect.  If ( a mod b ) is negative, performing another mod will still
leave it negative.
5.15 There are several possible answers, but the slickest is prob ably: (b+(a mod b)) mod b . Try
it with both positive and negative numbers for a and convince yourself that it is correct.
5.16
Evaluation of Solution 1:  This does not work. What happens wh en x = 3. 508, for instance?
Evaluation of Solution 2:  This is incorrect for two reasons. First, 1 / 2 = 0 in most programming
languages, so this will always round down. Second, even if we replaced this with . 5 or 1. 0 / 2. 0,
it would round up at . 5.
Evaluation of Solution 3:  Nice try, but still no good. What if x = 2. 5? This will round up to 3.
Worse, what if x = 2. 0001? Again, it rounds up to 3 which is really bad.
Evaluation of Solution 4:  This one is correct. Plug in values like 2, 2. 1, and 2. 5 to see that it
rounds down to 2 and values like 2. 51, 2. 7, and 2. 9 to see that i t rounds up to 3.
5.17 (a) 0; (b) 1; (c) 1; (d) 1; (e) 1 (f) 1; (g) 2; (h) 9; (i) 0; (j) -1; ( k) -1; (l) -2.
5.18
Evaluation of Solution 1:  0. 5 is not an integer, and the floor function is not allowed.
Evaluation of Solution 2:  The floor function is not allowed. Even if it were, this solution doesn ’t
work. 1 / 2 is evaluated to 0 so it doesn’t help.
Evaluation of Solution 3:  This one works, but 0. 5 is not allow ed so it does not follow the directions.
5.19 Two reasonable solutions include (n+m/2)/m and (2n+m)/(2m) .
5.22 Here is one possibility:

474 Chapter 12
int max( int x, int y, int z) {
int w = max(x,y);
return max(w,z);
}
We will use a proof by cases.
• If x is the maximum, then w = max ( x , y ) = x . so it returns max ( w , z ) = x , which is correct.
• If y is the maximum, the argument is essentially the same the prev ious case.
• If z is the maximum, then w is either x or y , but in either case w ≤ z , so it returns max ( w , z ) =
z .
In each case the algorithm returns the correct answer.
5.25 Here is a possible answer.
void HelloGoodbye( int x) {
if (x  >= 4) {
if (x  <= 6) {
print( "Hello" );
} else {
"Goodbye" ); print(
}
else { }
print( " Goodbye" );
}
}
5.26 It is possible. If you thought it wasn’t, go back and try to wri te the algorithm before reading
any further.
Here is one way to do it using an extra variable and an addition al conditional statement.
void HelloGoodbye( int x) {
boolean sayGoodbye = true;
if (x  >= 4) {
if (x  <= 6) {
sayGoodbye = false;
}
}
if (sayGoodbye) {
print( " Goodbye" );
} else {
"Hello" ); print(
}
}
It can also be done by using a return statement (this version i s not recommended!):
void HelloGoodbye( int x) {
if (x  >= 4) {
if (x  <= 6) {
"Hello" ); print(
return ;
}
}
" Goodbye" ); print(
}

Exercise Solutions 475
The second solution is simpler, but this sort of code (with so mewhat random return statements
in the middle of them) can be tricky to debug if it is changed la ter. Did you come up with a better
solution than these?
5.27 list.size()!=0 and !(list.size()==0) are the most obvious solutions.
5.32 Let p =“ x > 0” and q =“ x < y ”. Then the conditional above can be expressed as ( p ∧ q ) ∨
( p ∧¬ q ). Using a few of the logical equivalences from Table 2.3 , it is not too difficult to see that
( p ∧ q ) ∨ ( p ∧¬ q ) = p ∧ ( q ∨¬ q ) = p ∧ T = p . Therefore the code simplifies to:
if (x>0) {
x=y;
}
5.33 This is not equivalent to the original code. Consider the cas e when x = − 1 and y = 1, for
instance.
5.34 After my head is done spinning trying to understand what they are saying, I suspect
something isn’t right here.  In fact, since both conditions n eed to be true when if statements
are nested, it is the same thing as a conjunction. In other wor ds, the two ifs are equivalent to
if( x>0 && (x0) ) .  By absorption, this is equivalent to if(x>0) .  So the simplified
code is:
if (x>0) {
x=y;
}
You can also think about it this way. The assignment x=y cannot happen unless x>0 due to the
1 But the inner if has a disjunction, one part of which is x>0 , which we already know outer if.
is true. In other words, it doesn’t matter whether or not x0 && (a[0]==0  || a[n -1]==0) ) {
return true;
else {
return false;
}
}
5.56 The solution uses the expression n>0 && (a[0]==0 || a[n-1]==0) . If n = 0, the expression
is false because of the && , so the algorithm returns false as it should since an array wi th no elements
certainly does not begin or end with a 0. If n = 1, first note that n − 1 = 0, so a [0] and a [ n − 1] refer
to the same element. Although this is redundant, it isn’t a pr oblem. If a [0] = 0, the expression
evaluates to T ∧ ( T ∨ T ) = T , and the algorithm returns true as expected. If a [0] 6 = 0, the expression
evaluates to T ∧ ( F ∨ F ) = F , and the algorithm returns false as expected.

Exercise Solutions 477
5.59 As we already discussed, many languages truncate when perfo rming integer division. When
the numbers are positive (as they are here), that is the same t hing as taking the floor. Even if a
language does not do this, Theorem 4.81 implies that it would still work.
5.60 It is easiest to see that this is correct by comparing with the previous solution. The only
difference is that the condition went from i < = ( n − 2) / 2 to i < n/ 2. Notice that ( n − 2) / 2 + 1 =
n/ 2 − 2 / 2 + 1 = n/ 2. But since we also replaced < = with < , it still stops at the same point.
5.62 It is correct. To convince yourself (but this is not a proof), plug the numbers 1 through 5 (or
some other set of both even and odd values) into both sides to s ee that you get the same number.
5.65 They are equivalent by the commutative property. But they ar e not practically equivalent
because whenever x>=a.length , the first statement works properly because it does not try to access
a[x] which avoids an IndexOutOfBoundsException , but the second one will try to access a[x]
first, causing an IndexOutOfBoundsException before it checks if the index is valid.
5.66 This is simple—we just need to add a check that the index is not negative:
if(x>=0 && x 4 and thus x = 10. Next, n = 3, i = 2,
and we go through the loop again. Since n ∗ i > 4, x = 10 + 2 ∗ 3 = 16. Finally, n = 1, i = 3, and
the loop stops. Hence x = 16 is returned.

478 Chapter 12
√
5.81 ⌊ 101 ⌋ = 10.  The only primes less than 10 are 2, 3, 5, and 7.  Since 101 mo d 2 = 1,
5.79 tells us that 101 mod 3 = 2, 101 mod 5 = 1, and 101 mod 7 = 3, none of which are 0, Th eorem
101 is prime.
5.82 323 = 17 ∗ 19, so it is not prime. I determined this by seeing if any of the primes no greater √
than ⌊ 323 ⌋ = 17 were factors. Although 2, 3, 5, 7, 11, and 13, are not, 17 is .
5.84 No need to test the even integers. So we can modify the code to s kip checking even numbers,
so long as we first make sure that it gets the correct answer for 2. If you didn’t think about this,
go back and try to write the algorithm before continuing to re ad the solution. Here is the modified
code:
boolean isPrime( int n) {
if (n<=1) { //  Anything less than 2 is not prime
return false;
else if (n==2) { }
return true; // Need to deal  with this as a special case
} else if ( n%2==0 ) { //  Discard even  numbers.
return false;
} else {
//  Determine if it has any odd factors.
int i = 3;
while ( i  <= sqrt(n) ) {
if ( n%i==0 ) {
return false;
}
i = i + 2;
}
return true; // It had no  factors.
}
}
5.85 The following algorithm does the job.
int reverseDigits( int n) {
x=0;
while (n!=0) {
x = x*10+n%10;
n=n/10;
}
return x;
}
5.88 Below is a table of the values the algorithm computes. The fina l answer of 8388608 is correct!
It took 9 steps as opposed to the 22 required by the algorithm f rom Example 5.52 , so it was
definitely faster. Notice that 2 log (23) ≈ 2 ∗ 4. 52356 = 9. 04712 > 9, it works as advertised. 2
k pow ans
23 2.0 1.0
22 2.0 2.0
11 4.0 2.0
10 4.0 8.0
5 16.0 8.0
4 16.0 128.0
2 256.0 128.0
1 65536.0 128.0
0 65536.0 8388608.0

Exercise Solutions 479
0 1 2 6.3 (a) x = 1 + ( − 2) = 1 + 1 = 2 (b) x = 1 + ( − 2) = 1 − 2 = − 1 (c) x = 1 + ( − 2) = 1 + 4 = 5
0 1 2
3 4 (d) x = 1 + ( − 2) = 1 − 8 = − 7 (e) x = 1 + ( − 2) = 1 + 16 = 17
3 4
6.4 We will just provide the final answer for these. If you can’t ge t these answers, you may need
to brush up on your algebra skills. (a) 2, 1 / 2,5 / 4, 7 / 8, 17 / 16; (b) 2, 2, 3, 7, 25; (c) 1 / 3, 1 / 5, 1 / 25,
1 / 119, 1 / 721; (d) 2, 9 / 4, 64 / 27, 625 / 256, 7776 / 3125
2 2 3 6.8 Notice that x = 1, x = 5 · 1 = 5, x = 5 · 5 = 5 , x = 5 · 5 = 5 , etc. Looking back, we
0 1 2 3
0 0 1 n can see that 1 = 5 , so x = 5 . Also, x = 5 = 5 . So it seems likely that the solution is x = 5 .
0 1 n
This is not a proof, though!
6.9 Notice that x = 1, x = 1 · 1 = 1, x = 2 · 1 = 2, x = 3 · 2 = 6, x = 4 · 6 = 24, 0 1 2 3 4
x = 5 · 24 = 120, etc. Written this way, no obvious pattern is emergin g. Sometimes how you write 3
the numbers matters. Let’s try this again: x = 1 · 1 = 1!, x = 2 · 1 = 2!, x = 3 · 2 · 1 = 3!, 1 2 3
x = 4 · 3 · 2 · 1 = 4!, x = 5 · 4 · 3 · 2 · 1 = 5!, etc. Now we can see that x = n ! is a likely solution. 4 3 n
Again, this isn’t a proof.
6.10 Their calculations are correct (Did you check them with a cal culator? You should have! How
n else can you tell whether or not their solution is correct?). So it does seem like a = 2 is the
n
correct solution. However,
√ √ ö ù ö ù
1+ 1+ 5 5 5 a = + a = × a × 16 + 8 = 33 6 = 2
5 3 4 2 2
so the solution that seems ‘obvious’ turns out to incorrect. We won’t give the actual solution since
the point of this example is to demonstrate that just because a pattern holds for the first several
terms of a sequence, it does not guarantee that it holds for th e whole sequence.
n 0 6.12 Hopefully you came up with the solution x = 5 . Since x = 1 = 5 , it works for the initial
n 0
condition. If we plug this back into the right hand side of x = 5 · x , we get n n − 1
n − 1 5 · x =  5 · 5
n − 1
n =  5
= x , n
n which verifies the formula. Therefore x = 5 is the solution.
n
6.13 Hopefully you came up with the solution x = n !. Since x = 1 = 0!, it works for the initial n 0
condition. If we plug this back into the right hand side of x = n · x , we get n n − 1
n · x = n · ( n − 1)! n − 1
= n !
= x , n
which verifies the formula. Therefore x = n ! is the solution. n
6.14 The computations are correct, the conclusion is correct, bu t unfortunately, the final code has
a serious problem. It works most of the time, but it does not deal with negative values correct ly.
It should return 3 for all negative values, but it continues t o use the formula. The problem is they
forgot to even consider what the function does for negative v alues of n . They probably could have
formatted their answer better, too. It’s difficult to follow i n paragraph form. They could have put
the various values of ferzle(n) each on their own line and presented it mathematically inste ad of
in sentence form. For instance, instead of ‘ferzle(1) retur ns ferzle(0)+2, which is 3 + 2 = 5,’ they
should have ‘ f erzle (1) = f erzle (0) + 2 = 3 + 2 = 5.’ It would have made it much easier to see the
pattern.
6.15

480 Chapter 12
int ferzle( int n) {
if (n<=0) {
return 3;
} else {
return 2*n+3;
}
}
6.19 We didn’t do anything wrong. We wrote the inequality in the ot her order, and the indexes
are one lower than those given in the definition. But that’s O. K. The definition is simply trying
to convey the idea that every term is strictly greater than th e previous. That is what we showed.
We can show that x < x , x > x , x < x , or x > x . They all mean essentially the n n +1 n +1 n n − 1 n n n − 1
same thing. The only difference is the order in which the inequa lities are written (the first two and
last two are saying exactly the same thing–we just flipped the inequality) and what values of n are
valid. For instance, if the sequence starts at 0, then we need to assume n ≥ 0 for the first pair of
inequalities and n ≥ 1 for the second pair.
2 n + 1 1
6.21 If you got stuck on this one, first realize that x = = n + . This form might make the n
n n
algebra a little easier. Then, follow the technique of the pr evious example–show that x − x > 0. n +1 n
So, if necessary, go back and try again. If you already attemp ted a proof, you may proceed to read
the solution.
Notice that,
ã Å ã Å
1 1
− n + x − x = n + 1 + n +1 n
n + 1 n
1 1
=  1 + −
n + 1 n
1
=  1 −
n ( n + 1)
> 0,
the last step since 1 /n ( n + 1) < 1 when n ≥ 1. Therefore, x − x > 0, so x > x , i.e., the n +1 n n +1 n
sequence is strictly increasing. If your solution is signifi cantly different than this, make sure you
determine one way or another if it is correct.
6.22 We could go into much more detail than we do here, and hopefull y you did when you wrote
down your solutions. But we’ll settle for short, informal ar guments this time. (a) This is just a
linear function. It is strictly increasing . (b) Since this keeps going from positive to negative to
positive, etc. it is non-monotonic . (c) We know that n ! is strictly increasing. Since this is the
reciprocal of that function, it is almost strictly decreasing (since we are dividing by a number that
is getting larger). However, since 1 / 0! = 1 / 1! = 1, it is just decreasing . (d) This is getting closer
to 1 as n increases. It is strictly increasing (e) This is n ( n − 1). x = 0, x = 2, x = 6, etc. 1 2 3
Each term is multiplying two numbers that are both getting la rger, so it is strictly increasing .
(f) This is similar to the previous one, but x = x = 0, so it is just increasing . (g) This alternates 0 1
between − 1 and 1, so it is non-monotonic . (h) Each term subtracts from 1 a smaller numbers
than the last term, so it is strictly increasing . (i) Each term adds to 1 a smaller number than
the last term, so it is strictly decreasing .
) ( 2 2 2 17 16
= − 3 / 3 = − 3 (or and that r = / − 6.26 You should have concluded that a = − 17 16 17 3 3 3
n 2( − 1) n − 1 2
you could have divided the second and third terms). Then the n -th term is − ( − 3) = 17 18 − n 3 3
(Make sure you can do the algebra to get to this simplified form ).  Finally, the 17th term is
17 2 2( − 1)
= − 18 − 17 3
3
5 9 4 6.28 We are given that ar = 20 and ar = 320.  Dividing, we can see that r = 16.  Thus

Exercise Solutions 481
5 r = ± 2.  (We don’t have enough information to know which it is).  Sin ce ar = 20, we know
5 2 2 that a = 20 /r = ± 20 / 32. So the third term is ar = ( ± 20 / 32)( ± 2) = ± 80 / 32 = ± 5 / 2. Thus
2 | ar | = 5 / 2.
6.32
(a) The difference between the each of the first 4 terms of the seq uence is 7, so it appears to be an
arithmetic sequence. Doing a little math, the correct answe r appears to be (d) 51.
(b) Although the sequence appears to be arithmetic, we cannot be certain that it is. If you are
told it is arithmetic, then 51 is absolutely the correct answ er. Notice that the previous exam-
ple specifically stated that you should assume that the patte rn continues. This one did not.
Without being told this, the rest of the sequence could be any thing. The 8th term could be 0
or 8, 675, 309 for all we know. Of the choices given, 51 is the mo st obvious choice, but any of
the answers could be correct. This is one reason I hate these s orts of questions on tests.
Although I think it is important to point out the flaw in these s orts of questions, it is also
important to conform to the expectations when answering suc h questions on standardized
tests. In other words, instead of disputing the question (as some students might be inclined to
do), just go with the obvious interpretation.
n 6.33 (a) The closed form was x = 5 , which is clearly geometric (with a = 1 and r = 5) and not
n
arithmetic. (b) Since the solution for this one is x = n !, this is neither arithmetic or geometric. n
(c) Since the sequence is essentially f = 2 n + 3, with initial condition f = 3, it is an arithmetic n 0
sequence. It is clearly not geometric.
100 ∑
i 6.36 y
i =0
50 50 ∑ ∑
2 i 2 i 6.38 y ( y ) or
i =0 i =0
6.40 (a) 2 (b)11 (c) 100 (d) 101
6 6 30 30 ∑ ∑ ∑ ∑
6.45 (a) 5 = 5 1 = 5 · 2 = 10. (b) 200 = 200 1 = 200(30 − 20 + 1) = 2200.
k =5 k =5 k =20 k =20
6.48 Using Theorem 6.46 , we get the following answers: (a) (30 − 20 + 1)200 = 11 ∗ 200 = 2200.
(b) 900 (c) 909. Notice that this one has one more term than the previous one. The fact that the
additional index is 0 doesn’t matter since it is adding 9 for t hat term.
6.49 This solution contains an ‘off by one’ error. The correct answ er is 10(75 − 25+1) = 10 ∗ 51 =
510.
6.52 (a) 20 · 21 / 2 = 210 (b) 100 · 101 / 2 = 5050 (c) 1000 · 1001 / 2 = 500500
6.53
Evaluation of Solution 1:  Another example of the ‘off by one er ror’. They are using the formula
n ( n − 1) / 2 instead of n ( n + 1) / 2.
Evaluation of Solution 2:  This answer doesn’t even make sens e. What is k in the answer? k is
just an index of the summation. The index should never appear in the answer. The problem
is that you can’t pull the k out of the sum since each term in the sum depends on it.
6.54 It is true. The additional term that the sum adds is 0, so the su m is the same whether or
not it starts at 0 or 1.

482 Chapter 12
100 100 100 ∑ ∑ ∑
100 · 101
= 200 − 5050 = − 4850. i = 200 − 6.57 2 − 2 − i =
2
i =1 i =1 i =1
6.58 The sum of the first n odd integers is
n n n n n ∑ ∑ ∑ ∑ ∑
n ( n + 1) 2 2
− n = n + n − n = n . (2 k − 1) = 2 k − 1 = 2 k − 1 = 2
2
k =1 k =1 k =1 k =1 k =1
9 20 20 ∑ ∑ ∑
k = 20 · 21 / 2 − 9 · 10 / 2 = 210 − 45 = 165. k − k = 6.61 (a)
k =1 k =1 k =10
40 40 20 ∑ ∑ ∑
(b) k = k − k = 40 · 41 / 2 − 20 · 21 / 2 = 820 − 210 = 610.
k =21 k =1 k =1
6.62
Evaluation of Solution 1:  Another example of the off-by-one er ror. The second sum should end at
29, not 30.
Evaluation of Solution 2:  This one has two errors, one of whic h is repeated twice. It has the same
error as the previous solution, but it also uses the incorrec t formula for each of the sums (the
off-by-one error).
Evaluation of Solution 3:  This one is correct.
6.63 Two errors are made that cancel each other out. The first error is that the second sum in
the second step should go to 29, not 30. But in the computation of that sum in the next step, the
formula n ( n − 1) / 2 is used instead of n ( n + 1) / 2 (The correct formula was used for the first sum).
This is a rare case where an off-by-one error is followed by the o pposite off-by-one error that results
in the correct answer.
It should be emphasized that even though the correct answer i s obtained, this is an incorrect
solution . They obtained the correct answer by sheer luck.
6.65 There are two ways to answer this. The smart aleck answer is ‘b ecause it is correct.’ But
why is it correct with 2, and couldn’t it be slightly modified to wo rk with 1 or 0? The answer is no
1 because if you plug 1 or 0 into , you get a division by 0. Hopefully I don’t need to tell you
( k − 1) k
that this is a bad thing.
6.66
n n n ∑ ∑ ∑
3 3 k + k = k + k
k =1 k =1 k =1
2 2 n ( n + 1) n ( n + 1)
+ =
4 2 ã Å
n ( n + 1) n ( n + 1)
+ 1 =
2 2
Å ã 2
n ( n + 1) n + n + 2
=
2 2
2 n ( n + 1)( n + n + 2)
=
4
n n i ∑ ∑ ∑
n ( n + 1)
i = . 1 = 6.68 (a)
2
i =1 i =1 j =1

Exercise Solutions 483
n n i ∑ ∑ ∑
i ( i + 1) n ( n + 1)( n + 2)
= ··· = . (This one involves doing a little algebra, j = (b)
2 6
i =1 i =1 j =1
applying two formulas, and then doing a little more algebra. Make sure you work it out until you
get this answer.) é Ñ
Å ã n n n n n n ∑ ∑ ∑ ∑ ∑ ∑
n ( n + 1) n ( n + 1) n ( n + 1) n ( n + 1)
ij = j = i i (c) i = = =
2 2 2 2
i =1 i =1 j =1 j =1 i =1 i =1
2 2 n ( n + 1)
.
4 50
3 − 1 6.72 = 358948993845926294385124.
2 ∑
34 k 35
6.73 This is equivalent to ( − 2) , so the summation is (1 − ( − 2) ) / (1 − ( − 2)) = (1 − k =0
35 35 35 ( − 1) 2 ) / 3 = (1 + 2 ) / 3 = 11453246123.
101 101 y − 1 1 − y
or (We won’t give the alternatives for the rest. If your answer d iffers, do 6.74 (a) 1 − y y − 1
101 102 101 1 − ( − y ) 1 − y 1+ y
. some algebra to make sure it is equivalent.) (b) (c) = 2 1+ y 1 − ( − y ) 1 − y
5 4 3 2 6.77 x − 1 = ( x − 1)( x + x + x + x + 1).
1 2 3 n +1 0 n +1 n +1 0 6.78 2 + 2 + 2 + ··· + 2 ; 2 ; 2 ; 2 − 2
n ∑
k +1 k 1 − r
r ; a 6.80 a . 1 − r
k =0
2 n 2 n +1 6.81 Let S = a + ar + ar + ··· + ar . Then rS = ar + ar + ··· + ar Z , so
2 n 2 n +1 S − rS = a + ar + ar + ··· + ar − ar − ar −···− ar
n +1 = a − ar .
From this we deduce that
n +1 a − ar
S = ,
1 − r
that is,
n n +1 ∑
a − ar k
. ar =
1 − r
k =0
7.6 (a) Since we assumed that n ≥ 1, − 3 n is certainly negative. In other words, − 3 n ≤ 0. That’s
2 2 why in the first step we could say that 5 n − 3 n + 20 ≤ 5 n + 20.  (b) We used the fact that
2 20 ≤ 20 n whenever n ≥ 1. If either of these solutions is not clear to you, you need to brush up on
your algebra.
2 7.7 This is incorrect. It is not true that − 12 n ≤− 12 n when n ≥ 1. (If this isn’t clear to you after
thinking about it for a few minutes, you may need to do some alg ebra review.) In fact, that error
2 2 led to the statement 4 n − 12 n + 10 ≤ 2 n which cannot possibly be true as n gets larger since it
2 would require that 2 n − 12 n + 10 ≤ 0. This is not true as n gets larger. In fact, when n = 10, for
instance, it is clearly not true. But it is true that − 12 n < 0 when n ≥ 0, so instead of replacing it
2 with − 12 n , it should be replaced with 0 as in previous examples.
2 2 7.8 (a) Sure. Add the final step of 25 n ≤ 50 n to the algebra in the proof. In fact, any number
above 25 can easily be used. Some values under 25 can also be us ed, but they would require a
modification of the algebra used in the proof. The bottom line is that there is generally no ‘right’
value to use for c . If you find a value that works, then it’s fine. (b) Clearly not. For this to work,
2 2 we would need 5 n − 3 n + 20 < 2 n to hold as n increases towards ∞ . But this would imply that
2 2 2 3 n − 3 n + 20 < 0. But when n ≥ 1, 3 n is positive and larger than 3 n , so 3 n − 3 n + 20 > 0. (c)
Sure. The proof used the fact that the inequality is true when n ≥ 1, so it is clearly also true if

484 Chapter 12
n ≥ 100. And the definition of Big-O does not require that we use th e smallest possible value for
2 2 n . (d) No. We would need a constant c such that 5 · 0 − 3 · 0 + 20 = 20 ≤ 0 = c · 0 , which is
0
clearly impossible.
7.9 If n ≥ 1,
5 4 3 2 5 3 5 n − 4 n + 3 n − 2 n + n ≤ 5 n + 3 n + n
5 5 5 ≤ 5 n + 3 n + n
5 =  9 n .
5 4 3 2 5 Therefore, 5 n − 4 n + 3 n − 2 n + n = O ( n ).
7.10 We used n = 1 and c = 9. Your values for n and c may differ. This is O.K. if you have the 0 0
correct algebra to back it up.
2 2 2 2 7.13 Since 4 n ≤ 4 n + n + 1 for n ≥ 0, 4 n = Ω( n ).
7.14 We used c = 4 and n = 0. You might have used n = 1 or some other positive value. As 0 0
long as you chose a positive value for n , it works just fine. You could have also used any value for 0
c larger than 0 and at most 4.
7.17 It is O.K. Since the second inequality holds when n ≥ 0, it also holds when n ≥ 1.
In general, when you want to combine inequalities that conta in two different assumptions, you
simply make the more restrictive assumption. In this case, n ≥ 1 is more restrictive than n ≥ 0.
In general, if you have assumptions n ≥ a and n ≥ b , then to combine the results with these
assumptions, you assume n ≥ max ( a , b ).
7.22 g ( n ) appears in the denominator of a fraction. If at some point it does not become (and
remain) non-zero, the limit in the definition will be undefine d. If you never took a calculus course
and are not that familiar with limits, do not worry a whole lot about this subtle point.
7.23 o is like < and ω is like > .
7.24 (a) No. If f ( n ) = Θ( g ( n )), f and g grow at the same rate. But f ( n ) = o ( g ( n )) expresses
the idea that f grows slower than g .  It is impossible for f to grow at the same rate as g and
slower than g . (b) Yes! If f grows no faster than g , then it is possible that it grows slower. For
2 2 instance, n = O ( n ) and n = o ( n ) are both true. (c) No. If f and g grow at the same rate, then
f ( n ) = O ( g ( n )), but f ( n ) 6 = o ( g ( n )). For instance, 3 n = O ( n ), but 3 n 6 = o ( n ). (d) Yes. In fact, it
is guaranteed! If f grows slower than g , then f grows no faster than g .
7.25
Evaluation of Solution 1:  Although this proof sounds somewh at reasonable, it is way too informal
and convoluted. Here are some of the problems.
1. This student misunderstands the concept behind ‘ignorin g the constants.’ We can ignore
the constants after we know that f ( n ) = O ( g ( n )). We can’t ignore them in order to prove
it.
2. The phrase ‘become irrelevant’ (used twice) is not precis e. We have developed mathe-
matical notation for a reason—it allows us to make statement s like these precise. It’s
kind of like saying that a certain car costs ‘a lot’. What is ‘a lot’? Although $ 30,000
might be a lot for most of us, people with a lot more money than I have might not think
$ 500,000 is a lot. that
k k − 1 k 3. The phrase ‘This leaves us with n + n + ··· + n = O ( n )’ is odd. What precisely do
they mean? That this is true or that this is what we need to prov e now? In either case,
it is incorrect. Similarly for the second time they use the ph rase ‘This leaves us with’.

Exercise Solutions 485
4. The second half of the proof is unnecessarily convoluted. They essentially are claiming
k k that their proof has boiled down to showing that n = O ( n ). To prove this, they use
an incredibly drawn out, yet vague, explanation that is in a s ingle unnecessarily long
sentence. Why are they even bringing Θ and Ω into this proof? W hy don’t they just
k k k k say something like ‘since n ≤ 1 n for all n ≥ 1, n = O ( n )’? I believe the answer is
obvious: they don’t really understand what they are doing he re. They clearly have a
vague understanding of the notation, but they don’t underst and the formal definition.
The bottom line is that this student understands that the sta tement they needed to prove
is correct, and they have a vague sense of why it is true, but they did not have a clear
understanding of how to use the definition of Big-O to prove it . The most important thing
to take away from this example is this: Be precise, use the notation and definitions you have
learned, and if your proofs look a lot different than those in t he book, you might question
whether or not you are on the right track.
Evaluation of Solution 2:  This proof is correct.
7.26 We cannot say anything about the relative growth rates of f ( n ) and g ( n ) because we are
2 only given upper bounds for each. It is possible that f ( n ) = n and g ( n ) = n , so that f ( n ) grows
faster, or vice-versa. They could also both be n .
7.27 (a) F. This is saying that f ( n ) grows no faster than g ( n ). (b) F. They grow at the same
2 rate. (c) F. f ( n ) might grow slower than g ( n ). For instance, f ( n ) = n and g ( n ) = n . (d) F. They
2 might grow at the same rate. For instance, f ( n ) = g ( n ) = n . (e) F. If f ( n ) = n and g ( n ) = n ,
2 7.18 . (g) F. If f ( n ) = n and g ( n ) = n , f ( n ) = O ( g ( n )), but f ( n ) 6 = Ω( g ( n )). (f) T. By Theorem
2 f ( n ) = O ( g ( n )), but f ( n ) 6 = Θ( g ( n )). (h) F. If f ( n ) = n and g ( n ) = n , f ( n ) = O ( g ( n )), but
g ( n ) 6 = O ( f ( n )).
1 1 7.37 c g ( n ) ≤ f ( n ) ≤ c g ( n ) for all n ≥ n ; f ( n ); f ( n ); c h ( n ) ≤ g ( n ) ≤ c h ( n ) for all n ≥
1 2 0 3 4 c c 2 1
n .; c ; c c ; max { n , n } ; c c h ( n ); c c h ( n ); Θ( h ( n )); Θ; transitive; 1 2 2 4 0 1 1 3 2 4
7.39 (a) T. By Theorem 7.36 . (b) T. By Theorem 7.18 . (c) T. By Theorem 7.32 . (d) F. The
2 backwards implication is true, but the forward one is not. Fo r instance, if f ( n ) = n and g ( n ) = n ,
clearly f ( n ) = O ( g ( n )), but f ( n ) 6 = Θ( g ( n )).  (e) F. Neither direction is true.  For instance, if
2 7.36 . (g) T. By f ( n ) = n and g ( n ) = n , f ( n ) = O ( g ( n )), but g ( n ) 6 = O ( f ( n )). (f) T. By Theorem
Theorem 7.18 . (h) T. By Theorem 7.28 .
1 3 10 − 6 1 1 1 2 2 2 2 7.42 c n ; c n ; − ; = ; n ; n ; 10.
1 2 2 n 20 5 5 2
3 is, so a smaller 7.43 There are a few ways to think about this. First, the larger n is, the smaller
n
amount is being subtracted. But that’s perhaps too fuzzy. Le t’s look at it this way:
10 n 3 3 3 3 1 3 1 3
n ≥ 10 ⇒ ≤ ⇒ ≤ ⇒− ≥− ⇒ − ≥ − .
3 3 n 10 n 10 2 n 2 10
7.45 (a) Theorem 7.18 . (b) Absolutely not! Theorem 7.18 requires that we also prove f ( n ) =
2 2 Ω( g ( n )). Here is a counterexample: n = O ( n ), but n 6 = Θ( n ). So f ( n ) = O ( g ( n )) does not imply
that f ( n ) = Θ( g ( n )).
n n 7.46 Notice that when n ≥ 1, n ! = 1 · 2 · 3 ··· n ≤ n · n ··· n = n . Therefore n ! = O ( n ) (We used
n = 1, and c = 1.) 0
′ such that 7.49 If f ( x ) = O ( g ( x )), then there are positive constants c and n
1 0
′ 0 ≤ f ( n ) ≤ c g ( n ) for all n ≥ n ,
1 0
′′ such that and if g ( x ) = O ( h ( x )), then there are positive constants c and n
2 0
′′ 0 ≤ g ( n ) ≤ c h ( n ) for all n ≥ n .
2 0

486 Chapter 12
′′ ′ ) and c = c c . Then , n Set n = max( n
3 1 2 0 0 0
0 ≤ f ( n ) ≤ c g ( n ) ≤ c c h ( n ) = c h ( n ) for all n ≥ n . 1 1 2 3 0
Thus f ( x ) = O ( h ( x )).
7.53 (a) ∞ (b) ∞ (c) ∞ (d) ∞ (e) 0 (f) 0 (g) 8675309
2 7.57 Theorem 7.51 part (b) implies that lim n = ∞ . Since the limit being computed was actually
n →∞
1
lim , Theorem 7.55 was used to obtain the final answer of 0 for the limit. 2
n →∞ n
3 3 x 3 2
= lim 3 x = ∞ , so 3 x = ω ( x ) by the second case of the 7.58 Notice that lim 2 x →∞ x →∞ x
3 2 7.50 , which also implies that 3 x = Ω( x ). Theorem
2 1 1 1 n + n 1 n ( n + 1) / 2
= lim = lim + = + 0 = , so n ( n + 1) / 2 = 7.63 Notice that  lim 2 2
n →∞ n →∞ n →∞ n 2 n 2 2 n 2 2
2 Θ( n ).
ã Å x x
2 2
7.64 (a) Since lim = 0, the result follows. = lim x
x →∞ x →∞ 3 3
( ) ( ) x x 3 2 × 3 x x x x x x
(b) If x ≥ 1, then clearly (3 / 2) ≥ 1, so 2 ≤ 2 = = 3 . Therefore, 2 = O (3 ). 2 2
7.70
x x x x Evaluation of Proof 1:  7 grows faster than 5 does not mean 7 − 5 > 0 for all x 6 = 0. For one
thing, we are really only concerned about positive values of x . Further, we are specifically
concerned about very large values of x . In other words, we want something to be true for all
x that are ‘large enough’. Also, this statement does not take i nto account constant factors.
x x Similarly, a tight bound does not imply that 7 − 5 = 0. The bottom line: This one is way
off. They are not conveying an understanding of what ‘upper bou nd’ really means, and they
certainly haven’t proven anything. Frankly, I don’t think t hey have a clue what they are
trying to say in this proof.
Evaluation of Proof 2:  This one has several problems. First, the application of l’Hopital’s rule is
x 5 log 5
, which should make it obvious that l’Hopital’s incorrect. The result should be lim x
x →∞ 7 log 7
rule doesn’t actually help in this case. (The key to this one i s to do a little algebra.) The
next problem is the statement ‘but x log 7 gets there faster’. What exactly does that mean?
Asymptotically faster, or just faster? If the former, it nee ds to be proven. If the latter, that
x x isn’t enough to prove relative growth rates. Finally, even i f this showed that 5 = O (7 ),
x x that only shows that 7 is an upper bound on 5 . It does not show that the bound is not
tight. The bottom line is that bad algebra combined with vagu e statements falls way short
of a correct proof.
Evaluation of Proof 3:  This proof is very close to being correct. The main problem is that they
x x x x only stated that 5 = O (7 ), but they also needed to show that 5 6 = Θ(7 ). It turns out that
x x the theorem they mention also gives them that. So all they nee ded to add is ‘and 5 6 = Θ(7 )’
x x at the end. Technically, there is another problem—they shou ld have taken the limit of 5 / 7 .
x x What they really showed using the limit theorem is that 7 = ω (5 ), which is equivalent to
x x 5 = o (7 ). It isn’t a major problem, but technically the limit theore m does not directly give
them the result they say it does. If you are trying to prove tha t f ( x ) is bounded by g ( x ), put
f ( x ) on the top and g ( x ) on the bottom.
2 7.72 You should have come up with n log n for the upper bound. If you didn’t, now that you
know the answer, go back and try to write the proofs before rea ding them here. (a) If n > 1,
2 2 2 2 2 ln( n + 1) ≤ ln( n + n ) = ln(2 n ) = (ln 2 + ln n ) ≤ (ln n + 2 ln n ) = 3 ln n

Exercise Solutions 487
Thus when n > 1,
2 2 2 2 2 2 n ln( n + 1) + n ln n ≤ n 3 ln n + n ln n ≤ 3 n ln n + n ln n ≤ 4 n ln n .
2 2 2 Thus, n ln( n + 1) + n ln n = O ( n ln n ). (You may have different algebra in your proof. Just make
certain that however you did it that it is correct.)
2 2 2 n ln( n + 1) n ln( n + 1) + n ln n
=  lim + 1 (b)  lim 2 2
x →∞ x →∞ n ln n n ln n
2 ln( n + 1)
=  1 + lim
x →∞ n ln n
2 n
2 n + 1
=  1 + lim (l’Hopital) 1
x →∞ 1 · ln n + n ·
n
2 n
=  1 + lim 2
x →∞ ( n + 1)(ln n + 1)
2
(l’Hopital) =  1 + lim 1
2 x →∞ 2 n (ln n + 1) + ( n + 1) ·
n
2
=  1 + lim 1
x →∞ 2 n (ln n + 1) + n +
n
=  1 + 0 = 1.
2 2 2 Therefore, n ln( n + 1) + n ln n = Θ( n log n ).
2 5 10 7.74 We can see that ( n − 1) = Θ( n ) since
Å Å ã ã 5 5 2 2 5
1 n − 1 ( n − 1)
= lim 1 − = 1. = lim lim 10 2 2
n →∞ n →∞ n →∞ n n n
n +1 n − 1 n 7.75 The following limit shows that 2 + 5 = Θ(5 ).
Å ã n n − 1 n +1 n +1 n − 1
2 5 1 1 2 2 + 5
= lim + = lim 2 = 0 + . + lim n n n
n →∞ n →∞ n →∞ 5 5 5 5 5 5
n +1 n − 1 n − 1 Note that we could also have shown that 2 + 5 = Θ(5 ), but that is not as simple of a
function. a
1 n a − b
= lim n = lim = 0. By Theorem 7.78 Since a < b , b − a > 0. Therefore, lim 7.50 , b b − a
n →∞ n →∞ n →∞ n n
a b n = o ( n ).
) ( n n a a
n n = 0. By Theorem = lim = o ( b ). 7.81 Since a < b , a/b < 1. Therefore, lim 7.50 , a
n n →∞ n →∞ b b
n n n n 7.86 (a) False since 3 grows faster than 2 . (b) True since 2 grows slower than 3 . (c) False
n n since 3 grows faster than 2 , which means it does not grow slower or at the same rate. (d) Tr ue
since they both have the same growth rate.  Remember, exponen tials with different bases have
different growth rates, but logarithms with different bases hav e the same growth rate. (e) True
since they have the same growth rate. Remember that if f ( n ) = Θ( g ( n )), then f ( n ) = O ( g ( n )) and
f ( n ) = Ω( g ( n )). (f) False since they have the same growth rate, so log n does not grow slower 10
than log n . 3
1
1 log ( n ) n ln( c ) c
= lim = lim = 0 since b > 0. 7.89 Using l’Hopital’s rule, we have lim b b − 1 b
n →∞ n →∞ n →∞ n b n ln( c ) b n
b 7.50 tells us that log n = o ( n ). Thus, Theorem
c
7.94 (a) Θ; (b) o ( O is correct, but not precise enough.); (c) Θ; (d) o ( O is correct, but not precise
n n − 1 enough.); (e) Θ since 2 = 2 2 ; (f) Ω (Technically it is ω , but I’ll let it slide if you put Ω since
we haven’t used ω much.); (g) through (j) are all o ( O is correct, but not precise enough.)

488 Chapter 12
7.96 If your answers do not all start with Θ, go back and redo them be fore reading the answers.
7 8 2 n Your answers should match the following exactly . (a) Θ( n ). (b) Θ( n ). (c) Θ( n ). (d) Θ(3 ). (e)
n 2 .000001 n Θ(2 ). (f) Θ( n ). (g) Θ( n ). (h) Θ( n ).
7.97 Here is the correct ranking (where ∼ indicates two functions grow at the same rate):
300 300 .000001 x log 3 2 5 x x 2 10000, log x ∼ log( x ), log x , x , x ∼ log(2 ), x log( x ), x , x , x ,  2 ,  3 .
7.98 Modern computers use multitasking to perform several tasks (seemingly) at the same time.
Therefore, if an algorithm takes 1 minute of real time (wall- clock time), it might be that 58 seconds
of that time was spent running the algorithm, but it could als o be the case that only 30 seconds
of that time were spent on that algorithm, and the other 30 sec onds spent on other processes. In
this case, the CPU time would be 30 seconds, but the wall-cloc k time 60 seconds.
Further complicating matters is increasing availability o f machines with multiple processors.
If an algorithm runs on 4 processors rather than one, it might take 1/4th the time in terms of
wall-clock time, but it will probably take the same amount of CPU time (or close to it).
7.99 We cannot be certain whose algorithm is better with the given information.  Maybe Sue
used a TRS-80 Model IV from the 1980s to run her program and Stu used Tianhe-2 (The fastest
computer in the world from about 2013-2014). In this case, it is possible that if Sue ran her program
on Tianhe-2 it would have only taken 2 minutes, making her the real winner .
7.100 As has already been mentioned, other processes on the machin e can have a significant
influence on the wall-clock time. For instance, if I run two CP U-intensive programs at once, the
wall-clock time of each might be about twice what it would be i f I ran them one at a time. If they
are run on a machine with multiple cores the wall-clock time m ight be closer to the CPU-time. But
other processes that are running can still throw off the numbe rs.
7.101 For the most part, yes. This is especially true if the running times of the algorithms are
not too close to each other (in other words, if one of the algor ithms is significantly faster than the
other). However, the number of other processes running on th e machine can have an influence on
CPU-time. For instance, if there are more processes running , there are more context switches, and
depending on how the CPU-time is counted, these context swit ches can influence the runtime. So
although comparing the CPU-time of two algorithms that are r un on the same computer gives a
pretty good indication of which is better, it is still not per fect.
7.103 This one is a little more tricky. The answer is n · m since this is how many entries are in the
matrix. Sometimes we need to use two numbers to specify the in put size. As suggested previously,
we will ignore the size of the two other pieces of data.
7.109 We focus on the assignment (=) inside the loop and ignore the o ther instructions. This
should be fine since assignment occurs at least as often as any other instruction. In addition, it is
important to note that max takes constant time (did you remember to explicitly say this ?), as do all
of the other operations, so we aren’t under-counting. It isn ’t too difficult to see that the assignment
will occur n times for an array of size n since the code goes through a loop with i = 0, . . . , n − 1.
Thus, the complexity of maximum is always Θ( n ). That is, Θ( n ) is the best, average, and worst-case
complexity of maximum .
7.112 The line in the inner for loop takes constant time (let’s call it c ). The inner loop executes
k = 50 times, each time doing c operations. Thus the inner loop does 50 · c operations, which is
still just a constant. The outer loop executes n times, each time executing the inner loop, which
takes 50 · c operations. Thus, the whole algorithm takes 50 · c · n = Θ( n ) time.
2 7.113 The line in the inner for loop takes constant time (let’s call it c ). The inner loop executes n
2 2 times since j is going from 0 to n − 1, so each time the inner loop executes, it does cn operations.
The outer loop executes n times, each time executing the inner loop.  Thus, the total ti me is
2 3 n × cn = Θ( n ).
2 This is an example of an algorithm with a double-nested loop t hat is worse than Θ( n ). The

Exercise Solutions 489
point of this exercise is to make it clear that you should neve r jump to conclusions too quickly
when analyzing algorithms. Read the limits on loops very car efully!
7.116 (a) AreaTrapezoid is constant. (b) factorial is not constant. It should be easy to see that
it has a complexity of Θ( n ). (c) absoluteValue is constant if we assume sqrt takes constant time.
7.121 Although it has a nested loop, the inside loop always execute s 6 times, which is a constant.
2 So the algorithm takes about 6 · c · n = Θ( n ) operations, not Θ( n ).
2 7.126 (a) Since factorial has a complexity of Θ( n ), it is not quadratic. (b) Since there are n
2 2 entries it to consider, the algorithm takes Θ( n ) time, so it would be quadratic.
7.127 Bubble sort, selection sort, and insertion sort are three of them that you may have seen
before.
7.133 As we mentioned in our analysis, executing the conditional s tatement takes about 3 opera-
tions, and if it is true, about 3 additional operations are pe rformed. So the worst case is no more
2 than about twice as many operations as the best case. In other words, we are comparing c · n to
2 2 2 c · n , both of which are Θ( n ).
7.136 Since both of these methods require accessing the i th element of the list for some integer i ,
and since we must traverse the list from the head, clearly the complexity of both methods is Θ( i ).
We could be less specific and say that the complexity is Θ( n ) since 0 ≤ i < n . However, when
analyzing algorithms that make repeated calls to these meth ods, using Θ( i ) might give a more
accurate answer overall. It makes the analysis more difficult , but sometimes it is worth it.
Note: For doubly-linked lists, some implementations trave rse starting at the tail if the index is
closer to the end of the list. However, that just means the com plexity is no worse than Θ( n/ 2) =
Θ( n ) . In other words, it only changes the complexity by a constant f actor.
7.138 All of them should be Θ(1), assuming we keep track of how many e lements are currently in
the stack (which is a reasonable thing to do).
7.139 For an array, either enqueue or dequeue (but not both) will be Θ( n ). All of the others will
be Θ(1), assuming we keep track of how many elements are curre ntly in the queue. Note that the
advantage of the circular array implementation is that both enqueue and dequeue are Θ(1).
7.140 For the array implementation, addToFront, removeFirst and contains will all be Θ( n ) and
the rest will be Θ(1). For the linked list implementation, co ntains will be Θ( n ) and the rest will be
constant if we assume there is both a head and tail pointer. If there is no tail pointer, addToEnd
will be Θ( n ).
7.141 For unbalanced, all operations can be done in Θ( h ) time, where h is the height of the tree.
This is the best answer you can give. You could also say O ( n ) time since the height is no more
then n , but this answer is not precise enough to be of much use. You cannot say Θ(log n ) since this
is not necessarily true for an unbalanced tree.
For balanced (red-black, AVL, etc.), all operations can be i mplemented with complexity Θ(log n ).
7.142 The average-case complexity for all of these operations is Θ (1), and the worst-case complexity
is Θ( n ).
7.143
n is an Evaluation of Solution 1:  I have no idea what logic they are tr ying to use here. Sure, a
exponential function, but what does that have to do with how l ong this algorithm takes?
This solution is way off.
Evaluation of Solution 2:  Having the i in the answer is nonsense since it doesn’t mean anything
in the context of a complexity—it is just a variable that happ ens to be used to index a
2 2 Technically this is linear with respect to the size of the input since the size of the input is n . But it is quadratic
2 in n . In either case, it is Θ( n ).

490 Chapter 12
loop. Further, the answer should be given using Θ-notation. So this solution is just plain
wrong. Since having an i in the complexity does not make any sense, this person either has a
fundamental misunderstanding of how to analyze algorithms or they didn’t think about their
final answer. Don’t be like this person!
Evaluation of Solution 3:  This solution is O.K., but it has a s light problem. Although the analysis
given estimates the worst-case behavior, it over-estimate s it. By replacing i with n − 1, they
are over-estimating how long the algorithm takes.  The call t o pow only takes n − 1 time
2 once. This solution can really only tell us that the complexi ty is O ( n ). Is it possible the
2 over-estimation of time resulted in a bound that isn’t tight ? Even if it turns out that Θ( n )
is the correct bound, this solution does not prove it. Althou gh they are on the right track,
this person needed to be a little more careful in their analys is.
7.144 Before you read too far: if you did not use a summation in your s olution, go back and try
again! This is very similar to the analysis of bubblesort . The for loop takes i from 0 to n − 1, and
each time the code in the loop takes i time (since that is how long power(a,i) takes). Thus, the
complexity is
n − 1 ∑
( n − 1) n 2
= Θ( n ). i =
2
i =0
2 Notice that just because the answer is Θ( n ), that does not mean that the third solution to Eval-
7.143 was correct. As we stated in the solution to that problem, bec ause they overestimated uate
2 the number of operations, they only proved that the algorith m has complexity O ( n ).
7.145 Here is one solution.
double addPowers( double a, int n) {
if (a==1) {
return n;
} else {
double sum = 1; // for the $ a^0 $ term.
double pow = 1;
for ( int i=1;i 0. (c) Yes. For any value
n > 0, the recursive call uses the value n − 1, which is getting closer to the base case of 0.
8.38 Notice that if n ≤ 0, countdown(0) prints nothing, so it works in that case. For k ≥ 0, assume
4 countdown(k) works correctly. Then countdown(k+1) will print ‘ k + 1’ and call countdown(k) . By
the inductive hypothesis, countdown(k) will print ‘k k-1 . . . 2 1’, so countdown(k+1) will print ‘k+1
k k-1 . . . 2 1’, so it works properly. By PMI, countdown(n) works for all n ≥ 0.
8.42 It is pretty clear that the recursive algorithm is much short er and was a lot easier to write.
It is also a lot easier to make a mistake implementing the iter ative algorithm. So far, it looks like
the recursive algorithm is the clear winner. However, in the next section we will show you why the
recursive algorithm we gave should never be implemented. It turns out that is is very inefficient.
The bottom line is that the iterative algorithm is better in t his case. Don’t feel bad if you
thought the recursive algorithm was better. After the next s ection, you will be better prepared to
compare recursive and iterative algorithms in terms of effici ency.
8.45 PrintN will print from 1 to n , and NPrint will print from n to 1. If you go the answer wrong,
go back and convince yourself that this is correct.
8.48 (a) r . (b) 1. (c) a + 2 · a + 3 · a + 4 · a . (d) There are none. n − 1 n − 2 n − 3 n − 4 n/ 2
8.52 It means to find a closed-form expression for it. In other word s, one that does not define the
sequence recursively.
8.54 When n = 1, T (1) = 1 = 0 + 1 = log 1 + 1. Assume that T ( k ) = log k + 1 for all 1 ≤ k < n 2 2
(we are using strong induction). Then
T ( n )  = T ( n/ 2) + 1
=  (log ( n/ 2) + 1) + 1 2
=  log n − log 2 + 2 2 2
=  log n − 1 + 2 2
=  log n + 1. 2
So by PMI, T ( n ) = log n + 1 for all n ≥ 1. 2
8.56 We begin by computing a few values to see if we can find a pattern . A (2) = A (1) + 2 =
2 + 2 = 4, A (3) = A (2) + 2 = 4 + 2 = 6, A (4) = 8, A (5) = 10, etc. It seems pretty obvious
that A ( n ) = 2 n .  It holds for n = 1, so we have our base case.  Assume A ( n ) = 2 n .  Then
A ( n + 1) = A ( n ) + 2 = 2 n + 2 = 2( n + 1), so it holds for n + 1. By PMI, A ( n ) = 2 n for all n ≥ 1.
8.59 It contains 3 very different looking recursive terms so it is ve ry unlikely we will be able to
find any sort of meaningful pattern by iteration.
4 We are letting n = 0 be the base case. You could also let n = 1 be the base case, but then you would need to
prove that countdown(1) works.

498 Chapter 12
8.61
H ( n )  =  2 H ( n − 1) + 1
=  2(2 H ( n − 2) + 1) + 1
2 = 2 H ( n − 2) + 2 + 1
2 =  2 (2 H ( n − 3) + 1) + 2 + 1
3 2 = 2 H ( n − 3) + 2 + 2 + 1
. .
.
n − 1 n − 2 n − 3 =  2 H (1) + 2 + 2 + ··· + 2 + 1
n − 1 n − 2 n − 3 =  2 + 2 + 2 + ··· + 2 + 1
n =  2 − 1
n 8.55 . Thus, H ( n ) = 2 − 1. Luckily, this matches our answer from Example
8.63 Iterating a few steps, we discover:
T ( n )  = T ( n/ 2) + 1
= T ( n/ 4) + 1 + 1
2 = T ( n/ 2 ) + 2 (I think I see a pattern!)
3 = T ( n/ 2 ) + 1 + 2
3 = T ( n/ 2 ) + 3 (I do see a pattern!)
. .
.
k = T ( n/ 2 ) + k
k We need to find k such that n/ 2 = 1. We already saw in Example 8.60 that k = log n is the
2
solution. Therefore, we have
k T ( n )  = T ( n/ 2 ) + k
log n 2 = T ( n/ 2 ) + log n
2
= T (1) + log n 2
=  1 + log n 2
Therefore, T ( n ) = 1 + log n . 2
n +1 n − 1 8.64 The final answer is T ( n ) = 2 − n − 2 or T ( n ) = 4 · 2 − n − 2. It is important that
you can work this out yourself, so try your best to get this ans wer without looking further. But if
you get stuck or have a different answer, you can refer to the fol lowing skeleton of steps–we have
omitted many of the steps because we want you to work them out. It does provide a few reference

Exercise Solutions 499
points along the way, however.
T ( n )  =  2 T ( n − 1) + n
=  2(2 T ( n − 2) + ( n − 1)) + n (having n instead of ( n − 1) is a common error)
2 =  2 T ( n − 2) + 3 n − 2 (it is unclear yet if I should have 3 n − 2 or some other form)
. .
. (many skipped steps)
k − 1 ∑
i k k i 2 (the all-important pattern revealed) =  2 T ( n − k ) + (2 − 1) n −
i =1
. .
. (plug in appropriate value of k and simplify)
n +1 =  2 − n − 2.
0 0 8.69 Here, a = 2, b = 2, and d = 0. ( d = 0 since 1 = 1 · n . In general, c = c · n , so when f ( n ) is
0 log a 1 a , we have T ( n ) = Θ( n ) = Θ( n ) = Θ( n ) by the third case of a constant, d = 0.) Since a > 2
the Master Theorem.
2 8.71 We have a = 7, b = 2, and d = 2. Since 7 > 2 , the third case of the Master Theorem applies
log 7 2.8 2 so T ( n ) = Θ( n ), which is about Θ( n ).
log 7 2.8 2 8.72 Because it isn’t true. Although the growth rate of n and n are close, they are not
log 7 2.8 log 7 2.81 2 2 exactly the same, so Θ( n ) 6 = Θ( n ). We could say that T ( n ) = Θ( n ) = O ( n ), but
then we have lost the ‘tightness’ of the bound. And I want to be able to say “Yo dawg, that bound
is really tight !”
0 8.73 Here we have a = 1, b = 2, and d = 0.  Since 1 = 2 , the second case of the Master
0 Theorem tells is that T ( n ) = Θ( n log n ) = Θ(log n ). Since we have already seen several times that
T ( n ) = log n + 1, we can notice that this answer is consistent with those. I t’s a good thing. 2
8.79 By raising the subscripts in the homogeneous equation we obt ain the characteristic equation
n n − 1 n x = 9 x or x = 9. A solution to the homogeneous equation will be of the form x = A (9) .
n
Now f ( n ) = − 56 n + 63 is a polynomial of degree 1 and so we assume that the soluti on will have
n the form x = A 9 + Bn + C . Now x = 2, x = 9(2) − 56+63 = 25, x = 9(25) − 56(2)+63 = 176.
n 0 1 2
We thus solve the system
2 = A + C ,
25 = 9 A + B + C ,
176 = 81 A + 2 B + C .
n We find A = 2, B = 7, C = 0, so the solution is x = 2(9 ) + 7 n .
n
2 2 8.83 The characteristic equation is x − 4 x + 4 = ( x − 2) = 0. There is a multiple root and so we
n n must test a solution of the form x = A 2 + Bn 2 . The initial conditions give
n
1 = A ,
4 = 2 A + 2 B .
n n This solves to A = 1, B = 1. The solution is thus x = 2 + n 2 .
n
1 8.85 We have a = 2, b = 2, and d = 1. Since 2 = 2 , we have that T ( n ) = Θ( n log n ) by the
second case of the Master Theorem.
8.86 (a) C and C are of lower order than n . Thus, we can do this according to part (c) of 1 2
7.28 . (b) We know that the Θ( n ) represents some function f ( n ). By definition of Θ, Theorem
there are constants, c and c such that c n ≤ f ( n ) ≤ c n for all n ≥ n for some constant n . So 1 2 1 2 0 0

500 Chapter 12
we essentially replaced f ( n ) with c n (since we are looking for a worst-case). Note that it doesn’t 2
matter what c is. We know there is some constant that works, so we just call i t c . 2
√
8.88 T ( n ) = 2 T ( n − 1) + T ( n − 5) + T ( n ) + 1 if n > 5, T (1) = T (2) = T (3) = T (4) = T (5) = 1.
You can also have + c instead of +1 in the recursive definition.
8.89 Beyond the recursive calls, StoogeSort does only a constant amount of work–we’ll call it
1. Then it makes three calls with sub-arrays of size (2 / 3) n . Therefore, T ( n ) = 3 T ((2 / 3) n ) + 1 or
T ( n ) = 3 T (2 n/ 3) + 1, with base case T (1) = 1.
8.90 We can use the Master Theorem for this one. a = 3, b = 3 / 2 and d = 0. (Notice that b 6 = 2 / 3!
0 If you made this mistake, make sure you understand why it is in correct.) Since 3 > 1 = (3 / 2) , the
Ä ä
log (3) 3 / 2 third case of the Master Theorem tells us that T ( n ) = Θ n . Although this looks weird, we
can have a rational number as the base of a logarithm (in fact, the base of ln ( n ) is e , an irrational
number). It might be helpful to compute the log since it isn’t clear how good or bad this complexity
2.71 2.71 is. Notice that log (3) ≈ 2. 71, so T ( n ) is approximately Θ( n ), but T ( n ) 6 = Θ( n ), so resist
3 / 2
the urge to place an equals sign between these. ) (
log (3) 3
2 8.91 The complexity of Mergesort is Θ( n log n ) and the complexity of StoogeSort is Θ n
) ( log (3)
3 2.7
2 grows faster than Θ( n log n ), so Mergesort is faster. Re- which is Ω( n ). Clearly Θ n
member: Faster growth rate means slower algorithm!
8.92 Let T ( n ) be the complexity of this algorithm. From the description, it seems pretty clear
that T ( n ) = 5 T ( n/ 3) + cn . Using the Master Theorem with a = 5, b = 3, and d = 1, we see that Ä ä
1 log (5) 1.46 3 5 > 3 , so the third case applies and T ( n ) = Θ n , which is approximately Θ( n ).
9.4 Nobody in their right mind will choose fruit if cake and ice cr eam are available, so there are
3 + 8 = 11 choices. Just kidding. There are really 3 + 8 + 5 = 16 diffe rent choices.
9.7 There are 26 choices for each of the first three characters, an d 10 choices for each of the final
3 3 three characters. Therefore, there are 26 · 10 possible license plates.
b b b k 1 2
, where 0 ≤ b ≤ a , 0 ≤ b ≤ a , . . . , 0 ≤ b ≤ a . 9.10 Every divisor of n is of the form p p ··· p 1 1 2 2 k k 1 2 k
(We could also write this as 0 ≤ b ≤ a for 0 ≤ i ≤ k .) Therefore there are a + 1 choices for b , i i 1 1
a +1 choices for b , all the way through a +1 choices for b . Since each of the b s are independent 2 2 i k k
of each other, the product rule tells us that the number of div isors of n is ( a +1)( a +1) ··· ( a +1). 1 2 k
9.11 Unless the p are distinct, the b s are not independent of each other. In other words, if the p s i i i
are distinct, then each different choice of the b s will produce a different number. But this is not i
3 2 the case if the p s are not distinct. For instance, if we write 32 = 2 2 , we can get the factor 4 as
i
2 0 1 1 0 2 2 2 , 2 2 , or 2 2 . Clearly we would count 4 three times and would obtain the inc orrect number
of divisors.
.  There are two choices for each plus sign–leave it or perform 9.13 Write n = 1 + 1 + ··· + 1
︷︷ ︸ ︸
′ n − 1 + s
n − 1 the addition. Each of the 2 ways of making choices leads to a different expression, and eve ry
n − 1 expression can be constructed this way. Therefore, there ar e 2 such ways of expressing n .
9.15 This combines the product and sum rules.  We now have 10 + 26 = 36 choices for each
5 character, and there are 5 characters, so the answer is 36 .
n 9.16 Each bit can be either 0 or 1, so there are 2 bit strings of length n .
2 3 k − 1 9.18 53 · 63 ; 53 · 63 ; 53 · 63 .
9.21 It contains at least one repeated digit. The wording of your a nswer is very important. Your
answer should not be “it has some digit twice” since this is va gue–do you mean ‘exactly twice’? If
so, that is incorrect. If you mean ‘at least twice’, then it is better to be explicit and say it that
way or just say ‘repeated’. To be clear, we don’t know that it c ontains any digit exactly twice, and
we also don’t know how many unique digits the number has–it mi ght be 22222222222, but it also

Exercise Solutions 501
might be 98765432101.
9.24 If all the magenta, all the yellow, all the white, 14 of the red and 14 of the blue marbles are
drawn, then in among these 8 + 10 + 12 + 14 + 14 = 58 there are no 15 m arbles of the same color.
Thus we need 59 marbles in order to insure that there will be 15 marbles of the same color.
9.25 She knows that you are the 25th person in line. If everyone get s 4 tickets, she will get none,
but you will get the 4 you want. She can get one or more tickets i f one or more people in front of
her, including you, get less than 4.
9.28 There are seven possible sums, each one a number in {− 3, − 2, − 1, 0, 1, 2, 3 } . By the Pigeonhole
Principle, two of the eight sums must add up to the same number .
16 ⌉ = 4, so some cat has at least four kittens. 9.31 We have ⌈
5
9.32
Evaluation of Proof 1:  This proof is incomplete. It kind of ar gues it for 5, not n in general. Even
then, the proof is neither clear not complete. For instance, what are the 4 ‘slots’?
Evaluation of Proof 2:  They only prove it for n = 2. It needs to be proven for any n .
Evaluation of Proof 3:  You can’t assume somebody had shaken h ands with everyone else without
some justification. You certainly can’t assume it was any par ticular person (i.e. person n ).
Similarly, you can’t assume the next person has shaken n − 2 hands without justifying it. The
final statement is weird (what does ‘fulfills the contradicti on’ mean?) and needs justification
(why is it a problem that the last person shakes no hands?).
9.33 Notice that if someone shakes n − 1 hands, then nobody shakes 0 hands and vice-verse. Thus,
we have two cases. If someone shakes n − 1 hands, then the n people can shake hands with between
1 and n − 1 other people. If nobody shakes hands with n − 1 people, then the n people can shake
hands with between 0 and n − 2 other people. In either case, there are n − 1 possibilities for the
number of hands that the n people can shake. The pigeonhole principle implies that two people
shake hands with the same number of people.
Note: You cannot say that the two cases are that someone shake s hands with n − 1 or someone
shakes hands with 0. It may be that neither of these is true. The two cases are someone shakes
hands with n − 1 others or nobody does. Alternatively, you could say someon e shakes hands with
0 others or nobody does.
9.34 Choose a particular person of the group, say Charlie. He corr esponds with sixteen others.
By the pigeonhole principle, Charlie must write to at least s ix of the people about one topic, say
topic I. If any pair of these six people corresponds about top ic I, then Charlie and this pair do the
trick, and we are done. Otherwise, these six correspond amon gst themselves only on topics II or
III. Choose a particular person from this group of six, say Er ic. By the Pigeonhole Principle, there
must be three of the five remaining that correspond with Eric a bout one of the topics, say topic II.
If amongst these three there is a pair that corresponds with e ach other on topic II, then Eric and
this pair correspond on topic II, and we are done. Otherwise, these three people only correspond
with one another on topic III, and we are done again.
9.38 EAT , ET A , AT E , AET , T AE , and T EA .
9.41 Since there are 15 letters and none of them repeat, there are 1 5! permutations of the letters
in the word uncopyrightable .
9.43 (a) 5 · 7 · 6 · 5 · 4 · 3 · 2 = 25, 200. (b) We condition on the last digit. If the last digi t were 1 or
5 then we would have 5 choices for the first digit and 2 for the la st digit. Then there are 6 left to
choose from for the second, 5 for the third, etc. So this leads to
5 · 6 · 5 · 4 · 3 · 2 · 2 = 7, 200

502 Chapter 12
possible phone numbers. If the last digit were either 3 or 7, t hen we would have 4 choices for the
first digit and 2 for the last. The rest of the digits have the sa me number of possibilities as above,
so we would have
4 · 6 · 5 · 4 · 3 · 2 · 2 = 5, 760
possible phone numbers. Thus the total number of phone numbe rs is
7200 + 5760 = 12, 960.
9.45 Label the letters T , A , L , and L . There are 4! permutations of these letters. However, 1 1 1 2
every permutation that has L before L is actually identical to one having L before L , so we 1 2 1 2
have double-counted. Therefore, there are 4! / 2 = 12 permutations of the letters in T ALL .
9.46 T ALL , T LAL , T LLA , AT LL , ALT L , ALLT , LLAT , LALT , LAT L , LLT A , LT LA , and
LT AL . That makes 12 permutations, which is exactly what we said it should be in Exercise 9.45 .
9.47 Following similar logic to the previous few examples, since we have one letter that is repeated
three times, and a total of 5 letters, the answer is 5! / 3! = 20.
9.48 Ten of them are AIEEE , AEIEE , AEEIE , AEEEI , EAIEE , EAEIE , EAEEI , EEAIE ,
EEAEI , EEEAI . The other ten are identical to these, but with the A and I swapped.
9.51 We can consider SM IT H as one block along with the remaining 5 letters A , L , G , O , and
R . Thus, we are permuting 6 ‘letters’, all of which are unique. So there are 6! = 720 possible
permutations.
6 5 5 9.54 (a) 5 · 8 = 1310720. (b) 5 · 8 · 4 = 655360. (c) 5 · 8 · 4 = 655360.
12 · 11 10 · 9 · 8 · 7 · 6 7 · 6 · 5 · 4 · 3
= 21. (b) = 66. (c) = 252. 9.58 (a)
1 · 2 · 3 · 4 · 5 1 · 2 1 · 2 · 3 · 4 · 5
200 · 199 · 198 · 197
(d) = 64, 684, 950. (e) 1.
1 · 2 · 3 · 4 Ç å Ç å Ç å Ç å
12 12 · 11 12 17 17 · 16 17
= 136. (b) = 66. = = 9.61 (a) = =
1 · 2 1 · 2 10 2 15 2
Ç å Ç å Ç å Ç å
200 · 199 · 198 · 197 200 200 67 67
(c) = = = 64, 684, 950. (d) = = 67 / 1 = 67.
196 4 1 · 2 · 3 · 4 66 1
9.65 12, 13, 14, 15, 23, 24, 25, 34, 35, 45.
9.68
Evaluation of Solution 1:  This solution does not take into ac count which woman was selected and
which 15 of the original 16 are left, so this is not correct.
Evaluation of Solution 2:  This solution has two problems. Fi rst, it counts things multiple times.
For instance, any selection that contains both Sally and Kim will be counted twice–once when
Sally is the first woman selected and again when Kim is selecte d first. Second, the product
rule should have been used instead of the sum rule. Of course, that hardly matters since it
would have been wrong anyway.
Evaluation of Solution 3:  This solution is correct.
9.70 To count the number of shortest routes from A to B that pass through point O , we count ) (
5 = 10) and the number of paths from the number of paths from A to O (of which there are
3 ) (
4 = 4).  Using the product rule, the desired number of paths is O to B (of which there are
3 Ç åÇ å
5 4
= 10 · 4 = 40.
3 3
9.71

Exercise Solutions 503
Evaluation of Solution 1:  This answer is incorrect since it w ill count some of the committees mul-
tiple times. If you did not come up with an example of somethin g that gets counted multiple
times, you should do so to convince yourself that this answer is incorrect.
Evaluation of Solution 2:  This solution is incorrect since i t does not take into account which man
and woman were selected and which 14 of the original 16 are lef t.
) ) ( ) ( ( 7 9 16
contain only contain only men and possible committees. Of these, 9.72 There are 5 5 5
women. Clearly these two sets of committees do not overlap. T herefore, the number of committees ) ( ( ) ( )
9 16 7 − that contain at least one man and at least one woman is − .
5 5 5
9.73 Because we subtracted the size of both of these from the total number of possible committees.
If the sets intersected, we would have subtracted some possi bilities twice and the answer would have
been incorrect.
9.75
Evaluation of Solution 1:  This solution is incorrect since i t double counts some of the possibilities.
Evaluation of Solution 2:  This solution is incorrect becaus e it does not take into account the re-
quirement that one course from each group must be taken.
9.76
Evaluation of Solution 1:  This solution is incorrect since i t counts some of the possibilities multiple
times.
Evaluation of Solution 2:  This solution is incorrect becaus e it does not take into account the re-
quirement that one course from each group must be taken.
9.79 Using 10 bars to separate the meat and 3 stars to represent the slices, we can see that this ) ) ( (
13 13 = 286. = is exactly the same as the previous two examples. Thus, the so lution is
3 10
9.84
Ç å Ç å Ç å Ç å Ç å
4 4 4 4 4 2 4 4 3 2 2 2 2 2 3 2 4
(2 x − y ) = (2 x ) + (2 x ) ( − y ) + (2 x ) ( − y ) + (2 x )( − y ) + ( − y )
0 1 2 3 4
4 3 2 2 2 2 2 3 2 4 =  (2 x ) + 4(2 x ) ( − y ) + 6(2 x ) ( − y ) + 4(2 x )( − y ) + ( − y )
4 3 2 2 4 6 8 =  16 x − 32 x y + 24 x y − 8 xy + y
9.85 √ √ √ √ √ √ √ √ √ √
4 4 3 2 2 3 4 ( 3 + 5) =  ( 3) + 4( 3) ( 5) + 6( 3) ( 5) + 4( 3)( 5) + ( 5)
√ √
=  9 + 12 15 + 90 + 20 15 + 25 √
=  124 + 32 15
9.87 Using a little algebra and the binomial theorem, we can see th at
Ç å Ç å Ç å n n n
∑ ∑ ∑ n n n
n − k k n n k k 1 3 − 1 = (1 + 3) − 1 = 4 − 1. 3 − 1 = 3 =
k k k
k =0 k =0 k =1
9.91 Let A be the set of camels eating wheat and B be the set of camels eating barley. We know
that | A | = 46, | B | = 57, and | A ∪ B | = 100 − 10 = 90. We want | A ∩ B | . By Theorem 9.89 (solving
it for | A ∩ B | ),
| A ∩ B | = | A | + | B |−| A ∪ B | = 46 + 57 − 90 = 13.

504 Chapter 12
9.95 Using Theorem 9.93 , we know that 28 + 29 + 19 − 14 − 10 − 12 + 8 = 48% watch at least one
of these sports. That leaves 52% that don’t watch any of them.
9.96 Let C denote the set of people who like candy, I the set of people who like ice cream, and
K denote the set of people who like cake. We are given that | C | = 816, | I | = 723, | K | = 645,
| C ∩ I | = 562, | C ∩ K | = 463, | I ∩ K | = 470, and | C ∩ I ∩ K | = 310. By Inclusion-Exclusion we
have
| C ∪ I ∪ K | = | C | + | I | + | K |
−| C ∩ I |−| C ∩ K |−| I ∩ C |
+ | C ∩ I ∩ K |
=  816 + 723 + 645 − 562 − 463 − 470 + 310
=  999.
The investigator miscounted, or probably did not report one person who may not have liked any
of the three things.
9.98 We can either use inclusion-exclusion for four sets or use a f ew applications of inclusion-
exclusion for two sets. Let’s try the latter.
Let A denote the set of those who lost an eye, B denote those who lost an ear, C denote those
who lost an arm and D denote those losing a leg. Suppose there are n combatants. Then
n ≥ | A ∪ B |
= | A | + | B |−| A ∩ B |
=  . 7 n +. 75 n −| A ∩ B | ,
n ≥ | C ∪ D |
= | C | + | D |−| C ∩ D |
=  . 8 n +. 85 n −| C ∩ D | .
This gives
| A ∩ B |≥ . 45 n ,
| C ∩ D |≥ . 65 n .
This means that
n ≥ | ( A ∩ B ) ∪ ( C ∩ D ) |
= | A ∩ B | + | C ∩ D |−| A ∩ B ∩ C ∩ D |
≥ . 45 n +. 65 n −| A ∩ B ∩ C ∩ D | ,
whence
| A ∩ B ∩ C ∩ D |≥ . 45+. 65 n − n =. 1 n .
This means that at least 10% of the combatants lost all four me mbers.
10.24 abed is a cycle of length 4 and ecdab is a cycle of length 5. Other answers are possible.
There is no cycle of length 6 since there are only 5 vertices in the graph and a cycle cannot repeat
a vertex.
10.27 You should have drawn something like this (but probably bigg er and with dots on the
corners):  △
10.30 You should have drawn something like this (but probably bigg er and with dots on the
corners and center): ×
10.31 You should have drawn a path of length 2 and 4 vertices not conn ected to anything.
Something like this: | . . . .
10.55

Exercise Solutions 505
A → D → E → F
B → D → E → F
C → D → E → F
D → A → B → C
E → A → B → C
F → A → B → C
10.56
A → D → E → F
B → D → E → F
C → D → E → F
→ D
→ E
→ F
10.61
A   B   C   D   E   E
 
A 0   0   0   1   1   1
  B 0   0   0   1   1   1
 
  C 0   0   0   1   1   1
 
  D 1   1   1   0   0   0
 
 
E 1   1   1   0   0   0
F 1   1   1   0   0   0
10.62
A   B   C   D   E   E
 
A 0   0   0   1   1   1
  B 0   0   0   1   1   1
 
  C 0   0   0   1   1   1
 
  D 0   0   0   0   0   0
 
  E 0   0   0   0   0   0
F 0   0   0   0   0   0
10.73 Did you draw a triangle with a vertex in the middle connected t o the three vertices of the
triangle? I thought so!
10.79 Notice that K does not have C as a subgraph.  Since K has 3 · 3 = 9 edges and 3,3 3 3,3
9 > 8 = 2(6) − 4, Theorem 10.77 part (b) implies that K is not planar. 3,3

506 Chapter 12

GNU Free Documentation License
Version 1.2, November 2002
Copyright © 2000,2001,2002 Free Software Foundation, Inc.
51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
Everyone is permitted to copy and distribute verbatim copie s of this license document, but changing it is not allowed.
Preamble
The purpose of this License is to make a manual, textbook, or o ther functional and useful document “free” in the sense of fr eedom: to assure
everyone the effective freedom to copy and redistribute it, w ith or without modifying it, either commercially or noncomm ercially. Secondarily, this
License preserves for the author and publisher a way to get cr edit for their work, while not being considered responsible for modifications made
by others.
This License is a kind of “copyleft”, which means that deriva tive works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyl eft license designed for free software.
We have designed this License in order to use it for manuals fo r free software, because free software needs free documenta tion: a free program
should come with manuals providing the same freedoms that th e software does. But this License is not limited to software m anuals; it can be used
for any textual work, regardless of subject matter or whethe r it is published as a printed book. We recommend this License principally for works
whose purpose is instruction or reference.
1. APPLICABILITY AND DEFINITIONS
This License applies to any manual or other work, in any mediu m, that contains a notice placed by the copyright holder sayi ng it can be
distributed under the terms of this License. Such a notice gr ants a world-wide, royalty-free license, unlimited in dura tion, to use that work under
the conditions stated herein. The “ Document ”, below, refers to any such manual or work. Any member of the p ublic is a licensee, and is addressed
as “ you ”. You accept the license if you copy, modify or distribute th e work in a way requiring permission under copyright law.
A “ Modified  Version ” of the Document means any work containing the Document or a p ortion of it, either copied verbatim, or with
modifications and/or translated into another language.
A “ Secondary Section ” is a named appendix or a front-matter section of the Documen t that deals exclusively with the relationship of the
publishers or authors of the Document to the Document’s over all subject (or to related matters) and contains nothing tha t could fall directly
within that overall subject. (Thus, if the Document is in par t a textbook of mathematics, a Secondary Section may not expl ain any mathematics.)
The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commer cial, philosophical, ethical
or political position regarding them.
The “ Invariant  Sections ” are certain Secondary Sections whose titles are designate d, as being those of Invariant Sections, in the notice
that says that the Document is released under this License. I f a section does not fit the above definition of Secondary then i t is not allowed to be
designated as Invariant. The Document may contain zero Inva riant Sections. If the Document does not identify any Invari ant Sections then there
are none.
The “ Cover Texts ” are certain short passages of text that are listed, as Front -Cover Texts or Back-Cover Texts, in the notice that says tha t
the Document is released under this License. A Front-Cover T ext may be at most 5 words, and a Back-Cover Text may be at most 2 5 words.
A “ Transparent ” copy of the Document means a machine-readable copy, repres ented in a format whose specification is available to the
general public, that is suitable for revising the document s traightforwardly with generic text editors or (for images c omposed of pixels) generic
paint programs or (for drawings) some widely available draw ing editor, and that is suitable for input to text formatters or for automatic translation
to a variety of formats suitable for input to text formatters . A copy made in an otherwise Transparent file format whose mar kup, or absence of
markup, has been arranged to thwart or discourage subsequen t modification by readers is not Transparent. An image format is not Transparent if
used for any substantial amount of text. A copy that is not “Tr ansparent” is called “ Opaque ”.
Examples of suitable formats for Transparent copies includ e plain ASCII without markup, Texinfo input format, LaTeX in put format, SGML
or XML using a publicly available DTD, and standard-conform ing simple HTML, PostScript or PDF designed for human modific ation. Examples
of transparent image formats include PNG, XCF and JPG. Opaqu e formats include proprietary formats that can be read and ed ited only by
proprietary word processors, SGML or XML for which the DTD an d/or processing tools are not generally available, and the m achine-generated
HTML, PostScript or PDF produced by some word processors for output purposes only.
The “ Title Page ” means, for a printed book, the title page itself, plus such f ollowing pages as are needed to hold, legibly, the material t his
License requires to appear in the title page. For works in for mats which do not have any title page as such, “Title Page” mea ns the text near the
most prominent appearance of the work’s title, preceding th e beginning of the body of the text.
A section “ Entitled XYZ ” means a named subunit of the Document whose title either is p recisely XYZ or contains XYZ in parentheses follow-
ing text that translates XYZ in another language. (Here XYZ s tands for a specific section name mentioned below, such as “ Acknowledgements ”,
“ Dedications ”, “ Endorsements ”, or “ History ”.) To “ Preserve the Title ” of such a section when you modify the Document means that it
remains a section “Entitled XYZ” according to this definitio n.
The Document may include Warranty Disclaimers next to the no tice which states that this License applies to the Document. These Warranty
Disclaimers are considered to be included by reference in th is License, but only as regards disclaiming warranties: any other implication that these
Warranty Disclaimers may have is void and has no effect on the m eaning of this License.
2. VERBATIM COPYING
You may copy and distribute the Document in any medium, eithe r commercially or noncommercially, provided that this Lice nse, the copyright
notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions
whatsoever to those of this License. You may not use technica l measures to obstruct or control the reading or further copy ing of the copies you
make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must
also follow the conditions in section 3.
You may also lend copies, under the same conditions stated ab ove, and you may publicly display copies.
3. COPYING IN QUANTITY
507

508 Chapter 12
If you publish printed copies (or copies in media that common ly have printed covers) of the Document, numbering more than 100, and
the Document’s license notice requires Cover Texts, you mus t enclose the copies in covers that carry, clearly and legibl y, all these Cover Texts:
Front-Cover Texts on the front cover, and Back-Cover Texts o n the back cover. Both covers must also clearly and legibly id entify you as the
publisher of these copies. The front cover must present the f ull title with all words of the title equally prominent and vi sible. You may add other
material on the covers in addition. Copying with changes lim ited to the covers, as long as they preserve the title of the Do cument and satisfy these
conditions, can be treated as verbatim copying in other resp ects.
If the required texts for either cover are too voluminous to fi t legibly, you should put the first ones listed (as many as fit re asonably) on the
actual cover, and continue the rest onto adjacent pages.
If you publish or distribute Opaque copies of the Document nu mbering more than 100, you must either include a machine-rea dable Transparent
copy along with each Opaque copy, or state in or with each Opaq ue copy a computer-network location from which the general n etwork-using public
has access to download using public-standard network proto cols a complete Transparent copy of the Document, free of add ed material. If you
use the latter option, you must take reasonably prudent step s, when you begin distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated l ocation until at least one year after the last time you distri bute an Opaque copy
(directly or through your agents or retailers) of that editi on to the public.
It is requested, but not required, that you contact the autho rs of the Document well before redistributing any large numb er of copies, to give
them a chance to provide you with an updated version of the Doc ument.
4. MODIFICATIONS
You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the M odified Version filling the role of the Document, thus licensi ng distribution and
modification of the Modified Version to whoever possesses a co py of it. In addition, you must do these things in the Modified V ersion:
A. Use in the Title Page (and on the covers, if any) a title dist inct from that of the Document, and from those of previous ver sions (which
should, if there were any, be listed in the History section of the Document). You may use the same title as a previous versio n if the original
publisher of that version gives permission.
B. List on the Title Page, as authors, one or more persons or en tities responsible for authorship of the modifications in th e Modified Version,
together with at least five of the principal authors of the Doc ument (all of its principal authors, if it has fewer than five) , unless they
release you from this requirement.
C. State on the Title page the name of the publisher of the Modi fied Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modification s adjacent to the other copyright notices.
F. Include, immediately after the copyright notices, a lice nse notice giving the public permission to use the Modified Ve rsion under the terms
of this License, in the form shown in the Addendum below.
G. Preserve in that license notice the full lists of Invarian t Sections and required Cover Texts given in the Document’s l icense notice.
H. Include an unaltered copy of this License.
I. Preserve the section Entitled “History”, Preserve its Ti tle, and add to it an item stating at least the title, year, new authors, and publisher
of the Modified Version as given on the Title Page. If there is n o section Entitled “History” in the Document, create one sta ting the title,
year, authors, and publisher of the Document as given on its T itle Page, then add an item describing the Modified Version as stated in
the previous sentence.
J. Preserve the network location, if any, given in the Docume nt for public access to a Transparent copy of the Document, an d likewise the
network locations given in the Document for previous versio ns it was based on. These may be placed in the “History” sectio n. You may
omit a network location for a work that was published at least four years before the Document itself, or if the original pub lisher of the
version it refers to gives permission.
K. For any section Entitled “Acknowledgements” or “Dedicat ions”, Preserve the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgeme nts and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document, unal tered in their text and in their titles. Section numbers or th e equivalent are not
considered part of the section titles.
M. Delete any section Entitled “Endorsements”. Such a secti on may not be included in the Modified Version.
N. Do not retitle any existing section to be Entitled “Endors ements” or to conflict in title with any Invariant Section.
O. Preserve any Warranty Disclaimers.
If the Modified Version includes new front-matter sections o r appendices that qualify as Secondary Sections and contain no material copied
from the Document, you may at your option designate some or al l of these sections as invariant. To do this, add their titles to the list of Invariant
Sections in the Modified Version’s license notice. These tit les must be distinct from any other section titles.
You may add a section Entitled “Endorsements”, provided it c ontains nothing but endorsements of your Modified Version by various parties–for
example, statements of peer review or that the text has been a pproved by an organization as the authoritative definition o f a standard.
You may add a passage of up to five words as a Front-Cover Text, a nd a passage of up to 25 words as a Back-Cover Text, to the end of
the list of Cover Texts in the Modified Version. Only one passa ge of Front-Cover Text and one of Back-Cover Text may be added by (or through
arrangements made by) any one entity. If the Document alread y includes a cover text for the same cover, previously added b y you or by arrangement
made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit perm ission from the
previous publisher that added the old one.
The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
5. COMBINING DOCUMENTS

Exercise Solutions 509
You may combine the Document with other documents released u nder this License, under the terms defined in section 4 above f or modified
versions, provided that you include in the combination all o f the Invariant Sections of all of the original documents, un modified, and list them all
as Invariant Sections of your combined work in its license no tice, and that you preserve all their Warranty Disclaimers.
The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced w ith a single copy.
If there are multiple Invariant Sections with the same name b ut different contents, make the title of each such section uni que by adding at the end
of it, in parentheses, the name of the original author or publ isher of that section if known, or else a unique number. Make t he same adjustment
to the section titles in the list of Invariant Sections in the license notice of the combined work.
In the combination, you must combine any sections Entitled “ History” in the various original documents, forming one sec tion Entitled
“History”; likewise combine any sections Entitled “Acknow ledgements”, and any sections Entitled “Dedications”. You must delete all sections
Entitled “Endorsements”.
6. COLLECTIONS OF DOCUMENTS
You may make a collection consisting of the Document and othe r documents released under this License, and replace the ind ividual copies
of this License in the various documents with a single copy th at is included in the collection, provided that you follow th e rules of this License for
verbatim copying of each of the documents in all other respec ts.
You may extract a single document from such a collection, and distribute it individually under this License, provided yo u insert a copy of
this License into the extracted document, and follow this Li cense in all other respects regarding verbatim copying of th at document.
7. AGGREGATION WITH INDEPENDENT WORKS
A compilation of the Document or its derivatives with other s eparate and independent documents or works, in or on a volume of a storage or
distribution medium, is called an “aggregate” if the copyri ght resulting from the compilation is not used to limit the le gal rights of the compilation’s
users beyond what the individual works permit. When the Docu ment is included in an aggregate, this License does not apply to the other works
in the aggregate which are not themselves derivative works o f the Document.
If the Cover Text requirement of section 3 is applicable to th ese copies of the Document, then if the Document is less than o ne half of the
entire aggregate, the Document’s Cover Texts may be placed o n covers that bracket the Document within the aggregate, or t he electronic equivalent
of covers if the Document is in electronic form. Otherwise th ey must appear on printed covers that bracket the whole aggre gate.
8. TRANSLATION
Translation is considered a kind of modification, so you may d istribute translations of the Document under the terms of se ction 4. Replacing
Invariant Sections with translations requires special per mission from their copyright holders, but you may include tr anslations of some or all
Invariant Sections in addition to the original versions of t hese Invariant Sections. You may include a translation of th is License, and all the license
notices in the Document, and any Warranty Disclaimers, prov ided that you also include the original English version of th is License and the original
versions of those notices and disclaimers. In case of a disag reement between the translation and the original version of this License or a notice or
disclaimer, the original version will prevail.
If a section in the Document is Entitled “Acknowledgements” , “Dedications”, or “History”, the requirement (section 4) to Preserve its Title
(section 1) will typically require changing the actual titl e.
9. TERMINATION
You may not copy, modify, sublicense, or distribute the Docu ment except as expressly provided for under this License. An y other attempt to
copy, modify, sublicense or distribute the Document is void , and will automatically terminate your rights under this Li cense. However, parties who
have received copies, or rights, from you under this License will not have their licenses terminated so long as such parti es remain in full compliance.
10. FUTURE REVISIONS OF THIS LICENSE
The Free Software Foundation may publish new, revised versi ons of the GNU Free Documentation License from time to time. S uch new
versions will be similar in spirit to the present version, bu t may differ in detail to address new problems or concerns.
See http://www.gnu.org/copyleft/.
Each version of the License is given a distinguishing versio n number. If the Document specifies that a particular numbere d version of this
License “or any later version” applies to it, you have the opt ion of following the terms and conditions either of that spec ified version or of any
later version that has been published (not as a draft) by the F ree Software Foundation. If the Document does not specify a v ersion number of this
License, you may choose any version ever published (not as a d raft) by the Free Software Foundation.
ADDENDUM: How to use this License for your documents
To use this License in a document you have written, include a c opy of the License in the document and put the following copyr ight and license
notices just after the title page:
© YEAR YOUR NAME. Permission is granted to copy, distribute an d/or modify this document under the terms of the Copyright
GNU Free Documentation License, Version 1.2 or any later ver sion published by the Free Software Foundation; with no Inva riant
Sections, no Front-Cover Texts, and no Back-Cover Texts. A c opy of the license is included in the section entitled “GNU Fr ee
Documentation License”.
If you have Invariant Sections, Front-Cover Texts and Back- Cover Texts, replace the “with . . . Texts.” line with this:
with the Invariant Sections being LIST THEIR TITLES, with th e Front-Cover Texts being LIST, and with the Back-Cover Text s
being LIST.
If you have Invariant Sections without Cover Texts, or some o ther combination of the three, merge those two alternatives to suit the situation.
If your document contains nontrivial examples of program co de, we recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit their use in free software.

510 Chapter 12

Index
∀ (for all), 27 ⊆ (subset), 86
6⊆ (not a subset), 86 O ( f ( n )) (Big-O), 226
⊂ (proper subset), 86 Ω( f ( n )) (Big-Omega), 229
∑
203 (summation), Θ( f ( n )) (Big-Theta), 230
∏
(product), 218 ω ( f ( n )) (little-omega), 232
algorithm, 137 o ( f ( n )) (little-o), 232
AND, 9 & (bitwise AND), 158
AND (bitwise), 158 ∼ (bitwise compliment), 157
anti-symmetric relation, 120 | (bitwise OR), 158
arithmetic progression, 200 ^ (bitwise XOR), 158
) ( n
arithmetic sequence, 200 384 (binomial coefficient),
k
array, 162 ≡ (congruence modulo n ), 100
assignment operator, 137 ∃ (there exists), 29
asymptotic notation, 225 ! (factorial), 48
⌊⌋ (floor), 102
base case, 308
⌈⌉ (ceiling), 102
base case (induction), 307
| (divides), 46
base case (recursion), 327
∧ (AND), 9
biconditional, 13
¬ (NOT), 9 , 30
Big-O, 226
∨ (OR), 9
Big-Omega, 229
⊕ (XOR), 10
Big-Theta, 230
→ (conditional), 12
binary search, 294 , 336
↔ (biconditional), 13
binomial coefficient, 384
= (logically equivalent), 21
Binomial Theorem, 392
mod operator, 100
bitwise operator
% (modulus), 100
158 AND,
| A | (set cardinality), 83
compliment, 157
∈ (element of set), 83
NOT, 157
6∈ (not element of set), 83
OR, 158
C (complex numbers), 84
XOR, 158
N (natural numbers), 84
boolean
Q (rational numbers), 84
7 proposition,
R (real numbers), 84
Z (integers), 84 cardinality, set, 83
+ Z (positive integers), 84
Cartesian product, 94
− Z (negative integers), 84
ceiling, 102
∅ (empty set), 84 characteristic equation, 350 , 352
{} (empty set), 84 choose, 384
∩ (intersection), 90 closed form (recurrence relation), 335
∪ (union), 90 combination, 386
A (complement of A ), 91 combinatorics, 367
\ (set-difference), 91 complement, set, 91
× (Cartesian product), 94 complete bipartite graph, 419
P ( A ) (power set), 88 complete graph, 417
511

512 INDEX
complex numbers, 84 exponential growth rate, 276
compliment, bitwise, 157
face, 431 composite, 47
factor, 46 compound proposition, 8
factorial, 48 , 159 , 326 conditional statement, 12
Fibonacci numbers, 196 , 315 , 331 , 334 , 339 , congruence modulo n , 100
353 conjunction, 9
Fibonacci sequence, 196 conjunctive clause, 32
finite set, 83 conjunctive normal form, 35
first order recurrence, 350 constant growth rate, 272
floor, 102 contingency, 19
for all, 27 contradiction, 19
for loop, 159 contradiction proof, 55
function contraposition
104 injective, proof by, 64
contrapositive, 52
geometric progression, 199
converse, 53
geometric sequence, 199
counterexample
geometric series, 214
proof by, 66
graph
CPU time, 263
431 planar,
cycle, 417
Hamilitonian cycle, 430
decreasing sequence, 196
Hamiltonian cycle, 430
DeMorgan’s Law
Hamiltonian graph, 430
for propositions, 22
homogeneous recurrence relation, 350
for quantifiers, 30
hypercube, 417
difference, set, 91
Dirac’s Theorem, 430 if-else statement, 147
direct proof, 43 implication, 51
disjoint, set, 92 inclusion-exclusion
disjunction, 9 397 three sets,
disjunctive clause, 35 two sets, 395
disjunctive normal form, 33 inclusive or, 9
divides, 46 increasing sequence, 196
divisor, 46 induction, 306
inductive case (recursion), 327
efficient algorithm, 275 inductive hypothesis, 308
element, of a set, 83 inductive step, 308
empty set, 84 infinite set, 83
equivalence class, 127 integers, 84
equivalence relation, 123 intersection, set, 90
equivalent inverse, 52
21 logically, irrational number, 59
Eulerian graph, 429 iteration method, 340
even, 43
exclusive or, 10 l’Hopital’s Rule, 249
existential quantifier, 29 linear growth rate, 274
exists, 29 linear recurrence relation, 350

INDEX 513
literal, 32 parity, 43
little-O, 232 partial order, 124
little-omega, 232 partition, 116
logarithmic growth rate, 273 Pascal’s Identity, 394
logical Pascal’s Triangle, 394
operator, 8 path, 412 , 417
AND, 9 permutation, 57 , 378
biconditional, 13 pigeonhole principle, 372
conditional, 12 planar graph, 431
conjunction, 9 polynomial growth rate, 275
disjunction, 9 positive integers, 84
exclusive or, 10 power set, 88
inclusive or, 9 precedence, logical operators, 17
negation, 9 predicate, 27
OR, 9 primality testing, 173
XOR, 10 prime, 47
logical operator, 8 product rule, 368
logically equivalent, 21 product-of-sums, 35
loop proof
159 for, 67 by cases,
while, 171 by contradiction, 55
by counterexample, 66
Master Method, 348
contrapositive, 64
mathematical induction, 306
direct, 43
maximum
induction, 306
array element, 162
trivial, 66
of three numbers, 147
proper subset, 86
of two numbers, 147
proposition, 7
mergesort, 354
compound, 8
mod, 100
propositional function, 27
modus ponens, 60 , 306
monotonic sequence, 196
quadratic growth rate, 274
multiple, 46
quantifier
29 existential, natural numbers, 84
universal, 27 negation, 9
quicksort, 358 quantifiers, 30
negative integers, 84
rational number, 59
non-monotonic sequence, 196
rational numbers, 84
non-recursive term (recurrence relation), 334
real numbers, 84
nonhomogeneous recurrence relation, 350
recurrence relations, 334
null set, 84
definition, 191
solving, 335 odd, 43
first-order, 350 operator
iteration method, 340 8 logical, see logical, operator,
linear, 350 OR, 9
Master method, 348 OR (bitwise), 158
outside face, 431 second-order, 352

514 INDEX
substitution method, 336 strong induction, 319
recursion, 326 subset, 86
recursive, 326 proper, 86
recursive term (recurrence relation), 334 substitution method, 336
reflexive relation, 118 sum notation, 203
relation, 117 sum rule, 367
anti-symmetric, 120 sum-of-products, 33
equivalence, 123 swapping, 139
reflexive, 118 symmetric relation, 119
symmetric, 119
tautology, 19 transitive, 122
tour, 429 reverse, an array, 164
Euler, 429
second order recurrence, 352 Towers of Hanoi, 356
sequence, 189 trail, 412 , 429
set, 83
Eulerian, 429
cardinality, 83
transitive relation, 122
complement, 91
trivial proof, 66
containment proof, 97
truth table, 14
difference, 91
truth value, 7
disjoint, 92
empty, 84 union, set, 90
finite, 83 universal quantifier, 27
infinite, 83 universal set, 92
intersection, 90 universe, 92
mutually exclusive, 92
operations, 90 Venn diagram, 90
partition, 116
power, 88 walk, 412
relation, 117 wall-clock time, 263
size, 83 weak induction, 319
union, 90 while loop, 171
universe, 92
XOR, 10 strictly decreasing sequence, 196
strictly increasing sequence, 196 XOR (bitwise), 158